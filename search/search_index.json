{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"glm-py","text":"<p>Python tools for running General Lake Model (GLM) simulations.</p>"},{"location":"#glm","title":"GLM","text":"<p>GLM is a 1-dimensional lake water balance and stratification model. It can also be coupled with a powerful ecological modelling library to support simulations of lake water quality and ecosystem processes.</p> <p>GLM is suitable for a wide range of natural and engineered lakes, including shallow (well-mixed) and deep (stratified) systems. The model has been successfully applied to systems from the scale of individual ponds and wetlands to the scale of Great Lakes.</p> <p>For more information about running GLM, please see the model website's scientific basis description and the GLM workbook. </p> <p>The GLM model is available as an executable for Linux (Ubuntu), MacOS, and Windows. It is actively developed by the  Aquatic EcoDynamics research group at The University of Western Australia.</p>"},{"location":"#why-glm-py","title":"Why glm-py?","text":"<p>glm-py provides a series of classes, functions, and data structures that support running GLM simulations, preparing model input data and configurations, and processing model outputs. </p> <p>Its goal is to make running and deploying GLM in a range of environments easy, e.g., building APIs for web applications or cloud services that use GLM, running batches of GLM simulations on HPCs, and running GLM simulations locally within Python environments such as JupyterLab or QGIS. </p>"},{"location":"#nml","title":"NML","text":"<p>Classes that store model parameters and methods that generate <code>.nml</code> configuration files for running GLM. </p>"},{"location":"#dimensions","title":"Dimensions","text":"<p>Turns simple user descriptions of lake geometries and dimensions into appropriate morphometry parameters.</p>"},{"location":"#glm_json","title":"GLM_JSON","text":"<p>Tools to convert JSON data to <code>.nml</code> format data. Useful for handling client requests if GLM is deployed within a web API / REST API.</p>"},{"location":"#simulation","title":"Simulation","text":"<p>Classes to handle running GLM simulations and processing output data into CSV, JSON, NetCDF files, or generating a JSON stream to pass onto clients. </p>"},{"location":"#plots","title":"Plots","text":"<p>Matplotlib-based plotting methods that process and plot GLM's output files.</p>"},{"location":"development/","title":"Development setup","text":""},{"location":"development/#environment","title":"Environment","text":"<p>A Docker container can be used to create a development environment. You can either build the Docker image:</p> <p><pre><code>docker build -t glmpy-dev .devcontainer\n</code></pre> Or, you can develop glmpy using a dev container. </p>"},{"location":"development/#code-style","title":"Code style","text":"<p>Code linting and formatting uses ruff and black. A script to format the glm-met repository can be run: <code>./scripts/format.sh</code>. </p> <p>pre-commit is used to run ruff and black. </p>"},{"location":"development/#tests","title":"Tests","text":"<p>pytest is used for testing glm-py. </p> <p>If testing, please add tests under the <code>tests</code> directory. If you need test data for running tests, add them as <code>pytest.fixtures</code> in <code>conftest.py</code>. </p>"},{"location":"development/#docs","title":"Docs","text":"<p>Build the docs (from the package root): </p> <pre><code>mkdocs serve \n</code></pre>"},{"location":"development/#build-package","title":"Build package","text":"<pre><code>python -m build\n</code></pre>"},{"location":"development/#release-to-pypi","title":"Release to PyPI","text":"<p>Use semantic versioning, versioneer, GitHub Actions workflows. Push to GitHub with a <code>vX.X.X</code> tag to trigger a the <code>build-and-deploy.yml</code> workflow.</p> <p><code>build-and-deploy.yml</code> will build glm-py and push the new release to PyPI. </p> <p>To use versioneer:</p> <pre><code>pip install versioneer\n</code></pre> <p>Then add the following to <code>pyproject.toml</code>:</p> <pre><code>[build-system]\nrequires = [\"setuptools&gt;=61.0.0\", \"versioneer[toml]\"]\nbuild-backend = \"setuptools.build_meta\"\n</code></pre> <p>and</p> <pre><code># See the docstring in versioneer.py for instructions. Note that you must\n# re-run 'versioneer.py setup' after changing this section, and commit the\n# resulting files.\n\n[tool.versioneer]\nVCS = \"git\"\nstyle = \"pep440\"\nversionfile_source = \"glmpy/_version.py\"\nversionfile_build = \"glmpy/_version.py\"\ntag_prefix = \"v\"\nparentdir_prefix = \"glmpy-\"\n</code></pre> <p>and</p> <pre><code>[project.optional-dependencies]\ntoml = [\"tomli; python_version &lt; '3.11'\"]\n</code></pre> <p>Create <code>setup.py</code>:</p> <pre><code>touch setup.py\n</code></pre> <p>and add the following to <code>setup.py</code>:</p> <pre><code>from setuptools import setup\n\nimport versioneer\n\n# see pyproject.toml for static project metadata\nsetup(\n    version=versioneer.get_version(),\n    cmdclass=versioneer.get_cmdclass(),\n)\n</code></pre> <p>Run:</p> <pre><code>versioneer install --vendor\n</code></pre>"},{"location":"development/#code-style_1","title":"Code style","text":"<ul> <li>Format all code using black (see <code>./scripts/format.sh</code>)</li> <li>Manually correct all ruff errors</li> <li>Use pre-commit to format Python code before git commits</li> <li>Use NumPy style docstrings - follow NumPy conventions</li> </ul>"},{"location":"development/#methods-function-docstring","title":"Methods / function docstring","text":"<p>Example from Pandas:</p> <ul> <li>Summary - one line function / method summary.</li> <li>Extended summary - one or two sentences outlining what the function achieves and when / where it is used.</li> <li>Parameter description - list function arguments, keywords, and types.</li> <li>Returns / yields section - list returns / yields from the function and their types.</li> <li>Notes - optional notes section.</li> <li>Examples - example to illustrate how the function can be used.</li> </ul> <pre><code>\"\"\"\nAdd up two integer numbers.\n\nThis function simply wraps the ``+`` operator, and does not\ndo anything interesting, except for illustrating what\nthe docstring of a very simple function looks like.\n\nParameters\n----------\nnum1 : int\n    First number to add.\nnum2 : int\n    Second number to add.\n\nReturns\n-------\nint\n    The sum of ``num1`` and ``num2``.\n\nSee Also\n--------\nsubtract : Subtract one integer from another.\n\nExamples\n--------\n&gt;&gt;&gt; add(2, 2)\n4\n&gt;&gt;&gt; add(25, 0)\n25\n&gt;&gt;&gt; add(10, -10)\n0\n\"\"\"\n</code></pre>"},{"location":"development/#class-docstring","title":"Class docstring","text":"<ul> <li>Summary - one line class summary.</li> <li>Extended summary - one or two sentences outlining the class purpose and use.</li> <li>Attributes description - list function arguments, keywords, and types.</li> <li>Example - short example indicating class usage.</li> <li>Notes - optional notes section</li> </ul> <p>Do not list methods - add docstrings to methods within the class. </p>"},{"location":"dimensions/","title":"Dimensions","text":""},{"location":"dimensions/#glmpy.dimensions.InvertedTruncatedCone","title":"<code>InvertedTruncatedCone</code>","text":"<p>Calculates the volume and surface area of an inverted truncated cone.</p> <p>Useful for calculating the <code>A</code> and <code>H</code> morphometry parameters for  simple water bodies. Assumes only the height (i.e., depth), side slope, and surface radius of the water body are known.</p> <p>Attributes:</p> Name Type Description <code>height</code> <code>Union[float, int]</code> <p>Height of the water body from the base to surface in metres.</p> <code>surface_radius</code> <code>Union[float, int]</code> <p>Surface radius of the water body in metres.</p> <code>num_vals</code> <code>int</code> <p>The number of values to be returned by the <code>get_volumes()</code>,  <code>get_surface_areas()</code>, and <code>get_heights()</code> methods. <code>num_vals</code> should  be the same as the <code>bsn_vals</code> parameter from the <code>&amp;morphometry</code>  configuration block (see <code>bsn_vals</code> in <code>nml.NMLMorphometry()</code>).</p> <code>side_slope</code> <code>Union[float, int]</code> <p>Side slope of water body - the rise over run (metre/metre). Default is  1/3.</p> <code>surface_elevation</code> <code>float</code> <p>Elevation at the water body surface. Shifts the values returned by <code>get_heights()</code> up or down. Default is 0.0.</p> <p>Examples:</p> <p>Import the <code>dimensions</code> and <code>nml</code> modules:</p> <pre><code>&gt;&gt;&gt; from glmpy import dimensions, nml\n</code></pre> <p>Consider a small circular reservoir that has a surface radius of 15m, a  slide slope of 1/3, and is 3m deep:</p> <pre><code>&gt;&gt;&gt; reservoir = dimensions.InvertedTruncatedCone(\n...     surface_radius=15,\n...     height=3,\n...     side_slope=1/3,\n...     num_vals=3,\n...     surface_elevation=0\n... )\n</code></pre> <p>Get a list of height values to use for the <code>H</code> parameter in the  <code>&amp;morphometry</code> configuration block by calling the <code>get_heights()</code> method.  The length of the list is determined by the <code>num_vals</code> attribute:</p> <pre><code>&gt;&gt;&gt; print(reservoir.get_heights())\n[-3.0, -1.5, 0.0]\n</code></pre> <p>Get the water surface area at each of these heights by calling the  <code>get_surface_areas()</code> method:</p> <pre><code>&gt;&gt;&gt; print(reservoir.get_surface_areas())\n[113.09733552923255, 346.3605900582747, 706.8583470577034]\n</code></pre> <p>Get the volume at each of these heights by calling the <code>get_volumes()</code>  method:</p> <pre><code>&gt;&gt;&gt; print(reservoir.get_volumes())\n[0.0, 328.6891313818321, 1102.6990214100174]\n</code></pre> <p>Set the <code>A</code>, <code>H</code>, and <code>bsn_vals</code> attributes of <code>nml.NMLMorphometry()</code>:</p> <pre><code>&gt;&gt;&gt; morphometry = nml.NMLMorphometry(\n...     A=ofr.get_surface_areas(),\n...     H=ofr.get_heights(),\n...     bsn_vals=3\n... )\n</code></pre>"},{"location":"dimensions/#glmpy.dimensions.InvertedTruncatedCone.get_heights","title":"<code>get_heights()</code>","text":"<p>Calculates heights.</p> <p>Returns a list of heights (m) from base to surface. The number of  heights is determined by the <code>num_vals</code> attribute. Heights can be  adjusted for different surface elevations by increasing or decreasing the <code>surface_elevation</code> attribute.</p> <p>Returns:</p> Name Type Description <code>heights</code> <code>list</code> <p>Heights (m) from base to surface.</p> <p>Examples:</p> <p>Get the height values for a water body that has a surface elevation of -3m:</p> <pre><code>&gt;&gt;&gt; from glmpy import dimensions\n&gt;&gt;&gt; reservoir = dimensions.InvertedTruncatedCone(\n...     surface_radius=15,\n...     height=3,\n...     side_slope=1/3,\n...     num_vals=3,\n...     surface_elevation=-3\n... )\n&gt;&gt;&gt; print(reservoir.get_heights())\n[-6.0, -4.5, -3.0]\n</code></pre>"},{"location":"dimensions/#glmpy.dimensions.InvertedTruncatedCone.get_surface_areas","title":"<code>get_surface_areas()</code>","text":"<p>Calculates surface areas.</p> <p>Returns a list of surface areas (m^2) that correspond with the heights  returned by <code>get_heights()</code>. The length of the list is determined by  the <code>num_vals</code> attribute. Surface areas are returned as a list of  floats where the first item is the area at the bottom of the water body  and the last is the area at the surface.</p> <p>Returns:</p> Name Type Description <code>surface_areas</code> <code>list</code> <p>Surface areas of water body (m^2).</p> <p>Examples:</p> <p>Get a list of 5 surface areas at each height in <code>get_heights()</code>:</p> <pre><code>&gt;&gt;&gt; from glmpy import dimensions\n&gt;&gt;&gt; reservoir = dimensions.InvertedTruncatedCone(\n...     surface_radius=15,\n...     height=3,\n...     side_slope=1/3,\n...     num_vals=5,\n...     surface_elevation=0\n... )\n&gt;&gt;&gt; print(reservoir.get_heights())\n[-3.0, -2.25, -1.5, -0.75, 0.0]\n&gt;&gt;&gt; print(reservoir.get_surface_areas())\n[113.09733552923255, 213.8246499849553, 346.3605900582747, \n510.70515574919074, 706.8583470577034]\n</code></pre> <p>Get a list of 3 surface areas at each height in <code>get_heights()</code>:</p> <pre><code>&gt;&gt;&gt; from glmpy import dimensions\n&gt;&gt;&gt; reservoir = dimensions.InvertedTruncatedCone(\n...     surface_radius=15,\n...     height=3,\n...     side_slope=1/3,\n...     num_vals=3,\n...     surface_elevation=0\n... )\n&gt;&gt;&gt; print(reservoir.get_heights())\n[-3.0, -1.5, 0.0]\n&gt;&gt;&gt; print(reservoir.get_surface_areas())\n[113.09733552923255, 346.3605900582747, 706.8583470577034]\n</code></pre>"},{"location":"dimensions/#glmpy.dimensions.InvertedTruncatedCone.get_volumes","title":"<code>get_volumes()</code>","text":"<p>Calculates volumes</p> <p>Returns a list of volumes (m^3) that correspond with the heights  returned by <code>get_heights()</code>. The length of the list is determined by  the <code>num_vals</code> attribute. Volumes are returned as a list of floats  where the first item is the volume at the bottom of the water body and  the last is the volume at the surface.</p> <p>Returns:</p> Name Type Description <code>volume</code> <code>list</code> <p>The water body volumes (m^3).</p> <p>Examples:</p> <p>Get a list of 5 volumes at each height in <code>get_heights()</code>:</p> <pre><code>&gt;&gt;&gt; from glmpy import dimensions\n&gt;&gt;&gt; reservoir = dimensions.InvertedTruncatedCone(\n...     surface_radius=15,\n...     height=3,\n...     side_slope=1/3,\n...     num_vals=5,\n...     surface_elevation=0\n... )\n&gt;&gt;&gt; print(reservoir.get_heights())\n[-3.0, -2.25, -1.5, -0.75, 0.0]\n&gt;&gt;&gt; print(reservoir.get_volumes())\n[0.0, 120.60770546672065, 328.6891313818321, 648.1007469585319, \n1102.6990214100174]\n</code></pre> <p>Get a list of 3 volumes at each height in <code>get_heights()</code>:</p> <pre><code>&gt;&gt;&gt; from glmpy import dimensions\n&gt;&gt;&gt; reservoir = dimensions.InvertedTruncatedCone(\n...     surface_radius=15,\n...     height=3,\n...     side_slope=1/3,\n...     num_vals=3,\n...     surface_elevation=0\n... )\n&gt;&gt;&gt; print(reservoir.get_heights())\n[-3.0, -1.5, 0.0]\n&gt;&gt;&gt; print(reservoir.get_volumes())\n[0.0, 328.6891313818321, 1102.6990214100174]\n</code></pre>"},{"location":"dimensions/#glmpy.dimensions.InvertedTruncatedPyramid","title":"<code>InvertedTruncatedPyramid</code>","text":"<p>Calculates the volume and surface area of an inverted truncated pyramid.</p> <p>Useful for calculating the <code>A</code> and <code>H</code> morphometry parameters for simple  water bodies such as on-farm reservoirs. Assumes only the height  (i.e., depth), side slope, surface length, and surface width of the water  body are known. </p> <p>Attributes:</p> Name Type Description <code>height</code> <code>Union[float, int]</code> <p>Height of water body from the base to surface in metres.</p> <code>surface_length</code> <code>Union[float, int]</code> <p>Surface length of the water body in metres. </p> <code>surface_width</code> <code>Union[float, int]</code> <p>Surface width of the water body in metres. </p> <code>num_vals</code> <code>int</code> <p>The number of values to be returned by the <code>get_volumes()</code>,  <code>get_surface_areas()</code>, and <code>get_heights()</code> methods. <code>num_vals</code> should  be the same as the <code>bsn_vals</code> parameter from the <code>&amp;morphometry</code>  configuration block (see <code>bsn_vals</code> in <code>MorphometryBlock</code>).</p> <code>side_slope</code> <code>Union[float, int]</code> <p>Side slope of water body - the rise over run (metre/metre). Default is  1/3.</p> <code>surface_elevation</code> <code>float</code> <p>Elevation at the water body surface. Shifts the values returned by <code>get_heights()</code> up or down. Default is 0.0.</p> <p>Examples:</p> <p>Import the <code>dimensions</code> module and <code>glm_nml</code> sub-module:</p> <pre><code>&gt;&gt;&gt; from glmpy import dimensions\n&gt;&gt;&gt; from glmpy.nml import glm_nml\n</code></pre> <p>Consider a square on-farm reservoir that is 40m long, 40m wide, 6m deep,  and has a side slope of 1/3:</p> <pre><code>&gt;&gt;&gt; ofr = dimensions.InvertedTruncatedPyramid(\n...     height=6,\n...     surface_length=40,\n...     surface_width=40,\n...     num_vals=7,\n...     side_slope=1/3,\n...     surface_elevation=0\n... )\n</code></pre> <p>Get a list of height values to use for the <code>H</code> parameter in the  <code>&amp;morphometry</code> configuration block by calling the <code>get_heights()</code> method.  The length of the list is determined by the <code>num_vals</code> attribute:</p> <pre><code>&gt;&gt;&gt; print(ofr.get_heights())\n[-6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0]\n</code></pre> <p>Get the water surface area at each of these heights by calling the  <code>get_surface_areas()</code> method:</p> <pre><code>&gt;&gt;&gt; print(ofr.get_surface_areas())\n[16.0, 100.0, 256.0, 484.0, 784.0, 1156.0, 1600.0]\n</code></pre> <p>Get the volume at each of these heights by calling the <code>get_volumes()</code>  method:</p> <pre><code>&gt;&gt;&gt; print(ofr.get_volumes())\n[0.0, 52.0, 224.0, 588.0, 1216.0, 2180.0, 3552.0]\n</code></pre> <p>Set the <code>A</code>, <code>H</code>, and <code>bsn_vals</code> attributes of <code>nml.NMLMorphometry()</code>:</p> <pre><code>&gt;&gt;&gt; morphometry = glm_nml.MorphometryBlock(\n...     A=ofr.get_surface_areas(),\n...     H=ofr.get_heights(),\n...     bsn_vals=7\n... )\n</code></pre>"},{"location":"dimensions/#glmpy.dimensions.InvertedTruncatedPyramid.get_heights","title":"<code>get_heights()</code>","text":"<p>Calculates heights.</p> <p>Returns a list of heights (m) from base to surface. The number of  heights is determined by the <code>num_vals</code> attribute. Heights can be  adjusted for different surface elevations by increasing or decreasing the <code>surface_elevation</code> attribute.</p> <p>Returns:</p> Name Type Description <code>heights</code> <code>list</code> <p>Heights (m) from base to surface.</p> <p>Examples:</p> <p>Get the height values for a water body that has a surface elevation of -3m:</p> <pre><code>&gt;&gt;&gt; from glmpy import dimensions\n&gt;&gt;&gt; ofr = dimensions.InvertedTruncatedPyramid(\n...     height=6,\n...     surface_length=40,\n...     surface_width=40,\n...     num_vals=7,\n...     side_slope=1/3,\n...     surface_elevation=-3\n... )\n&gt;&gt;&gt; print(ofr.get_heights())\n[-9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0]\n</code></pre>"},{"location":"dimensions/#glmpy.dimensions.InvertedTruncatedPyramid.get_surface_areas","title":"<code>get_surface_areas()</code>","text":"<p>Calculates surface areas.</p> <p>Returns a list of surface areas (m^2) that correspond with the heights  returned by <code>get_heights()</code>. The length of the list is determined by  the <code>num_vals</code> attribute. Surface areas are returned as a list of  floats where the first item is the area at the bottom of the water body  and the last is the area at the surface.</p> <p>Returns:</p> Name Type Description <code>surface_areas</code> <code>list</code> <p>Surface areas of water body (m^2).</p> <p>Examples:</p> <p>Get a list of 7 surface areas at each height in <code>get_heights()</code>:</p> <pre><code>&gt;&gt;&gt; from glmpy import dimensions\n&gt;&gt;&gt; ofr = dimensions.InvertedTruncatedPyramid(\n...     height=6,\n...     surface_length=40,\n...     surface_width=40,\n...     num_vals=7,\n...     side_slope=1/3,\n...     surface_elevation=0\n... )\n&gt;&gt;&gt; print(ofr.get_heights())\n[-6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0]\n&gt;&gt;&gt; print(ofr.get_surface_areas())\n[16.0, 100.0, 256.0, 484.0, 784.0, 1156.0, 1600.0]\n</code></pre> <p>Get a list of 4 surface areas at each height in <code>get_heights()</code>:</p> <pre><code>&gt;&gt;&gt; ofr = dimensions.InvertedTruncatedPyramid(\n...     height=6,\n...     surface_length=40,\n...     surface_width=40,\n...     num_vals=4,\n...     side_slope=1/3\n... )\n&gt;&gt;&gt; print(ofr.get_heights())\n[-6.0, -4.0, -2.0, 0.0]\n&gt;&gt;&gt; print(ofr.get_surface_areas())\n[16.0, 256.0, 784.0, 1600.0]\n</code></pre>"},{"location":"dimensions/#glmpy.dimensions.InvertedTruncatedPyramid.get_volumes","title":"<code>get_volumes()</code>","text":"<p>Calculates volumes.</p> <p>Returns a list of volumes (m^3) that correspond with the heights  returned by <code>get_heights()</code>. The length of the list is determined by  the <code>num_vals</code> attribute. Volumes are returned as a list of floats  where the first item is the volume at the bottom of the water body and  the last is the volume at the surface.</p> <p>Returns:</p> Name Type Description <code>volume</code> <code>list</code> <p>The water body volumes (m^3).</p> <p>Examples:</p> <p>Get a list of 7 volumes at each height in <code>get_heights()</code>:</p> <pre><code>&gt;&gt;&gt; from glmpy import dimensions\n&gt;&gt;&gt; ofr = dimensions.InvertedTruncatedPyramid(\n...     height=6,\n...     surface_length=40,\n...     surface_width=40,\n...     num_vals=7,\n...     side_slope=1/3,\n...     surface_elevation=0\n... )\n&gt;&gt;&gt; print(ofr.get_heights())\n[-6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0]\n&gt;&gt;&gt; print(ofr.get_volumes())\n[0.0, 52.0, 224.0, 588.0, 1216.0, 2180.0, 3552.0]\n</code></pre> <p>Get a list of 4 volumes at each height in <code>get_heights()</code>:</p> <pre><code>&gt;&gt;&gt; ofr = dimensions.InvertedTruncatedPyramid(\n...     height=6,\n...     surface_length=40,\n...     surface_width=40,\n...     num_vals=4,\n...     side_slope=1/3,\n...     surface_elevation=0\n... )\n&gt;&gt;&gt; print(ofr.get_heights())\n[-6.0, -4.0, -2.0, 0.0]\n&gt;&gt;&gt; print(ofr.get_volumes())\n[0.0, 224.0, 1216.0, 3552.0]\n</code></pre>"},{"location":"dimensions/#glmpy.dimensions.InvertedTruncatedSquarePyramid","title":"<code>InvertedTruncatedSquarePyramid</code>","text":""},{"location":"farm-dam-tutorial/","title":"Tutorials","text":""},{"location":"farm-dam-tutorial/#farm-dam","title":"Farm Dam","text":""},{"location":"farm-dam-tutorial/#introduction","title":"Introduction","text":"<p>In this tutorial, you will use <code>glmpy</code> to construct a simple model of a farm dam in the Western Australian (WA) Wheatbelt. The WA Wheatbelt is a semi-arid agricultural region dominated by rain-fed cropping and livestock production. Farm dams play a crucial role in storing fresh water for irrigation and animal consumption during the dry summer months. Climate change is warming the Wheatbelt and increasingly disrupting the winter rainfall patterns that fill farm dams. When dams dry out, the impact to farmers and animals can be servere. Modelling the water balance of these small water bodies is important to minimise their risk of failure under a drying climate.</p> <p>In the map below, you can see the dam is connected to a large catchment area. These catchments are often constructed up-hill from the dam and consist of a compacted clay surface. This design increases runoff during rainfall events and channels the water into the dam. To accurately model the dam, we will need to incorporate the inflows from this catchment.</p>"},{"location":"farm-dam-tutorial/#model-setup","title":"Model setup","text":"<p>Let's start building the model. <code>glmpy</code> provides a set of classes in the <code>nml</code> module that can be used to construct the GLM namelist file (<code>.nml</code>). The <code>.nml</code> file is simply a text file that contains a set of parameters which configure the model. These parameters are grouped into different components that each configure different aspects of the model. For every component, there is a corresponding class in the <code>nml</code> module that you can use to construct the namelist file, e.g., the <code>NMLMeteorology</code> class configures the <code>&amp;meteorology</code> parameters. Go ahead and import the <code>nml</code> module:</p> <pre><code>from glmpy import nml\n</code></pre> <p>The first component we will configure is the <code>&amp;setup</code> component. These parameters control the model layers. GLM is a 1-D model that simulates a water body as a vertical series of layers. The number of layers, and their thickness, is dynamic. Layers will expand, contract, merge, and split in response to water and surface mass fluxes.  The <code>&amp;setup</code> component defines the initial state of these layers. The <code>NMLSetup</code> class constructor takes the following arguments:</p> <ul> <li><code>sim_name</code>: The name of your simulation</li> <li><code>max_layers</code>: The maximum number of layers that can be created during the simulation</li> <li><code>min_layer_vol</code>: The minimum volume of a layer in cubic metres</li> <li><code>min_layer_thick</code>: The minimum thickness of a layer in metres</li> <li><code>max_layer_thick</code>: The maximum thickness of a layer in metres</li> <li><code>density_model</code>: The equation used to calculate the density of water in each layer</li> <li><code>non_avg</code>: A flag to indicate whether the model should use non-averaged layers</li> </ul> <p>Let's initialise our model with a maximum of 100 layers. Each layer must contain at least 0.1 m<sup>3</sup> of water and range in thickness from 0.01-1.0 m. By setting <code>density_model</code> to 1, we'll use a model from TEOS-10 that calculates the density as a function of local temperature and salinity. Finally, we'll set <code>non_avg</code> to <code>True</code> to indicate that we want to use non-averaged layers.</p> <pre><code>setup = nml.NMLSetup(\n    sim_name='farm_dam',\n    max_layers=100,\n    min_layer_vol=0.1,\n    min_layer_thick=0.01,\n    max_layer_thick=1.0,\n    density_model=1,\n    non_avg=True\n)\n</code></pre>"},{"location":"farm-dam-tutorial/#model-duration","title":"Model duration","text":"<p>Our model will run over a 10 year period from 2010 to 2020 at an hourly timestep. The <code>&amp;time</code> component defines the start and stop time of the simulation, the time step, and the time zone. We can use <code>NMLTime</code> class constructor to configure these properties:</p> <pre><code>time = nml.NMLTime(\n    timefmt=2,\n    start=\"2010-01-01 00:00:00\",\n    stop=\"2020-12-31 00:00:00\",\n    dt=3600,\n    timezone=8\n)\n</code></pre> <p>Here, we have specified the <code>timefmt</code> as <code>2</code> which configures GLM to accept <code>start</code> and <code>stop</code> times. Alternatively, a <code>timefmt=3</code> allows GLM to read the <code>num_days</code> parameter. The <code>start</code> and <code>stop</code> times are specified as strings in the format <code>YYYY-MM-DD HH:MM:SS</code>. The <code>dt</code> parameter is the time step in seconds (3600 seconds in an hour). The <code>timezone</code> parameter is the time zone offset from UTC in hours.</p>"},{"location":"farm-dam-tutorial/#dam-morphometry","title":"Dam morphometry","text":"<p>Next, we'll define the dam morphometry, i.e., the physical dimensions that capture the shape of the water body. GLM records the morphometry of a water body by a list of height and surface area pairs. The heights are vertical distances from the bottom of the water body to the surface. Similarly, the surface areas are the horizontal area of the water body at the each height increment. The number of height/surface-area pairs you need to provide largely depends on how complex the morphometry is. For dams, the morphometry is simple. Most farm dams often resembles an truncated pyramid that has been inverted. Conveniently, <code>glmpy</code> provides a <code>SimpleTruncatedPyramidWaterBody</code> class in the <code>dimensions</code> module to easily calculate the height/surface-area pairs!</p> <p><pre><code>from glmpy import dimensions\n</code></pre> The <code>SimpleTruncatedPyramidWaterBody</code> constructor takes the following arguments:</p> <ul> <li><code>height</code>: The height (i.e., the depth) of the dam in metres.</li> <li><code>surface_width</code>: The width of the dam surface in metres.</li> <li><code>surface_length</code>: The length of the dam surface in metres.</li> <li><code>side_slope</code>: The rise over run of the dam side slopes</li> </ul> <p> </p> <p>Three of these arguments are known from the information on our map: <code>height</code>, <code>surface_width</code>, and <code>surface_length</code>. The <code>side_slope</code> is unknown so here we will make an assumption. Farm dams in the WA Wheatbelt are typically constructed with a side slope of 3:1. This means the dam slopes 3 metres vertically for every 1 metre horizontally. Based on this assumption we can now construct the <code>SimpleTruncatedPyramidWaterBody</code> object.</p> <pre><code>dam_morphometry = dimensions.SimpleTruncatedPyramidWaterBody(\n    height=5,\n    surface_width=40,\n    surface_length=62,\n    side_slope=3\n)\n</code></pre> <p>By calling the  <code>get_heights()</code> and <code>get_surface_areas()</code> method on the <code>dam_morphometry</code> object you can return a list of height/surface-area pairs.</p> <pre><code>dam_morphometry.get_heights()\n</code></pre> <pre><code>[-5, -4, -3, -2, -1, 0]\n</code></pre> <pre><code>dam_morphometry.get_surface_areas()\n</code></pre> <pre><code>[2151.111, 2215.111, 2280.0, 2345.774, 2412.444, 2480.0]\n</code></pre> <p>We now have the morphometry of our dam! Let's use these values as inputs to the <code>NMLMorphometry</code> constructor. We'll need to set the following arguments:</p> <ul> <li><code>lake_name</code>: The name of the water body</li> <li><code>latitude</code>: The latitude of the water body</li> <li><code>longitude</code>: The longitude of the water body</li> <li><code>base_elev</code>: The elevation of the bottom of the water body</li> <li><code>crest_elev</code>: The elevation of the top of the water body</li> <li><code>bsn_len</code>: The surface length of the water body in metres</li> <li><code>bsn_wid</code>: The surface width of the water body in metres</li> <li><code>A</code>: A list of surface areas. We just calculated this!</li> <li><code>H</code>: A list of heights. We just calculated this!</li> </ul> <p><code>latitude</code> and <code>longitude</code> are easy, just check the map! What about <code>base_elev</code> and <code>crest_elev</code>? On this farm in the Wheatbelt we're 332 m above sea level. We'll set the <code>crest_elev</code> to <code>332</code>, and the <code>base_elev</code> to <code>332 - 5</code>, i.e., minus the dam depth. <code>bsn_wid</code> and <code>bsn_len</code> are the surface dimensions of the dam while <code>A</code> and <code>H</code> are values we calculated from the <code>dam_morphometry</code> object.</p> <pre><code>morphometry = nml.NMLMorphometry(\n    lake_name = \"Farm dam\",\n    latitude = -32.474,\n    longitude = 116.988,\n    base_elev = 327,\n    crest_elev = 332,\n    bsn_len = 62,\n    bsn_wid = 40,\n    H = dam_morphometry.get_heights(),\n    A = dam_morphometry.get_surface_areas()\n)\n</code></pre>"},{"location":"farm-dam-tutorial/#initial-profiles","title":"Initial profiles","text":"<p>Let's fill up the dam! The <code>&amp;init_profiles</code> component of the GLM <code>.nml</code> file defines the initial state of water in the dam. We provide the initial water level (<code>lake_depth</code>), the water quality variables we want to simulate, and a set of depths where we can set the initialise certain conditions in the water profile.</p> <p>In this simulation, we're only interested in the water balance of our farm dam so we'll ignore the water quality variables. Our dam will start with 4 m of water and we'll set two depths at which we we'll initialise water temperature/salinity. The first depth will be at 1 m and the second at 3 m. We'll set the temperature and salinity at both depths to 18 \u00b0C and 0 ppt, respectively.</p> <pre><code>init_profiles = nml.NMLInitProfiles(\n    lake_depth = 4,\n    num_depth = 2,\n    the_depths = [1, 3],\n    the_temps = [18.0, 18.0],\n    the_sals = [0.0, 0.0]\n)\n</code></pre>"},{"location":"farm-dam-tutorial/#meteorology","title":"Meteorology","text":"<p>To setup the meteorology component of the <code>.nml</code> file we need some nearby data on rainfall and temperature for each day of our simulation. Click here to download some pre-prepared data from the Bureau of Meteorology's weather station at the nearby town of Pingelly:</p> <p>Inspecting the CSV, you'll see daily observations from <code>2010-01-01 00:00:00</code> to <code>2020-12-31 00:00:00</code>:</p> date temperature rainfall 2010-01-01 00:00:00 29.5 0.0 2010-01-02 00:00:00 33.4 0.0 2010-01-03 00:00:00 38.6 0.0 2010-01-04 00:00:00 32.2 0.0 2010-01-05 00:00:00 37.2 0.0 <pre><code>meteorology = nml.NMLMeteorology(\n    met_sw = True,\n    meteo_fl = 'path/to/dam_tutorial_met_data.csv',\n    subdaily = False,\n    time_fmt = 'YYYY-MM-DD hh:mm:ss',\n    ???\n)\n</code></pre>"},{"location":"farm-dam-tutorial/#catchment-inflows","title":"Catchment inflows","text":"<p>Let's now return to the large catchment mentioned at the beginning of this tutorial. During a rainfall event, this catchment captures additional inputs from beyond the spatial extent of the dam. This can be accounted for by configuring the <code>&amp;inflow</code> component of the <code>.nml</code>. Catchment inflows are a function of the catchment area, rainfall, and a runoff threshold. The <code>NMLInflow</code> class expects a CSV with inflows pre-calculated for each day of the simulation. We'll use some of the additional functionality in <code>glmpy</code> to calculate this timeseries.</p> <p>Start by importing the <code>inflows</code> module:</p> <pre><code>from glmpy import inflows\n</code></pre> <p>The <code>CatchmentInflows</code> class will calculate daily inflows from the catchment area and our meteorological data. Dam catchments typically start producing runoff when rainfall exceeds 8 mm.</p> <pre><code>inflows = inflows.CatchmentInflows(\n    input_type = 'dataframe',\n    met_data = met_data,\n    catchment_area = 32000,\n    runoff_threshold = 0.008,\n    precip_col = 'rainfall',\n    date_time_col = 'time'\n)\n</code></pre>"},{"location":"inflows/","title":"Inflows","text":""},{"location":"inflows/#glmpy.inflows.CatchmentRunoffInflows","title":"<code>CatchmentRunoffInflows</code>","text":"<p>Calculate runoff inflows from a catchment.</p> <p>Generates an inflows timeseries by calculating catchment runoff from a pandas DataFrame of precipitation data. Requires a catchment area, a runoff coefficient or threshold, and a precipitation timeseries in either hourly or daily timesteps. Inflows are calculated at the same timestep as the precipitation data but in units of m^3/s. <code>CatchmentRunoffInflows</code> provides methods to return the calculated inflows timeseries as a pandas DataFrame or to write the timeseries to a CSV.</p> <p>Attributes:</p> Name Type Description <code>met_data</code> <code>DataFrame</code> <p>A pandas DataFrame of meteorological data.</p> <code>precip_col</code> <code>str</code> <p>Name of the column in the DataFrame containing precipitation data in m/day or m/hour.</p> <code>date_time_col</code> <code>str</code> <p>Name of the column in the DataFrame containing datetime data.</p> <code>catchment_area</code> <code>Union[float, int]</code> <p>Area of the catchment in square meters.</p> <code>runoff_coef</code> <code>Union[float, None]</code> <p>Runoff coefficient for the catchment. The fraction of rainfall that will result in runoff. Either <code>runoff_coef</code> or <code>runoff_threshold</code> must be provided.</p> <code>runoff_threshold</code> <code>Union[float, None]</code> <p>Runoff threshold for the catchment. The amount of rainfall in mm to generate runoff. Either <code>runoff_coef</code> or <code>runoff_threshold</code> must be provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import inflows\n</code></pre> <p>Generate a daily timeseries of rainfall:</p> <pre><code>&gt;&gt;&gt; daily_met_data = pd.DataFrame({\n...     'Date': pd.date_range(\n...         start='1997-01-01',\n...         end='2004-12-31',\n...         freq='24h'),\n...     'Rain': 0.024 #m per day\n... })\n</code></pre> <p>Calculate inflows with a 50% runoff coefficient and a 1000 m^2 catchment area:</p> <pre><code>&gt;&gt;&gt; inflows_data = inflows.CatchmentRunoffInflows(\n...     met_data = daily_met_data,\n...     catchment_area = 1000,\n...     runoff_coef = 0.5,\n...     precip_col = 'Rain',\n...     date_time_col = 'Date'\n... )\n&gt;&gt;&gt; inflows_data.get_inflows()\n</code></pre> <p>Generate a hourly timeseries of rainfall:</p> <pre><code>&gt;&gt;&gt; hourly_met_data = pd.DataFrame({\n...     'Date': pd.date_range(\n...         start='1997-01-01',\n...         end='2004-12-31',\n...         freq='1h'),\n...     'Rain': 0.001\n... })\n</code></pre> <p>Calculate inflows with a 50% runoff coefficient and a 1000 m^2 catchment area:</p> <pre><code>&gt;&gt;&gt; inflows_data = inflows.CatchmentRunoffInflows(\n...     met_data = hourly_met_data,\n...     catchment_area = 1000,\n...     runoff_coef = 0.5,\n...     precip_col = 'Rain',\n...     date_time_col = 'Date'\n... )\n&gt;&gt;&gt; inflows_data.get_inflows()\n</code></pre>"},{"location":"inflows/#glmpy.inflows.CatchmentRunoffInflows.get_inflows","title":"<code>get_inflows()</code>","text":"<p>Get the inflows timeseries.</p> <p>Returns a pandas dataframe of the calculated catchment runoff inflows.</p> <p>Returns:</p> Name Type Description <code>inflows</code> <code>DataFrame</code> <p>DataFrame of inflow data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import inflows\n&gt;&gt;&gt; import pandas as pd\n</code></pre> <p>Generate an hourly timeseries of rainfall:</p> <pre><code>&gt;&gt;&gt; hourly_met_data = pd.DataFrame({\n...     'Date': pd.date_range(\n...         start='1997-01-01',\n...         end='2004-12-31',\n...         freq='1h'\n...     ),\n...     'Rain': 0.001\n... })\n</code></pre> <p>Calculate inflows with a 50% runoff coefficient and a 1000 m^2 catchment area</p> <pre><code>&gt;&gt;&gt; inflows_data = inflows.CatchmentRunoffInflows(\n...     met_data = hourly_met_data,\n...     catchment_area = 1000,\n...     runoff_coef = 0.5,\n...     precip_col = 'Rain',\n...     date_time_col = 'Date'\n... )\n</code></pre> <p>Call <code>get_inflows()</code> to return the inflows timeseries:</p> <pre><code>&gt;&gt;&gt; inflows_data.get_inflows()\n</code></pre>"},{"location":"inflows/#glmpy.inflows.CatchmentRunoffInflows.write_inflows","title":"<code>write_inflows(file_path)</code>","text":"<p>Write the inflow timeseries to a CSV file.</p> <p>Calculates catchment runoff inflows and writes the timeseries to a CSV.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the output CSV file.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import inflows\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; daily_met_data = pd.DataFrame({\n...     'Date': pd.date_range(\n...         start='1997-01-01',\n...         end='2004-12-31',\n...         freq='24h'),\n...     'Rain': 0.024\n... })\n&gt;&gt;&gt; inflows_data = inflows.CatchmentRunoffInflows(\n...     met_data = daily_met_data,\n...     catchment_area = 1000,\n...     runoff_coef = 0.5,\n...     precip_col = 'Rain',\n...     date_time_col = 'Date'\n... )\n</code></pre> <p>Call <code>write_inflows</code> to write the inflows timeseries to a CSV:</p> <pre><code>&gt;&gt;&gt; inflows_data.write_inflows(file_path='runoff.csv')\n</code></pre>"},{"location":"installation/","title":"Install","text":""},{"location":"installation/#quick-start","title":"Quick start","text":"<p>Install glm-py with <code>pip</code>:</p> <pre><code>pip install glm-py\n</code></pre>"},{"location":"installation/#built-distribution-recommended","title":"Built distribution (recommended)","text":"<p>The built distribution of glm-py comes bundled with the GLM binary.  <code>pip</code> will automatically download the built distribution of glm-py providing:</p> <ul> <li>You have CPython 3.9-3.12 or PyPy 3.9-3.10 installed </li> <li>You are running one of the supported OS/architectures listed in the table below</li> </ul> Linux Macos Windows x86_64 \u2705 \u2705 \u2705 ARM64 \u2705 \u2705 \u274c"},{"location":"installation/#source-distribution","title":"Source distribution","text":"<p>In the event your system does not meet the above requirements, <code>pip</code> will install the source distribution. The source distribution does not ship with the GLM binary. You will still be able to use glm-py (e.g., to create <code>.nml</code> files) but the package will raise an error when you call the <code>glm_run()</code> method from the <code>simulation.GLMSim</code> class.</p> <p>To run GLM, you will either need to source a pre-compiled binary or compile GLM yourself. The <code>glm_path</code> parameter of the <code>glm_run()</code> method can be used to tell glm-py where to run the binary from.</p>"},{"location":"installation/#release-history","title":"Release history","text":"<p>The following table lists the GLM version that is bundled with the built distribution of each glm-py release:</p> glm-py version GLM version <code>0.4.*</code> <code>3.3.1a12</code> <code>0.3.*</code> <code>3.3.1a12</code> <code>0.2.*</code> <code>3.3.1a12</code> <code>0.1.*</code> <code>3.3.1a12</code>"},{"location":"json-to-nml/","title":"GLM_JSON","text":""},{"location":"json-to-nml/#glmpy.glm_json.JSONReader","title":"<code>JSONReader</code>","text":"<p>Supports the reading of GLM configuration blocks in a JSON format or working with GLM configuration blocks in dictionary format.</p> <p>Reads and parses a JSON file into a dictionary object which can be used to set the attributes of the corresponding NML class. Useful for converting a JSON file of GLM parameters from a web application.</p> <p>Attributes:</p> Name Type Description <code>json_file</code> <code>str | PathLike | dict</code> <p>The path to the json file to be read or dict representation of the nml file in memory.</p> <code>nml_file</code> <code>str</code> <p>The path to the nml file to be written.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import glm_json\n&gt;&gt;&gt; json_to_nml = glm_json.JSONReader(\"sparkling_lake.json\")\n</code></pre>"},{"location":"json-to-nml/#glmpy.glm_json.JSONReader.get_nml_blocks","title":"<code>get_nml_blocks()</code>","text":"<p>Reads a JSON file or dictionary of GLM configuration blocks and returns a list of the block names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import glm_json\n&gt;&gt;&gt; json_to_nml = glm_json.JSONReader(\"config.json\")\n&gt;&gt;&gt; json_to_nml.get_nml_blocks()\n</code></pre>"},{"location":"json-to-nml/#glmpy.glm_json.JSONReader.get_nml_parameters","title":"<code>get_nml_parameters(nml_block)</code>","text":"<p>Get the model parameters for a GLM configuration block.</p> <p>Returns a dictionary of model parameters for a specified GLM  configuration block. Used for setting the attributes of the  corresponding <code>nml.NML*</code> classes.</p> <p>Parameters:</p> Name Type Description Default <code>nml_block</code> <code>str</code> <p>The name of the GLM configuration block</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the model parameters for a specified GLM  configuration block.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import glm_json, nml\n&gt;&gt;&gt; json = glm_json.JSONReader(\"sparkling_lake.json\")\n&gt;&gt;&gt; setup_dict = json.get_nml_parameters(\"&amp;glm_setup\")\n&gt;&gt;&gt; setup = nml.NMLSetup()\n&gt;&gt;&gt; setup.set_attributes(setup_dict)\n</code></pre>"},{"location":"json-to-nml/#glmpy.glm_json.JSONReader.read_json","title":"<code>read_json()</code>","text":"<p>Read a JSON file of <code>.nml</code> parameters. </p> <p>Reads a JSON file of GLM configuration blocks and returns a dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import glm_json\n&gt;&gt;&gt; json_to_nml = glm_json.JSONReader(\"sparkling_lake.json\")\n&gt;&gt;&gt; json_to_nml.read_json()\n</code></pre>"},{"location":"nml/","title":"NML","text":""},{"location":"nml/#glmpy.nml.glm_nml","title":"<code>glm_nml</code>","text":""},{"location":"nml/#glmpy.nml.glm_nml.BirdModelBlock","title":"<code>BirdModelBlock</code>","text":"<p>             Bases: <code>_BaseBlock</code></p> <p>Construct the <code>&amp;bird_model</code> model parameters.</p> <p>The <code>&amp;bird_model</code> parameters define the surface irradiance based on the  Bird Clear Sky Model (BCSM) (Bird, 1984). <code>BirdModelBlock</code> provides the  means to construct a dictionary containing these parameters for use in the  <code>glm_nml.GLMNML</code> class. Model parameters are set as attributes upon  initialising an instance of the class or using the <code>set_attributes()</code>  method. The <code>get_params()</code> method returns the parameter dictionary and performs optional error checking to ensure compliant parameters. </p> <p>Attributes:</p> Name Type Description <code>AP</code> <code>Union[float, None]</code> <p>Atmospheric pressure (hPa). Default is <code>None</code>.</p> <code>Oz</code> <code>Union[float, None]</code> <p>Ozone concentration (atm-cm). Default is <code>None</code>.</p> <code>WatVap</code> <code>Union[float, None]</code> <p>Total Precipitable water vapor (atm-cm). Default is <code>None</code>.</p> <code>AOD500</code> <code>Union[float, None]</code> <p>Dimensionless Aerosol Optical Depth at wavelength 500 nm. Default is <code>None</code>.</p> <code>AOD380</code> <code>Union[float, None]</code> <p>Dimensionless Aerosol Optical Depth at wavelength 380 nm. Default is <code>None</code>.</p> <code>Albedo</code> <code>Union[float, None]</code> <p>Albedo of the surface used for Bird Model insolation calculation. Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; bird_model = glm_nml.BirdModelBlock(\n...     AP=973,\n...     Oz=0.2\n... )\n&gt;&gt;&gt; bird_model_attrs = {\n...     \"Oz\": 0.279,\n...     \"WatVap\": 1.1,\n...     \"AOD500\": 0.033,\n...     \"AOD380\": 0.038,\n...     \"Albedo\": 0.2\n... }\n&gt;&gt;&gt; bird_model.set_attributes(bird_model_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.BirdModelBlock.get_params","title":"<code>get_params(check_params=False)</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Consolidate the model parameters set during class instance  initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>glm_nml.GLMNML</code> class. </p> <p>Parameters:</p> Name Type Description Default <code>check_params</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the configuration block parameters.</p>"},{"location":"nml/#glmpy.nml.glm_nml.BirdModelBlock.set_attrs","title":"<code>set_attrs(attrs_dict)</code>","text":"<p>Set attributes for an instance of a configuration block class.</p> <p>Parameters:</p> Name Type Description Default <code>attrs_dict</code> <code>dict</code> <p>A dictionary of GLM parameters to set the respective attributes in  the configuration block class instance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup = glm_nml.SetupBlock()\n&gt;&gt;&gt; glm_setup.set_attrs(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.GLMNML","title":"<code>GLMNML</code>","text":"<p>Write GLM NML files.</p> <p>The General Lake Model (GLM) namelist file (<code>.nml</code>) describes the parameter configuration for running simulations. The <code>GLMNML</code> class builds a NML  file by combining dictionaries of parameters that correspond with each  configuration block, e.g., <code>&amp;glm_setup</code>, <code>&amp;morphometry</code>, and <code>&amp;time</code>. Each dictionary of parameters can be constructed using the respective block classes, e.g., <code>glm_nml.SetupBlock</code>, <code>glm_nml.MorphometryBlock</code>, and  <code>glm_nml.TimeBlock</code>.</p> <p>An optional <code>check_errors</code> argument can be set to raise errors when  parameters from separate configuration blocks are in conflict. The NML file can be saved using the <code>write_nml()</code> method.</p> <p>Attributes:</p> Name Type Description <code>glm_setup</code> <code>dict</code> <p>Dictionary of <code>&amp;glm_setup</code> parameters. See <code>glm_nml.SetupBlock</code>.  Required for every GLM simulation.</p> <code>morphometry</code> <code>dict</code> <p>Dictionary of <code>&amp;morphometry</code> parameters. See <code>glm_nml.MorphometryBlock</code> . Required for every GLM simulation.</p> <code>time</code> <code>dict</code> <p>Dictionary of <code>&amp;time</code> parameters. See <code>glm_nml.TimeBlock</code>. Required for  every GLM simulation.</p> <code>init_profiles</code> <code>dict</code> <p>Dictionary of <code>&amp;init_profiles</code> parameters. See  <code>glm_nml.InitProfilesBlock</code>. Required for every GLM simulation.</p> <code>mixing</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;mixing</code> parameters. See <code>glm_nml.MixingBlock</code>. Default  is <code>None</code>.</p> <code>output</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;output</code> parameters. See <code>glm_nml.OutputBlock</code>. Default  is <code>None</code>.</p> <code>meteorology</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;meteorology</code> parameters. See <code>glm_nml.MeteorologyBlock</code> . Default is <code>None</code>.</p> <code>light</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;light</code> parameters. See <code>glm_nml.LightBlock</code>. Default is  <code>None</code>.</p> <code>bird_model</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;bird_model</code> parameters. See <code>glm_nml.BirdModelBlock</code>.  Default is <code>None</code>.</p> <code>inflow</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;inflow</code> parameters. See <code>glm_nml.InflowBlock</code>. Default  is <code>None</code>.</p> <code>outflow</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;outflow</code> parameters. See <code>glm_nml.OutflowBlock</code>.  Default is <code>None</code>.</p> <code>sediment</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;sediment</code> parameters. See <code>glm_nml.SedimentBlock</code>.  Default is <code>None</code>.</p> <code>snow_ice</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;snow_ice</code> parameters. See <code>glm_nml.SnowIceBlock</code>.  Default is <code>None</code>.</p> <code>wq_setup</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;wq_setup</code> parameters. See <code>glm_nml.WQSetupBlock</code>.  Default is <code>None</code>.</p> <p>Examples:</p> <p>Import the <code>glm_nml</code> module:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n</code></pre> <p>Initialise instances of the NML configuration block classes:</p> <pre><code>&gt;&gt;&gt; glm_setup = glm_nml.SetupBlock()\n&gt;&gt;&gt; morphometry = glm_nml.MorphometryBlock()\n&gt;&gt;&gt; time = glm_nml.TimeBlock()\n&gt;&gt;&gt; init_profiles = glm_nml.InitProfilesBlock()\n&gt;&gt;&gt; mixing = glm_nml.MixingBlock()\n&gt;&gt;&gt; output = glm_nml.OutputBlock()\n&gt;&gt;&gt; meteorology = glm_nml.MeteorologyBlock()\n&gt;&gt;&gt; light = glm_nml.LightBlock()\n&gt;&gt;&gt; bird_model = glm_nml.BirdModelBlock()\n&gt;&gt;&gt; inflow = glm_nml.InflowBlock()\n&gt;&gt;&gt; outflow = glm_nml.OutflowBlock()\n&gt;&gt;&gt; sediment = glm_nml.SedimentBlock()\n&gt;&gt;&gt; snow_ice = glm_nml.SnowIceBlock()\n&gt;&gt;&gt; wq_setup = glm_nml.WQSetupBlock()\n</code></pre> <p>Set the instance attributes from dictionaries of GLM parameters (omitted  for brevity):</p> <pre><code>&gt;&gt;&gt; glm_setup.set_attributes(glm_setup_attrs)\n&gt;&gt;&gt; morphometry.set_attributes(morphometry_attrs)\n&gt;&gt;&gt; time.set_attributes(time_attrs)\n&gt;&gt;&gt; init_profiles.set_attributes(init_profiles_attrs)\n&gt;&gt;&gt; mixing.set_attributes(mixing_attrs)\n&gt;&gt;&gt; output.set_attributes(output_attrs)\n&gt;&gt;&gt; meteorology.set_attributes(meteorology_attrs)\n&gt;&gt;&gt; light.set_attributes(light_attrs)\n&gt;&gt;&gt; bird_model.set_attributes(bird_model_attrs)\n&gt;&gt;&gt; inflow.set_attributes(inflow_attrs)\n&gt;&gt;&gt; outflow.set_attributes(outflow_attrs)\n&gt;&gt;&gt; sediment.set_attributes(sediment_attrs)\n&gt;&gt;&gt; snow_ice.set_attributes(snow_ice_attrs)\n&gt;&gt;&gt; wq_setup.set_attributes(wq_setup_attrs)\n</code></pre> <p>Initialise the <code>GLMNML</code> class and pass in the consolidated dictionaries ( returned by the call method of block classes).</p> <pre><code>&gt;&gt;&gt; nml_file = glm_nml.GLMNML(\n...     glm_setup=glm_setup(),\n...     morphometry=morphometry(),\n...     time=time(),\n...     init_profiles=init_profiles(),\n...     mixing=mixing(),\n...     output=output(),\n...     meteorology=meteorology(),\n...     light=light(),\n...     bird_model=bird_model(),\n...     inflow=inflow(),\n...     outflow=outflow(),\n...     sediment=sediment(),\n...     snow_ice=snow_ice(),\n...     wq_setup=wq_setup()\n... )\n</code></pre> <p>Write the <code>.nml</code> file with the <code>write_nml()</code> method.</p> <pre><code>&gt;&gt;&gt; nml_file.write_nml(nml_file_path=\"glm3.nml\")\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.GLMNML.write_nml","title":"<code>write_nml(nml_file_path='glm3.nml', list_len=None)</code>","text":"<p>Write the <code>.nml</code> file.</p> <p>Write the <code>.nml</code> of model parameters.</p> <p>Parameters:</p> Name Type Description Default <code>nml_file_path</code> <code>str</code> <p>File path to save .nml file, by default <code>glm3.nml</code>.</p> <code>'glm3.nml'</code> <code>list_len</code> <code>Union[int, None]</code> <p>The number of items in a comma-separated list to write before  adding a line break. When set to <code>None</code>, no line breaks are added.  Default is <code>None</code>.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; nml_file.write_nml(nml_file_path=\"my_lake.nml\")\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.InflowBlock","title":"<code>InflowBlock</code>","text":"<p>             Bases: <code>_BaseBlock</code></p> <p>Return the <code>&amp;inflow</code> parameter dictionary.</p> <p>The <code>&amp;inflow</code> parameters define river inflows and submerged inflows.  <code>InflowBlock</code> provides the means to construct a dictionary containing these  parameters for use in the <code>glm_nml.GLMNML</code> class. Model parameters are set  as attributes upon initialising an instance of the class or using the  <code>set_attributes()</code> method. The <code>get_params()</code> method returns the parameter  dictionary and performs optional error checking to ensure compliant  parameters. </p> <p>Attributes:</p> Name Type Description <code>num_inflows</code> <code>Union[int, None]</code> <p>Number of inflows to be simulated in this simulation. Default is  <code>None</code>.</p> <code>names_of_strms</code> <code>Union[List[str], str, None]</code> <p>Names of each inflow. A list if <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>subm_flag</code> <code>Union[List[bool], bool, None]</code> <p>Switch indicating if the inflow is entering as a submerged input. A  list if <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>subm_elev</code> <code>Union[List[float], float, None]</code> <p>Elevation of the submerged inflow. A list if <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>strm_hf_angle</code> <code>Union[List[float], float, None]</code> <p>Angle describing the width of an inflow river channel (\"half angle\"). A  list if <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>strmbd_slope</code> <code>Union[List[float], float, None]</code> <p>Slope of the streambed / river thalweg for each river (degrees). A  list if <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>strmbd_drag</code> <code>Union[List[float], float, None]</code> <p>Drag coefficient of the river inflow thalweg, to calculate entrainment during insertion. A list if <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>coef_inf_entrain</code> <code>Union[List[float], float, None]</code> <p>Undocumented parameter. A list if <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>inflow_factor</code> <code>Union[List[float], float, None]</code> <p>Scaling factor that can be applied to adjust the provided input data. A list if <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>inflow_fl</code> <code>Union[List[str], str, None]</code> <p>Filename(s) of the inflow CSV boundary condition files. A list if  <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>inflow_varnum</code> <code>Union[int, None]</code> <p>Number of variables being listed in the columns of <code>inflow_fl</code>. Can  include GLM variables. Default is <code>None</code>.</p> <code>inflow_vars</code> <code>Union[List[str], str, None]</code> <p>Names of the variables in the <code>inflow_fl</code>. Provide variables in the  order as they are in the file. Default is <code>None</code>.</p> <code>time_fmt</code> <code>Union[str, None]</code> <p>Time format of the 1st column in the <code>inflow_fl</code>. For example,  <code>'YYYY-MM-DD hh:mm:ss'</code>. Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; inflow = glm_nml.InflowBlock(\n...     num_inflows=5,\n...     names_of_strms= ['Inflow1','Inflow2','Inflow3','Inflow4','Inflow5']\n... )\n&gt;&gt;&gt; inflow_attrs = {\n...     \"num_inflows\": 6,\n...     \"names_of_strms\": [\n...         'Inflow1','Inflow2','Inflow3','Inflow4','Inflow5','Inflow6'\n...     ],\n...     \"subm_flag\": [False, False, False, True, False, False],\n...     \"strm_hf_angle\": [85.0, 85.0, 85.0, 85.0, 85.0, 85.0],\n...     \"strmbd_slope\": [4.0, 4.0, 4.0, 4.0, 4.0, 4.0],\n...     \"strmbd_drag\": [0.0160, 0.0160, 0.0160, 0.0160, 0.0160, 0.0160],\n...     \"inflow_factor\": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n...     \"inflow_fl\": [\n...         'bcs/inflow_1.csv', 'bcs/inflow_2.csv', 'bcs/inflow_3.csv', \n...         'bcs/inflow_4.csv', 'bcs/inflow_5.csv', 'bcs/inflow_6.csv'\n...     ],\n...     \"inflow_varnum\": 3,\n...     \"inflow_vars\": ['FLOW', 'TEMP', 'SALT'],\n...     \"coef_inf_entrain\": 0.0,\n...     \"time_fmt\": 'YYYY-MM-DD hh:mm:ss'\n... }\n&gt;&gt;&gt; inflow.set_attributes(inflow_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.InflowBlock.get_params","title":"<code>get_params(check_params=False)</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Consolidate the model parameters set during class instance  initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>glm_nml.GLMNML</code> class. </p> <p>Parameters:</p> Name Type Description Default <code>check_params</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the configuration block parameters.</p>"},{"location":"nml/#glmpy.nml.glm_nml.InflowBlock.set_attrs","title":"<code>set_attrs(attrs_dict)</code>","text":"<p>Set attributes for an instance of a configuration block class.</p> <p>Parameters:</p> Name Type Description Default <code>attrs_dict</code> <code>dict</code> <p>A dictionary of GLM parameters to set the respective attributes in  the configuration block class instance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup = glm_nml.SetupBlock()\n&gt;&gt;&gt; glm_setup.set_attrs(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.InitProfilesBlock","title":"<code>InitProfilesBlock</code>","text":"<p>             Bases: <code>_BaseBlock</code></p> <p>Construct the <code>&amp;init_profiles</code> model parameters.</p> <p>The <code>&amp;init_profiles</code> parameters define the initial conditions at specific  depths in the water body. <code>InitProfilesBlock</code> provides the means to  construct a dictionary containing these parameters for use in the  <code>glm_nml.GLMNML</code> class. Model parameters are set as attributes upon  initialising an instance of the class or using the <code>set_attributes()</code>  method. The <code>get_params()</code> method returns the parameter dictionary and performs optional error checking to ensure compliant parameters. </p> <p>Attributes:</p> Name Type Description <code>lake_depth</code> <code>Union[float, None]</code> <p>Initial lake height/depth (m). Default is <code>None</code>.</p> <code>num_depths</code> <code>Union[int, None]</code> <p>Number of depths provided for initial profiles. Default is <code>None</code>.</p> <code>the_depths</code> <code>Union[List[float], float, None]</code> <p>The depths of the initial profile points (m). Default is <code>None</code>.</p> <code>the_temps</code> <code>Union[List[float], float, None]</code> <p>The temperature (\u00b0C) at each of the initial profile points. Default is <code>None</code>.</p> <code>the_sals</code> <code>Union[List[float], float, None]</code> <p>The salinity (ppt) at each of the initial profile points. Default is <code>None</code>.</p> <code>num_wq_vars</code> <code>Union[int, None]</code> <p>Number of non-GLM (i.e., FABM or AED2) variables to be initialised. Default is <code>None</code>.</p> <code>wq_names</code> <code>Union[List[str], str, None]</code> <p>Names of non-GLM (i.e., FABM or AED2) variables to be initialised. Default is <code>None</code>.</p> <code>wq_init_vals</code> <code>Union[List[float], float, None]</code> <p>List of water quality variable initial data. Default is <code>None</code>.</p> <code>restart_variables</code> <code>Union[List[float], float, None]</code> <p>Restart variables to restart model from a previous saved  state. Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; init_profiles = glm_nml.InitProfilesBlock(\n...     lake_depth=43,\n...     num_depths=2\n... )\n&gt;&gt;&gt; init_profiles_attrs = {\n...     \"num_depths\": 3,\n...     \"the_depths\": [1, 20, 40],\n...     \"the_temps\": [18.0, 18.0, 18.0],\n...     \"the_sals\": [ 0.5, 0.5, 0.5],\n...     \"num_wq_vars\": 6,\n...     \"wq_names\": [\n...         'OGM_don','OGM_pon','OGM_dop','OGM_pop','OGM_doc','OGM_poc'\n...     ],\n...     \"wq_init_vals\": [\n...         1.1, 1.2, 1.3, 1.2, 1.3,\n...         2.1, 2.2, 2.3, 1.2, 1.3,\n...         3.1, 3.2, 3.3, 1.2, 1.3,\n...         4.1, 4.2, 4.3, 1.2, 1.3,\n...         5.1, 5.2, 5.3, 1.2, 1.3,\n...         6.1, 6.2, 6.3, 1.2, 1.3\n...     ],\n...     \"restart_variables\": [\n...         70.30026370304032,\n...         0.8994359224744514,\n...         0.03906299522902229,\n...         6.1835334329751606e-06,\n...         6833986.341232119,\n...         0.0,\n...         0.10319285945774581,\n...         25.0,\n...         25.0,\n...         25.0,\n...         0.0,\n...         70.30026370304032,\n...         0.0,\n...         0.0,\n...         0.0,\n...         0.0,\n...         0.0\n...     ]\n... }\n&gt;&gt;&gt; init_profiles.set_attributes(init_profiles_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.InitProfilesBlock.get_params","title":"<code>get_params(check_params=False)</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Consolidate the model parameters set during class instance  initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>glm_nml.GLMNML</code> class. </p> <p>Parameters:</p> Name Type Description Default <code>check_params</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the configuration block parameters.</p>"},{"location":"nml/#glmpy.nml.glm_nml.InitProfilesBlock.set_attrs","title":"<code>set_attrs(attrs_dict)</code>","text":"<p>Set attributes for an instance of a configuration block class.</p> <p>Parameters:</p> Name Type Description Default <code>attrs_dict</code> <code>dict</code> <p>A dictionary of GLM parameters to set the respective attributes in  the configuration block class instance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup = glm_nml.SetupBlock()\n&gt;&gt;&gt; glm_setup.set_attrs(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.LightBlock","title":"<code>LightBlock</code>","text":"<p>             Bases: <code>_BaseBlock</code></p> <p>Construct the <code>&amp;light</code> model parameters.</p> <p>The <code>&amp;light</code> parameters define light penertration into the water body.  <code>LightBlock</code> provides the means to construct a dictionary containing these  parameters for use in the <code>glm_nml.GLMNML</code> class. Model parameters are set  as attributes upon initialising an instance of the class or using the  <code>set_attributes()</code> method. The <code>get_params()</code> method returns the parameter  dictionary andperforms optional error checking to ensure compliant  parameters. </p> <p>Attributes:</p> Name Type Description <code>light_mode</code> <code>Union[int, None]</code> <p>Switch to configure the approach to light penetration. Options are <code>0</code>  or <code>1</code>. Default is <code>None</code>.</p> <code>Kw</code> <code>Union[float, None]</code> <p>Light extinction coefficient (m^{-1}). Used when <code>light_mode=0</code>.  Default is <code>None</code></p> <code>Kw_file</code> <code>Union[str, None]</code> <p>Name of file with Kw time-series included. Default is <code>None</code>.</p> <code>n_bands</code> <code>Union[int, None]</code> <p>Number of light bandwidths to simulate. Used when <code>light_mode=1</code>.  Default is <code>None</code>.</p> <code>light_extc</code> <code>Union[List[float], float, None]</code> <p>Comma-separated list of light extinction coefficients for each waveband. Default is <code>None</code>.</p> <code>energy_frac</code> <code>Union[List[float], float, None]</code> <p>Comma-separated list of energy fraction captured by each waveband. Default is None.</p> <code>Benthic_Imin</code> <code>Union[float, None]</code> <p>Critical fraction of incident light reaching the benthos. Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; light = glm_nml.LightBlock(\n...     light_mode=0,\n...     Kw=0.5\n... )\n&gt;&gt;&gt; light_attrs = {\n...     \"n_bands\": 4,\n...     \"light_extc\": [1.0, 0.5, 2.0, 4.0],\n...     \"energy_frac\": [0.51, 0.45, 0.035, 0.005],\n...     \"Benthic_Imin\": 10\n... }\n&gt;&gt;&gt; light.set_attributes(light_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.LightBlock.get_params","title":"<code>get_params(check_params=False)</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Consolidate the model parameters set during class instance  initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>glm_nml.GLMNML</code> class. </p> <p>Parameters:</p> Name Type Description Default <code>check_params</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the configuration block parameters.</p>"},{"location":"nml/#glmpy.nml.glm_nml.LightBlock.set_attrs","title":"<code>set_attrs(attrs_dict)</code>","text":"<p>Set attributes for an instance of a configuration block class.</p> <p>Parameters:</p> Name Type Description Default <code>attrs_dict</code> <code>dict</code> <p>A dictionary of GLM parameters to set the respective attributes in  the configuration block class instance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup = glm_nml.SetupBlock()\n&gt;&gt;&gt; glm_setup.set_attrs(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.MeteorologyBlock","title":"<code>MeteorologyBlock</code>","text":"<p>             Bases: <code>_BaseBlock</code></p> <p>Construct the <code>&amp;meteorology</code> model parameters.</p> <p>The <code>&amp;meteorology</code> parameters define a variety of meteorological  dynamics, e.g., rainfall, air temperature, radiation, wind, and cloud  cover. <code>MeteorologyBlock</code> provides the means to construct a dictionary  containing these parameters for use in the <code>glm_nml.GLMNML</code> class. Model parameters are set as attributes upon initialising an instance of the  class or using the <code>set_attributes()</code> method. The <code>get_params()</code> method  returns the parameter dictionary and performs optional error checking to  ensure compliant parameters. </p> <p>Attributes:</p> Name Type Description <code>met_sw</code> <code>Union[bool, None]</code> <p>Switch to enable the surface heating module. Default is <code>None</code>.</p> <code>meteo_fl</code> <code>Union[str, None]</code> <p>Filename of the meterological file. Include path and filename. Default  is <code>None</code>.</p> <code>subdaily</code> <code>Union[bool, None]</code> <p>Switch to indicate the meteorological data is provided with sub-daily resolution, at an interval equivalent to <code>dt</code> from <code>nml.NMLTime</code> (\u0394t).  Default is <code>None</code>.</p> <code>time_fmt</code> <code>Union[str, None]</code> <p>Time format of the 1st column in the inflow_fl. For example, 'YYYY-MM-DD hhss'. Default is <code>None</code>.</p> <code>rad_mode</code> <code>Union[int, None]</code> <p>Switch to configure which incoming radiation option to use. Options are <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, or <code>5</code>. Default is <code>None</code>.</p> <code>albedo_mode</code> <code>Union[int, None]</code> <p>Switch to configure which albedo calculation option is used. Options  are <code>1</code> for Hamilton &amp; Schladow, <code>2</code> for Briegleb et al., or <code>3</code> for  Yajima &amp; Yamamoto. Default is <code>None</code>.</p> <code>sw_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the shortwave radiation data provided in the <code>meteo_fl</code>. Default is <code>None</code>.</p> <code>lw_type</code> <code>Union[str, None]</code> <p>Switch to configure which input approach is being used for longwave/cloud data in the <code>meteo_fl</code>. Options are <code>'LW_IN'</code> for  incident longwave, <code>'LW_NET'</code> for net longwave, or <code>'LW_CC'</code> for cloud  cover. Default is <code>None</code>.</p> <code>cloud_mode</code> <code>Union[int, None]</code> <p>Switch to configure which atmospheric emmissivity calculation option is used. Options are <code>1</code> for Idso and Jackson, <code>2</code> for Swinbank, <code>3</code> for Brutsaert, <code>4</code> for Yajima &amp; Yamamoto. Default is <code>None</code>.</p> <code>lw_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the longwave (or cloud) data provided in the <code>meteo_fl</code>. Default is <code>None</code>.</p> <code>atm_stab</code> <code>Union[int, None]</code> <p>Switch to configure which approach to atmospheric stability is used.  <code>0</code> for neutral conditions, <code>1</code> for an undocumented use case, and <code>2</code>  for an undocumented use case. Default is <code>None</code>.</p> <code>rh_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the relative humidity data provided in the <code>meteo_fl</code>. Default is <code>None</code>.</p> <code>at_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the air temperature data provided in the <code>meteo_fl</code>. Default is <code>None</code>.</p> <code>ce</code> <code>Union[float, None]</code> <p>Bulk aerodynamic transfer coefficient for latent heat flux. Default is <code>None</code>.</p> <code>ch</code> <code>Union[float, None]</code> <p>Bulk aerodynamic transfer coefficient for sensible heat flux. Default is <code>None</code>.</p> <code>rain_sw</code> <code>Union[bool, None]</code> <p>Switch to configure rainfall input concentrations. Default is <code>None</code>.</p> <code>rain_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the rainfall data provided in the <code>meteo_fl</code>. Default is <code>None</code>.</p> <code>catchrain</code> <code>Union[bool, None]</code> <p>Switch that configures runoff from exposed banks of lake area. Default is <code>None</code>.</p> <code>rain_threshold</code> <code>Union[float, None]</code> <p>Daily rainfall amount (m) required before runoff from exposed banks occurs. Default is <code>None</code>.</p> <code>runoff_coef</code> <code>Union[float, None]</code> <p>Conversion fraction of infiltration excess rainfall to runoff in exposed lake banks. Default is <code>None</code>.</p> <code>cd</code> <code>Union[float, None]</code> <p>Bulk aerodynamic transfer coefficient for momentum. Default is <code>None</code>.</p> <code>wind_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the windspeed data provided in the <code>meteo_fl</code>. Default is <code>None</code>.</p> <code>fetch_mode</code> <code>Union[int, None]</code> <p>Switch to configure which wind-sheltering/fetch option to use. Options  are <code>0</code> for no sheltering, <code>1</code> for area-based scaling, <code>2</code> for Markfort  length-scale, or <code>3</code> for user input scaling table. Default is <code>None</code>.</p> <code>Aws</code> <code>Union[float, None]</code> <p>Undocumented parameter. Required if <code>fetch_mode=1</code>. Default is <code>None</code>.</p> <code>Xws</code> <code>Union[float, None]</code> <p>Undocumented parameter. Required if <code>fetch_mode=2</code>. Default is <code>None</code>.</p> <code>num_dir</code> <code>Union[int, None]</code> <p>Number of wind direction reference points being read in. Required if  <code>fetch_mode=2</code> or <code>fetch_mode=3</code>. Default is <code>None</code>.</p> <code>wind_dir</code> <code>Union[float, None]</code> <p>Wind directions used for wind-sheltering effects. Required if  <code>fetch_mode=2</code> or <code>fetch_mode=3</code>. Default is <code>None</code>.</p> <code>fetch_scale</code> <code>Union[float, None]</code> <p>Direction specific wind-sheltering scaling factors. Required if  <code>fetch_mode=2</code> or <code>fetch_mode=3</code>. Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; meteorology = glm_nml.MeteorologyBlock(\n...     met_sw=True,\n...     lw_type='LW_NET'\n... )\n&gt;&gt;&gt; meteorology_attrs = {\n...     \"lw_type\": \"LW_IN\",\n...     \"rain_sw\": False,\n...     \"atm_stab\": 0,\n...     \"fetch_mode\": 0,\n...     \"rad_mode\": 1,\n...     \"albedo_mode\": 1,\n...     \"cloud_mode\": 4,\n...     \"subdaily\": True,\n...     \"meteo_fl\": 'bcs/met_hourly.csv',\n...     \"wind_factor\": 0.9,\n...     \"ce\": 0.0013,\n...     \"ch\": 0.0013,\n...     \"cd\": 0.0013,\n...     \"catchrain\": True,\n...     \"rain_threshold\": 0.001,\n...     \"runoff_coef\": 0.0\n... }\n&gt;&gt;&gt; meteorology.set_attributes(meteorology_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.MeteorologyBlock.get_params","title":"<code>get_params(check_params=False)</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Consolidate the model parameters set during class instance  initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>glm_nml.GLMNML</code> class. </p> <p>Parameters:</p> Name Type Description Default <code>check_params</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the configuration block parameters.</p>"},{"location":"nml/#glmpy.nml.glm_nml.MeteorologyBlock.set_attrs","title":"<code>set_attrs(attrs_dict)</code>","text":"<p>Set attributes for an instance of a configuration block class.</p> <p>Parameters:</p> Name Type Description Default <code>attrs_dict</code> <code>dict</code> <p>A dictionary of GLM parameters to set the respective attributes in  the configuration block class instance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup = glm_nml.SetupBlock()\n&gt;&gt;&gt; glm_setup.set_attrs(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.MixingBlock","title":"<code>MixingBlock</code>","text":"<p>             Bases: <code>_BaseBlock</code></p> <p>Construct the <code>&amp;mixing</code> model parameters.</p> <p>The <code>&amp;mixing</code> parameters define the dynamics of layer mixing in the  modelled water body. <code>MixingBlock</code> provides the means to construct a  dictionary containing these parameters for use in the <code>glm_nml.GLMNML</code>  class. Model parameters are set as attributes upon initialising an instance  of the class or using the <code>set_attributes()</code> method. The <code>get_params()</code>  method returns the parameter dictionary and performs optional error  checking to ensure compliant parameters. </p> <p>Attributes:</p> Name Type Description <code>surface_mixing</code> <code>Union[int, None]</code> <p>Switch to select the options of the surface mixing model. Options are  <code>0</code> for no surface mixing, <code>1</code>, and <code>2</code>. Default is <code>None</code>.</p> <code>coef_mix_conv</code> <code>Union[float, None]</code> <p>Mixing efficiency - convective overturn. Default is <code>None</code>.</p> <code>coef_wind_stir</code> <code>Union[float, None]</code> <p>Mixing efficiency - wind stirring. Default is <code>None</code>.</p> <code>coef_mix_shear</code> <code>Union[float, None]</code> <p>Mixing efficiency - shear production. Default is <code>None</code>.</p> <code>coef_mix_turb</code> <code>Union[float, None]</code> <p>Mixing efficiency - unsteady turbulence effects. Default is <code>None</code>.</p> <code>coef_mix_KH</code> <code>Union[float, None]</code> <p>Mixing efficiency - Kelvin-Helmholtz billowing. Default is <code>None</code>.</p> <code>deep_mixing</code> <code>Union[int, None]</code> <p>Switch to select the options of the deep (hypolimnetic) mixing model. Options are <code>0</code> for no deep mixing, <code>1</code> for constant diffusivity, and  <code>2</code> for the Weinstock model. Default is <code>None</code>.</p> <code>coef_mix_hyp</code> <code>Union[float, None]</code> <p>Mixing efficiency - hypolimnetic turbulence. Default is <code>None</code>.</p> <code>diff</code> <code>Union[float, None]</code> <p>Background (molecular) diffusivity in the hypolimnion. Default is  <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; mixing = glm_nml.MixingBlock(\n...     surface_mixing=1,\n...     coef_mix_conv=0.1,\n... )\n&gt;&gt;&gt; mixing_attrs = {\n...     \"coef_mix_conv\": 0.125,\n...     \"coef_wind_stir\": 0.23,\n...     \"coef_mix_shear\":0.2,\n...     \"coef_mix_turb\": 0.51,\n...     \"coef_mix_KH\": 0.3,\n...     \"deep_mixing\": 2,\n...     \"coef_mix_hyp\": 0.5,\n...     \"diff\": 0.0\n... }\n&gt;&gt;&gt; mixing.set_attributes(mixing_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.MixingBlock.get_params","title":"<code>get_params(check_params=False)</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Consolidate the model parameters set during class instance  initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>glm_nml.GLMNML</code> class. </p> <p>Parameters:</p> Name Type Description Default <code>check_params</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the configuration block parameters.</p>"},{"location":"nml/#glmpy.nml.glm_nml.MixingBlock.set_attrs","title":"<code>set_attrs(attrs_dict)</code>","text":"<p>Set attributes for an instance of a configuration block class.</p> <p>Parameters:</p> Name Type Description Default <code>attrs_dict</code> <code>dict</code> <p>A dictionary of GLM parameters to set the respective attributes in  the configuration block class instance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup = glm_nml.SetupBlock()\n&gt;&gt;&gt; glm_setup.set_attrs(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.MorphometryBlock","title":"<code>MorphometryBlock</code>","text":"<p>             Bases: <code>_BaseBlock</code></p> <p>Construct the <code>&amp;morphometry</code> model parameters.</p> <p>The <code>&amp;morphometry</code> parameters define the physical dimensions and location  of the water body. <code>MorphometryBlock</code> provides the means to construct a  dictionary containing these parameters for use in the <code>glm_nml.GLMNML</code>  class. Model parameters are set as attributes upon initialising an instance  of the class or using the <code>set_attributes()</code> method. The <code>get_params()</code>  method returns the parameter dictionary and performs optional error  checking to ensure compliant parameters. </p> <p>Attributes:</p> Name Type Description <code>lake_name</code> <code>Union[str, None]</code> <p>Site name. Default is <code>None</code>.</p> <code>latitude</code> <code>Union[float, None]</code> <p>Latitude, positive North (\u00b0N). Default is <code>None</code>.</p> <code>longitude</code> <code>Union[float, None]</code> <p>Longitude, positive East (\u00b0E). Default is <code>None</code>.</p> <code>base_elev</code> <code>Union[float, None]</code> <p>Elevation of the bottom-most point of the lake (m above datum). Default is <code>None</code>.</p> <code>crest_elev</code> <code>Union[float, None]</code> <p>Elevation of a weir crest, where overflow begins (m above datum).  Default is <code>None</code>.</p> <code>bsn_len</code> <code>Union[float, None]</code> <p>Length of the lake basin, at crest height (m). Default is <code>None</code>.</p> <code>bsn_wid</code> <code>Union[float, None]</code> <p>Width of the lake basin, at crest height (m). Default is <code>None</code>.</p> <code>bsn_vals</code> <code>Union[int, None]</code> <p>Number of points being provided to described the hyposgraphic details. Default is <code>None</code>.</p> <code>H</code> <code>Union[List[float], None]</code> <p>Comma-separated list of lake elevations (m above datum). Default is <code>None</code>.</p> <code>A</code> <code>Union[List[float], None]</code> <p>Comma-separated list of lake areas (m^2). Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; morphometry = glm_nml.MorphometryBlock(\n...     lake_name='Example Lake',\n...     latitude=30.0\n... )\n&gt;&gt;&gt; morphometry_attrs = {\n...     \"latitude\": 32.0,\n...     \"longitude\": 35.0,\n...     \"base_elev\": -252.9,\n...     \"crest_elev\": -203.9,\n...     \"bsn_len\": 21000.0,\n...     \"bsn_wid\": 13000.0,\n...     \"bsn_vals\": 45,\n...     \"H\": [\n...         -252.9, -251.9, -250.9, -249.9, -248.9, -247.9, -246.9, -245.9, \n...         -244.9, -243.9, -242.9, -241.9, -240.9, -239.9, -238.9, -237.9, \n...         -236.9, -235.9, -234.9, -233.9, -232.9, -231.9, -230.9, -229.9,  \n...         -228.9, -227.9, -226.9, -225.9, -224.9, -223.9, -222.9, -221.9,  \n...         -220.9, -219.9, -218.9, -217.9, -216.9, -215.9, -214.9, -213.9,  \n...         -212.9, -211.9, -208.9, -207.9, -203.9\n...     ],\n...     \"A\": [\n...         0, 9250000, 15200000, 17875000, 21975000, 26625000, 31700000, \n...         33950000, 38250000, 41100000, 46800000, 51675000, 55725000, \n...         60200000, 64675000, 69600000, 74475000, 79850000, 85400000, \n...         90975000, 96400000, 102000000, 107000000, 113000000, 118000000, \n...         123000000, 128000000, 132000000, 136000000, 139000000, \n...         143000000, 146000000, 148000000, 150000000, 151000000, \n...         153000000, 155000000, 157000000, 158000000, 160000000, \n...         161000000, 162000000, 167000000, 170000000, 173000000\n...     ]\n... }\n&gt;&gt;&gt; morphometry.set_attributes(morphometry_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.MorphometryBlock.get_params","title":"<code>get_params(check_params=False)</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Consolidate the model parameters set during class instance  initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>glm_nml.GLMNML</code> class. </p> <p>Parameters:</p> Name Type Description Default <code>check_params</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the configuration block parameters.</p>"},{"location":"nml/#glmpy.nml.glm_nml.MorphometryBlock.set_attrs","title":"<code>set_attrs(attrs_dict)</code>","text":"<p>Set attributes for an instance of a configuration block class.</p> <p>Parameters:</p> Name Type Description Default <code>attrs_dict</code> <code>dict</code> <p>A dictionary of GLM parameters to set the respective attributes in  the configuration block class instance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup = glm_nml.SetupBlock()\n&gt;&gt;&gt; glm_setup.set_attrs(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.OutflowBlock","title":"<code>OutflowBlock</code>","text":"<p>             Bases: <code>_BaseBlock</code></p> <p>Construct the <code>&amp;outflow</code> model parameters.</p> <p>The <code>&amp;outflow</code> parameters define withdrawals, outlets, offtakes, and  seepage. <code>OutflowBlock</code> provides the means to construct a dictionary  containing these parameters for use in the <code>glm_nml.GLMNML</code> class. Model  parameters are set as attributes upon initialising an instance of the class  or using the <code>set_attributes()</code> method. The <code>get_params()</code> method returns  the parameter dictionary and performs optional error checking to ensure  compliant parameters. </p> <p>Attributes:</p> Name Type Description <code>num_outlet</code> <code>Union[int, None]</code> <p>Number of outflows (including withdrawals, outlets or offtakes) to be included in this simulation. Default is <code>None</code>.</p> <code>outflow_fl</code> <code>Union[List[str], str, None]</code> <p>Filename of the file containing the outflow time-series.  A list if <code>num_outlet &gt; 1</code>.Default is <code>None</code>.</p> <code>time_fmt</code> <code>Union[str, None]</code> <p>Time format of the 1st column in the <code>outflow_fl</code>. Default is <code>None</code>.</p> <code>outflow_factor</code> <code>Union[List[float], float, None]</code> <p>Scaling factor used as a multiplier for outflows. A list if  <code>num_outlet &gt; 1</code>. Default is <code>None</code>.</p> <code>outflow_thick_limit</code> <code>Union[List[float], float, None]</code> <p>Maximum vertical limit of withdrawal entrainment. A list if  <code>num_outlet &gt; 1</code>. Default is <code>None</code>.</p> <code>single_layer_draw</code> <code>Union[List[bool], bool, None]</code> <p>Switch to only limit withdrawal entrainment and force outflows from layer at the outlet elevation height. A list if <code>num_outlet &gt; 1</code>.  Default is <code>None</code>.</p> <code>flt_off_sw</code> <code>Union[List[bool], bool, None]</code> <p>Switch to indicate if the outflows are floating offtakes (taking water  from near the surface). A list if <code>num_outlet &gt; 1</code>. Default is <code>None</code>.</p> <code>outlet_type</code> <code>Union[List[int], int, None]</code> <p>Switch to configure approach of each withdrawal. Options are <code>1</code> for  fixed outlet height, <code>2</code> for floating offtake, <code>3</code> for adaptive  offtake/low oxy avoidance, <code>4</code> for adaptive offtake/isotherm following,  or <code>5</code> for adaptive offtake/temp time-series. A list if  <code>num_outlet &gt; 1</code>. Default is <code>None</code>.</p> <code>outl_elvs</code> <code>Union[List[float], float, None]</code> <p>Outlet elevations (m). A list if <code>num_outlet &gt; 1</code>. Default is <code>None</code>.</p> <code>bsn_len_outl</code> <code>Union[List[float], float, None]</code> <p>Basin length at the outlet height(s) (m). A list if <code>num_outlet &gt; 1</code>.  Default is <code>None</code>.</p> <code>bsn_wid_outl</code> <code>Union[List[float], float, None]</code> <p>Basin width at the outlet heights (m). A list if <code>num_outlet &gt; 1</code>.  Default is <code>None</code>.</p> <code>crit_O2</code> <code>Union[int, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>crit_O2_dep</code> <code>Union[int, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>crit_O2_days</code> <code>Union[int, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>outlet_crit</code> <code>Union[int, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>O2name</code> <code>Union[str, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>O2idx</code> <code>Union[str, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>target_temp</code> <code>Union[float, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>min_lake_temp</code> <code>Union[float, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>fac_range_upper</code> <code>Union[float, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>fac_range_lower</code> <code>Union[float, None</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>mix_withdraw</code> <code>Union[bool, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>coupl_oxy_sw</code> <code>Union[bool, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>withdrTemp_fl</code> <code>Union[str, None]</code> <p>Filename of the file containing the temperature time-series the  adaptive withdrawal is targeting. Required if <code>outlet_type=5</code>. Default  is <code>None</code>.</p> <code>seepage</code> <code>Union[bool, None]</code> <p>Switch to enable the seepage of water from the lake bottom. Default is <code>None</code>.</p> <code>seepage_rate</code> <code>Union[float, None]</code> <p>Seepage rate of water, or, soil hydraulic conductivity (m day^{-1}).  Default is <code>None</code>.</p> <code>crest_width</code> <code>Union[float, None]</code> <p>Width of weir (at crest height) where lake overflows (m). Default is <code>None</code>.</p> <code>crest_factor</code> <code>Union[float, None]</code> <p>Drag coefficient associated with the weir crest, used to compute the overflow discharge rate. Applies only when the crest elevation is  configured to be less than the maximum elevation of the domain. Default  is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; outflow = glm_nml.OutflowBlock(\n...     num_outlet=1,\n...     flt_off_sw=True\n... )\n&gt;&gt;&gt; outflow_attrs = {\n...     \"flt_off_sw\": False,\n...     \"outlet_type\": 1,\n...     \"outl_elvs\": -215.5,\n...     \"bsn_len_outl\": 18000,\n...     \"bsn_wid_outl\": 11000,\n...     \"outflow_fl\" : 'bcs/outflow.csv',\n...     \"outflow_factor\": 1.0,\n...     \"seepage\": True,\n...     \"seepage_rate\": 0.01\n... }\n&gt;&gt;&gt; outflow.set_attributes(outflow_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.OutflowBlock.get_params","title":"<code>get_params(check_params=False)</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Consolidate the model parameters set during class instance  initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>glm_nml.GLMNML</code> class. </p> <p>Parameters:</p> Name Type Description Default <code>check_params</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the configuration block parameters.</p>"},{"location":"nml/#glmpy.nml.glm_nml.OutflowBlock.set_attrs","title":"<code>set_attrs(attrs_dict)</code>","text":"<p>Set attributes for an instance of a configuration block class.</p> <p>Parameters:</p> Name Type Description Default <code>attrs_dict</code> <code>dict</code> <p>A dictionary of GLM parameters to set the respective attributes in  the configuration block class instance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup = glm_nml.SetupBlock()\n&gt;&gt;&gt; glm_setup.set_attrs(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.OutputBlock","title":"<code>OutputBlock</code>","text":"<p>             Bases: <code>_BaseBlock</code></p> <p>Construct the <code>&amp;output</code> model parameters.</p> <p>The <code>&amp;output</code> parameters define the contents and location of GLM output  files. <code>OutputBlock</code> provides the means to construct a dictionary  containing these parameters for use in the <code>glm_nml.GLMNML</code> class. Model  parameters are set as attributes upon initialising an instance of the class  or using the <code>set_attributes()</code> method. The <code>get_params()</code> method returns  the parameter dictionary and performs optional error checking to ensure  compliant parameters. </p> <p>Attributes:</p> Name Type Description <code>out_dir</code> <code>Union[str, None]</code> <p>Directory to write the output files. Default is <code>None</code>.</p> <code>out_fn</code> <code>Union[str, None]</code> <p>Filename of the main NetCDF output file. Default is <code>None</code>.</p> <code>nsave</code> <code>Union[int, None]</code> <p>Frequency to write to the NetCDF and CSV point files. Default is  <code>None</code>.</p> <code>csv_lake_fname</code> <code>Union[str, None]</code> <p>Filename for the daily summary file. Default is <code>None</code></p> <code>csv_point_nlevs</code> <code>Union[float, None]</code> <p>Number of specific level/depth CSV files to be created. Default is <code>None</code>.</p> <code>csv_point_fname</code> <code>Union[str, None]</code> <p>Name to be appended to specified depth CSV files. Default is <code>None</code>.</p> <code>csv_point_frombot</code> <code>Union[List[float], float, None]</code> <p>Comma separated list identify whether each output point listed in csv_point_at is relative to the bottom (i.e., heights) or the surface (i.e., depths). Default is <code>None</code>.</p> <code>csv_point_at</code> <code>Union[List[float], float, None]</code> <p>Height or Depth of points to output at (comma-separated list). Default is <code>None</code>.</p> <code>csv_point_nvars</code> <code>Union[int, None]</code> <p>Number of variables to output into the csv files. Default is <code>None</code>.</p> <code>csv_point_vars</code> <code>Union[List[str], str, None]</code> <p>Comma separated list of variable names. Default is <code>None</code>.</p> <code>csv_outlet_allinone</code> <code>Union[bool, None]</code> <p>Switch to create an optional outlet file combining all outlets. Default is <code>None</code>.</p> <code>csv_outlet_fname</code> <code>Union[str, None]</code> <p>Name to be appended to each of the outlet CSV files. Default is <code>None</code>.</p> <code>csv_outlet_nvars</code> <code>Union[int, None]</code> <p>Number of variables to be written into the outlet file(s). Default is <code>None</code>.</p> <code>csv_outlet_vars</code> <code>Union[List[str], str, None]</code> <p>Comma separated list of variable names to be included in the output file(s). Default is <code>None</code>.</p> <code>csv_ovrflw_fname</code> <code>Union[str, None]</code> <p>Filename to be used for recording the overflow details. Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; output = glm_nml.OutputBlock(\n...     out_dir=\"output\",\n...     out_fn=\"output_file\"\n... )\n&gt;&gt;&gt; output_attrs = {\n...     'out_fn': 'output',\n...     'nsave': 6,\n...     'csv_lake_fname': 'lake',\n...     'csv_point_nlevs': 2,\n...     'csv_point_fname': 'WQ_' ,\n...     'csv_point_at': [5, 30],    \n...     'csv_point_nvars': 7,\n...     'csv_point_vars': [\n...         'temp', 'salt', 'OXY_oxy', 'SIL_rsi', \n...         'NIT_amm', 'NIT_nit', 'PHS_frp'\n...     ],\n...     'csv_outlet_allinone': False,\n...     'csv_outlet_fname': 'outlet_',\n...     'csv_outlet_nvars': 4,\n...     'csv_outlet_vars': ['flow', 'temp', 'salt', 'OXY_oxy'],\n...     'csv_ovrflw_fname': \"overflow\"\n... }\n&gt;&gt;&gt; output.set_attributes(output_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.OutputBlock.get_params","title":"<code>get_params(check_params=False)</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Consolidate the model parameters set during class instance  initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>glm_nml.GLMNML</code> class. </p> <p>Parameters:</p> Name Type Description Default <code>check_params</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the configuration block parameters.</p>"},{"location":"nml/#glmpy.nml.glm_nml.OutputBlock.set_attrs","title":"<code>set_attrs(attrs_dict)</code>","text":"<p>Set attributes for an instance of a configuration block class.</p> <p>Parameters:</p> Name Type Description Default <code>attrs_dict</code> <code>dict</code> <p>A dictionary of GLM parameters to set the respective attributes in  the configuration block class instance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup = glm_nml.SetupBlock()\n&gt;&gt;&gt; glm_setup.set_attrs(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.SedimentBlock","title":"<code>SedimentBlock</code>","text":"<p>             Bases: <code>_BaseBlock</code></p> <p>Construct the <code>&amp;sediment</code> model parameters.</p> <p>The <code>&amp;sediment</code> parameters define the thermal properties of the  soil-sediment. <code>SedimentBlock</code> provides the means to construct a dictionary  containing these parameters for use in the <code>glm_nml.GLMNML</code> class. Model  parameters are set as attributes upon initialising an instance of the class  or using the <code>set_attributes()</code> method. The <code>get_params()</code> method returns  the parameter dictionary and performs optional error checking to ensure  compliant parameters. </p> <p>Attributes:</p> Name Type Description <code>sed_heat_Ksoil</code> <code>Union[float, None]</code> <p>Heat conductivity of soil/sediment. Default is <code>None</code>.</p> <code>sed_temp_depth</code> <code>Union[float, None]</code> <p>Depth of soil/sediment layer below the lake bottom, used for heat flux calculation. Default is <code>None</code>.</p> <code>sed_temp_mean</code> <code>Union[List[float], float, None]</code> <p>Annual mean sediment temperature. A list if <code>n_zones &gt; 1</code>. Default is  <code>None</code>.</p> <code>sed_temp_amplitude</code> <code>Union[List[float], float, None]</code> <p>Amplitude of temperature variation experienced in the sediment over one year. A list if <code>n_zones &gt; 1</code>. Default is <code>None</code>.</p> <code>sed_temp_peak_doy</code> <code>Union[List[int], int, None]</code> <p>Day of the year where the sediment temperature peaks. A list if  <code>n_zones &gt; 1</code>. Default is <code>None</code>.</p> <code>benthic_mode</code> <code>Union[int, None]</code> <p>Switch to configure which mode of benthic interaction to apply. Options  are <code>0</code> for bottom layer only, <code>1</code> for bottom layer and layer flanks,  <code>2</code> for sediment zones, and <code>3</code> for an undocumented use case. Default  is <code>None</code>.</p> <code>n_zones</code> <code>Union[int, None]</code> <p>Number of sediment zones to simulate. Required if <code>benthic_mode=2</code> or  <code>benthic_mode=3</code>. Default is <code>None</code>.</p> <code>zone_heights</code> <code>Union[List[float], float, None]</code> <p>Upper height of zone boundary. Required if <code>benthic_mode=2</code> or  <code>benthic_mode=3</code>. Default is <code>None</code>.</p> <code>sed_reflectivity</code> <code>Union[List[float], float, None]</code> <p>Sediment reflectivity. Default is <code>None</code>.</p> <code>sed_roughness</code> <code>Union[List[float], float, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; sediment = glm_nml.SedimentBlock(\n...     sed_heat_Ksoil=0.0,\n...     sed_temp_depth=0.1\n... )\n&gt;&gt;&gt; sediment_attrs = {\n...     \"sed_temp_depth\": 0.2,\n...     \"sed_temp_mean\": [5, 10, 20],\n...     \"sed_temp_amplitude\": [6, 8, 10],\n...     \"sed_temp_peak_doy\": [80, 70, 60],\n...     \"benthic_mode\": 1,\n...     \"n_zones\": 3,\n...     \"zone_heights\": [10.0, 20.0, 50.0],\n...     \"sed_reflectivity\": [0.1, 0.01, 0.01],\n...     \"sed_roughness\": [0.1, 0.01, 0.01]\n... }\n&gt;&gt;&gt; sediment.set_attributes(sediment_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.SedimentBlock.get_params","title":"<code>get_params(check_params=False)</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Consolidate the model parameters set during class instance  initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>glm_nml.GLMNML</code> class. </p> <p>Parameters:</p> Name Type Description Default <code>check_params</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the configuration block parameters.</p>"},{"location":"nml/#glmpy.nml.glm_nml.SedimentBlock.set_attrs","title":"<code>set_attrs(attrs_dict)</code>","text":"<p>Set attributes for an instance of a configuration block class.</p> <p>Parameters:</p> Name Type Description Default <code>attrs_dict</code> <code>dict</code> <p>A dictionary of GLM parameters to set the respective attributes in  the configuration block class instance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup = glm_nml.SetupBlock()\n&gt;&gt;&gt; glm_setup.set_attrs(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.SetupBlock","title":"<code>SetupBlock</code>","text":"<p>             Bases: <code>_BaseBlock</code></p> <p>Construct the <code>&amp;glm_setup</code> model parameters.</p> <p>The <code>&amp;glm_setup</code> parameters define the vertical series of layers that GLM  resolves when modelling a water body. <code>SetupBlock</code> provides the means to construct a dictionary containing these parameters for use in the  <code>glm_nml.GLMNML</code> class. Model parameters are set as attributes upon  initialising an instance of the class or using the <code>set_attributes()</code>  method. The <code>get_params()</code> method returns the parameter dictionary and performs optional error checking to ensure compliant parameters. </p> <p>Attributes:</p> Name Type Description <code>sim_name</code> <code>Union[str, None]</code> <p>Title of simulation. Default is <code>None</code>.</p> <code>max_layers</code> <code>Union[int, None]</code> <p>Maximum number of layers. Default is <code>None</code>.</p> <code>min_layer_vol</code> <code>Union[float, None]</code> <p>Minimum layer volume (m^3). Default is <code>None</code>.</p> <code>min_layer_thick</code> <code>Union[float, None]</code> <p>Minimum thickness of a layer (m). Default is <code>None</code>.</p> <code>max_layer_thick</code> <code>Union[float, None]</code> <p>Maximum thickness of a layer (m). Default is <code>None</code>.</p> <code>density_model</code> <code>Union[int, None]</code> <p>Switch to set the density equation. Options are <code>1</code> for TEOS-10, <code>2</code>  for UNESCO(1981), and <code>3</code> for a custom implementation. Default is  <code>None</code>.</p> <code>non_avg</code> <code>Union[bool, None]</code> <p>Switch to configure flow boundary condition temporal interpolation. Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; glm_setup = glm_nml.SetupBlock(\n...     sim_name=\"Example Simulation #1\",\n...     max_layers=250\n... )\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup.set_attributes(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.SetupBlock.get_params","title":"<code>get_params(check_params=False)</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Consolidate the model parameters set during class instance  initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>glm_nml.GLMNML</code> class. </p> <p>Parameters:</p> Name Type Description Default <code>check_params</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the configuration block parameters.</p>"},{"location":"nml/#glmpy.nml.glm_nml.SetupBlock.set_attrs","title":"<code>set_attrs(attrs_dict)</code>","text":"<p>Set attributes for an instance of a configuration block class.</p> <p>Parameters:</p> Name Type Description Default <code>attrs_dict</code> <code>dict</code> <p>A dictionary of GLM parameters to set the respective attributes in  the configuration block class instance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup = glm_nml.SetupBlock()\n&gt;&gt;&gt; glm_setup.set_attrs(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.SnowIceBlock","title":"<code>SnowIceBlock</code>","text":"<p>             Bases: <code>_BaseBlock</code></p> <p>Construct the <code>&amp;snowice</code> model parameters.</p> <p>The <code>&amp;snowice</code> parameters define the formation of snow and ice cover on the water body. <code>SetupBlock</code> provides the means to construct a dictionary  containing these parameters for use in the <code>glm_nml.GLMNML</code> class. Model  parameters are set as attributes upon initialising an instance of the  class or using the <code>set_attributes()</code> method. The <code>get_params()</code> method  returns the parameter dictionary and performs optional error checking to  ensure compliant parameters. </p> <p>Attributes:</p> Name Type Description <code>snow_albedo_factor</code> <code>Union[float, None]</code> <p>Scaling factor used to as a multiplier to scale the snow/ice albedo estimate. Default is <code>None</code>.</p> <code>snow_rho_max</code> <code>Union[float, None]</code> <p>Minimum snow density allowable (kg m^{-3}). Default is <code>None</code>.</p> <code>snow_rho_min</code> <code>Union[float, None]</code> <p>Maximum snow density allowable (kg m^{-3}). Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; snow_ice = glm_nml.SnowIceBlock(\n...     snow_albedo_factor=1.0,\n...     snow_rho_min=40\n... )\n&gt;&gt;&gt; snow_ice_attrs = {\n...     \"snow_rho_min\": 50,\n...     \"snow_rho_max\": 300\n... }\n&gt;&gt;&gt; snow_ice.set_attributes(snow_ice_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.SnowIceBlock.get_params","title":"<code>get_params(check_params=False)</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Consolidate the model parameters set during class instance  initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>glm_nml.GLMNML</code> class. </p> <p>Parameters:</p> Name Type Description Default <code>check_params</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the configuration block parameters.</p>"},{"location":"nml/#glmpy.nml.glm_nml.SnowIceBlock.set_attrs","title":"<code>set_attrs(attrs_dict)</code>","text":"<p>Set attributes for an instance of a configuration block class.</p> <p>Parameters:</p> Name Type Description Default <code>attrs_dict</code> <code>dict</code> <p>A dictionary of GLM parameters to set the respective attributes in  the configuration block class instance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup = glm_nml.SetupBlock()\n&gt;&gt;&gt; glm_setup.set_attrs(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.TimeBlock","title":"<code>TimeBlock</code>","text":"<p>             Bases: <code>_BaseBlock</code></p> <p>Construct the <code>&amp;time</code> model parameters.</p> <p>The <code>&amp;time</code> parameters define the duration and timestep of a GLM  simulation. <code>TimeBlock</code> provides the means to construct a dictionary  containing these parameters for use in the <code>glm_nml.GLMNML</code> class. Model  parameters are set as attributes upon initialising an instance of the class  or using the <code>set_attributes()</code> method. The <code>get_params()</code> method returns  the parameter dictionary and performs optional error checking to ensure  compliant parameters. </p> <p>Attributes:</p> Name Type Description <code>timefmt</code> <code>Union[int, None]</code> <p>Time configuration switch. Options are <code>2</code> when using <code>start</code> and  <code>stop</code> parameters or <code>3</code> when using <code>num_days</code>. Default is <code>None</code>.</p> <code>start</code> <code>Union[str, None]</code> <p>Start time/date of simulation in format 'yyyy-mm-dd hhss'. Default is <code>None</code>.</p> <code>stop</code> <code>Union[str, None]</code> <p>End time/date of simulation in format 'yyyy-mm-dd hhss'. Used when <code>timefmt=2</code>. Default is <code>None</code>.</p> <code>dt</code> <code>Union[float, None]</code> <p>Time step (seconds). Default is <code>None</code></p> <code>num_days</code> <code>Union[int, None]</code> <p>Number of days to simulate. Used when <code>timefmt=3</code>. Default is <code>None</code>.</p> <code>timezone</code> <code>Union[float, None]</code> <p>UTC time zone. Default is <code>None</code>.  </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; time = glm_nml.TimeBlock(\n...     timefmt=3,\n...     start=\"1998-01-01 00:00:00\"\n... )\n&gt;&gt;&gt; time_attrs = {\n...     \"start\": \"1997-01-01 00:00:00\",\n...     \"stop\": \"1999-01-01 00:00:00\",\n...     \"dt\": 3600.0,\n...     \"num_days\": 730,\n...     \"timezone\": 7.0\n... }\n&gt;&gt;&gt; time.set_attributes(time_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.TimeBlock.get_params","title":"<code>get_params(check_params=False)</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Consolidate the model parameters set during class instance  initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>glm_nml.GLMNML</code> class. </p> <p>Parameters:</p> Name Type Description Default <code>check_params</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the configuration block parameters.</p>"},{"location":"nml/#glmpy.nml.glm_nml.TimeBlock.set_attrs","title":"<code>set_attrs(attrs_dict)</code>","text":"<p>Set attributes for an instance of a configuration block class.</p> <p>Parameters:</p> Name Type Description Default <code>attrs_dict</code> <code>dict</code> <p>A dictionary of GLM parameters to set the respective attributes in  the configuration block class instance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup = glm_nml.SetupBlock()\n&gt;&gt;&gt; glm_setup.set_attrs(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.WQSetupBlock","title":"<code>WQSetupBlock</code>","text":"<p>             Bases: <code>_BaseBlock</code></p> <p>Construct the <code>&amp;wq_setup</code> model parameters.</p> <p>The <code>&amp;wq_setup</code> parameters define the coupling of GLM with water quality  and biogeochemical model libraries, e.g., AED2. <code>WQSetupBlock</code> provides the  means to construct a dictionary containing these parameters for use in the  <code>glm_nml.GLMNML</code> class. Model parameters are set as attributes upon  initialising an instance of the class or using the <code>set_attributes()</code>  method. The <code>get_params()</code> method returns the parameter dictionary and performs optional error checking to ensure compliant parameters. </p> <p>wq_lib : Union[str, None]     Water quality model selection. Options are <code>\"aed2\"</code> and <code>\"fabm\"</code>.      Default is <code>None</code>. wq_nml_file : Union[str, None]     Filename of water quality configuration file, e.g., <code>\"./aed2.nml\"</code>.      Default is <code>None</code>. bioshade_feedback : Union[bool, None]     Switch to enable K_{w} to be updated by the WQ model. Default is      <code>None</code>. mobility_off : Union[bool, None]     Switch to enable settling within the WQ model. Default is <code>None</code>. ode_method : Union[int, None]     Method to use for ODE solution of water quality module. Default is     <code>None</code>. split_factor : Union[float, None]     Factor weighting implicit vs explicit numerical solution of the WQ     model. <code>split_factor</code> has a valid range between <code>0.0</code> and <code>1.0</code>.      Default is <code>None</code>. repair_state : Union[bool, None]     Switch to correct negative or out of range WQ variables. Default is     <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; wq_setup = glm_nml.WQSetupBlock(\n...     wq_lib=\"aed2\",\n...     wq_nml_file = \"aed2/aed2.nml\"\n... )\n&gt;&gt;&gt; wq_setup_attrs = {\n...     \"wq_nml_file\": \"aed2/aed2.nml\",\n...     \"ode_method\": 1,\n...     \"split_factor\": 1,\n...     \"bioshade_feedback\": True,\n...     \"repair_state\": True,\n...     \"mobility_off\": False\n... }\n&gt;&gt;&gt; wq_setup.set_attributes(wq_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.glm_nml.WQSetupBlock.get_params","title":"<code>get_params(check_params=False)</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Consolidate the model parameters set during class instance  initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>glm_nml.GLMNML</code> class. </p> <p>Parameters:</p> Name Type Description Default <code>check_params</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the configuration block parameters.</p>"},{"location":"nml/#glmpy.nml.glm_nml.WQSetupBlock.set_attrs","title":"<code>set_attrs(attrs_dict)</code>","text":"<p>Set attributes for an instance of a configuration block class.</p> <p>Parameters:</p> Name Type Description Default <code>attrs_dict</code> <code>dict</code> <p>A dictionary of GLM parameters to set the respective attributes in  the configuration block class instance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import glm_nml\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup = glm_nml.SetupBlock()\n&gt;&gt;&gt; glm_setup.set_attrs(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.nml","title":"<code>nml</code>","text":""},{"location":"nml/#glmpy.nml.nml.NMLReader","title":"<code>NMLReader</code>","text":"<p>             Bases: <code>_NML</code></p> <p>Read NML files.</p> <p>Read a NML file and return a dictionary of parameters that have been  converted to Python data types. By default, <code>NMLReader</code> can parse  parameters from the standard GLM NML configuration blocks. This  functionality can expanded to read other non-standard blocks, or overwrite  exisiting parameter conversion methods, using the <code>converters</code>  argument. The converted NML dictionary can be returned in its entirety with  <code>get_nml()</code>, or by block with <code>get_block()</code>, or saved directly to a JSON  file with <code>write_json()</code>. </p> <p>Unexpected behaviour will occur if:</p> <ul> <li> <p>Exclamation marks (<code>!</code>) are used within a string parameter, e.g.,  <code>sim_name = 'A very important sim!'</code>. Exclamation marks are used to declare comments in NML files.</p> </li> <li> <p>You terminate a comma-separated list with a comma, e.g.,  <code>A = 100, 3600, 5600,</code>. Remove the final comma: <code>A = 100, 3600, 5600</code>.</p> </li> </ul> <p><code>NMLReader</code> provides the following static methods to convert from NML syntax to Python syntax:</p> <ul> <li> <p><code>read_nml_int</code>: NML integer to Python integer.</p> </li> <li> <p><code>read_nml_float</code>: NML float to Python float.</p> </li> <li> <p><code>read_nml_bool</code>: NML boolean to Python boolean.</p> </li> <li> <p><code>read_nml_str</code>: NML string to Python string.</p> </li> <li> <p><code>read_nml_list</code>: NML list (comma-separated values) to Python list.</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>nml_file</code> <code>Union[str, PathLike]</code> <p>Path to the NML file.</p> required <p>Attributes:</p> Name Type Description <code>nml_str</code> <code>str</code> <p>The NML file as a string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import nml\n</code></pre> <p>Fetch an individual block of parameters with the <code>get_block()</code> method:</p> <pre><code>&gt;&gt;&gt; my_nml = nml.NMLReader(nml_file=\"glm3.nml\")\n&gt;&gt;&gt; setup = my_nml.get_block(\"glm_setup\")\n&gt;&gt;&gt; print(setup)\n{\n    \"sim_name\": \"GLM Simulation\",\n    \"max_layers\": 60,\n    \"min_layer_vol\": 0.0005,\n    \"min_layer_thick\": 0.05,\n    \"max_layer_thick\": 0.1,\n    \"non_avg\": True\n}\n&gt;&gt;&gt; glm_setup = nml.NMLGLMSetup()\n&gt;&gt;&gt; glm_setup.set_attributes(setup)\n</code></pre> <p>Expand the functionality of <code>NMLReader</code> to read in a non-standard block:</p> <pre><code>&gt;&gt;&gt; debugging_types = {\n...     \"debugging\": {\n...         \"disable_evap\": nml.NMLReader.read_nml_bool\n... }\n&gt;&gt;&gt; my_nml = nml.NMLReader(\n...     nml_file=\"glm3.nml\", converters=debugging_types\n... )\n&gt;&gt;&gt; debugging = my_nml.get_block(\"debugging\")\n&gt;&gt;&gt; print(debugging)\n{\n    \"disable_evap\": False\n}\n</code></pre> <p>Convert the NML file directly to a JSON file with <code>write_json()</code>:</p> <pre><code>&gt;&gt;&gt; my_nml = nml.NMLReader(nml_file=\"glm3.nml\")\n&gt;&gt;&gt; my_nml.write_json(json_file=\"glm3.json\")\n</code></pre>"},{"location":"nml/#glmpy.nml.nml.NMLReader.get_block","title":"<code>get_block(block)</code>","text":"<p>Get a block of parameters.</p> <p>Returns a dictionary of model parameters for a specified block. Useful for setting the attributes of the corresponding <code>nml.NML*</code> class.</p> <p>Parameters block block_name: str     Name of the block to fetch the parameter dictionary for.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import nml\n&gt;&gt;&gt; my_nml = nml.NMLReader(nml_file=\"glm3.nml\")\n&gt;&gt;&gt; setup = my_nml.get_block(\"glm_setup\")\n&gt;&gt;&gt; print(setup)\n{\n    \"sim_name\": \"GLM Simulation\",\n    \"max_layers\": 60,\n    \"min_layer_vol\": 0.0005,\n    \"min_layer_thick\": 0.05,\n    \"max_layer_thick\": 0.1,\n    \"non_avg\": True\n}\n</code></pre>"},{"location":"nml/#glmpy.nml.nml.NMLReader.get_converters","title":"<code>get_converters(block=None)</code>","text":"<p>Get the current dictionary of methods for reading/writing NML  parameters.</p> <p>Returns a dictionary of the syntax conversion methods used in the  instance of <code>NMLReader</code>or <code>NMLWriter</code>.</p>"},{"location":"nml/#glmpy.nml.nml.NMLReader.get_nml","title":"<code>get_nml()</code>","text":"<p>Get all blocks of parameters.</p> <p>Returns a dictionary of all blocks and their corresponding dictionary of parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import nml\n&gt;&gt;&gt; my_nml = nml.NMLReader(nml_file=\"glm3.nml\")\n&gt;&gt;&gt; nml_dict = my_nml.get_nml()\n</code></pre>"},{"location":"nml/#glmpy.nml.nml.NMLReader.read_nml_bool","title":"<code>read_nml_bool(nml_bool)</code>  <code>staticmethod</code>","text":"<p>NML bool to Python bool.</p> <p>Converts a string containing a NML-like boolean to a Python boolean.</p> <p>Parameters:</p> Name Type Description Default <code>nml_bool</code> <code>str</code> <p>A string representing a NML boolean. Valid booleans are <code>\".true.\"</code>, <code>\".TRUE.\"</code>, <code>\".false.\"</code>, and <code>\".FALSE.\"</code>.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import nml\n&gt;&gt;&gt; my_nml_bool = \".true.\"\n&gt;&gt;&gt; python_bool = nml.NMLReader.read_nml_bool(my_nml_bool)\n&gt;&gt;&gt; print(python_bool)\nTrue\n&gt;&gt;&gt; print(type(python_bool))\n&lt;class 'bool'&gt;\n</code></pre>"},{"location":"nml/#glmpy.nml.nml.NMLReader.read_nml_float","title":"<code>read_nml_float(nml_float)</code>  <code>staticmethod</code>","text":"<p>NML float to Python float.</p> <p>Converts a string containing a NML-like float to a Python float.</p> <p>Parameters:</p> Name Type Description Default <code>nml_float</code> <code>str</code> <p>A string representing a NML float.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import nml\n&gt;&gt;&gt; my_nml_float = \"1.23\"\n&gt;&gt;&gt; python_float = nml.NMLReader.read_nml_int(my_nml_float)\n&gt;&gt;&gt; print(python_float)\n1.23\n&gt;&gt;&gt; print(type(python_float))\n&lt;class 'float'&gt;\n</code></pre>"},{"location":"nml/#glmpy.nml.nml.NMLReader.read_nml_int","title":"<code>read_nml_int(nml_int)</code>  <code>staticmethod</code>","text":"<p>NML int to Python int.</p> <p>Converts a string containing a NML-like integer to a Python integer.</p> <p>Parameters:</p> Name Type Description Default <code>nml_int</code> <code>str</code> <p>A string representing a NML integer.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import nml\n&gt;&gt;&gt; my_nml_int = \"123\"\n&gt;&gt;&gt; python_int = nml.NMLReader.read_nml_int(my_nml_int)\n&gt;&gt;&gt; print(python_int)\n123\n&gt;&gt;&gt; print(type(python_int))\n&lt;class 'int'&gt;\n</code></pre>"},{"location":"nml/#glmpy.nml.nml.NMLReader.read_nml_list","title":"<code>read_nml_list(nml_list, converter_func)</code>  <code>staticmethod</code>","text":"<p>NML list to Python list.</p> <p>Converts a NML comma-separated list to a Python list. Applies a defined syntax function to each element of the list.</p> <p>Parameters:</p> Name Type Description Default <code>nml_list</code> <code>Union[str, List[str]]</code> <p>A string of comma-separated values or a Python list of strings of comma-separated values.</p> required <code>converter_func</code> <code>Callable</code> required <code>comma</code> required <p>Examples:</p> <p>Converting a comma-separated list of strings:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import nml\n&gt;&gt;&gt; my_nml_list = \"'foo', 'bar', 'baz'\"\n&gt;&gt;&gt; python_list = nml.NMLReader.read_nml_list(\n...     my_nml_list, \n...     converter_func=nml.NMLReader.read_nml_str\n... )\n&gt;&gt;&gt; print(python_list)\n['foo', 'bar', 'baz']\n&gt;&gt;&gt; print(type(python_list))\n&lt;class 'list'&gt;\n</code></pre> <p>Converting a list of comma-separated NML booleans:</p> <pre><code>&gt;&gt;&gt; my_nml_list = [\n...     \".true., .false., .true.,\", \".false., .true., .false.\"\n... ]\n&gt;&gt;&gt; python_list = nml.NMLReader.read_nml_list(\n...     my_nml_list, \n...     converter_func=nml.NMLReader.read_nml_bool\n... )\n&gt;&gt;&gt; print(python_list)\n[True, False, True, False, True, False]\n&gt;&gt;&gt; print(type(python_list))\n&lt;class 'list'&gt;\n</code></pre>"},{"location":"nml/#glmpy.nml.nml.NMLReader.read_nml_str","title":"<code>read_nml_str(nml_str)</code>  <code>staticmethod</code>","text":"<p>NML str to Python str.</p> <p>Converts a string containing a NML-like string to a Python string.</p> <p>Parameters:</p> Name Type Description Default <code>nml_str</code> <code>str</code> <p>A string representing a NML string, i.e., characters enclosed in  <code>\"\"</code> or <code>''</code>.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import nml\n&gt;&gt;&gt; my_nml_str = \"'foo'\"\n&gt;&gt;&gt; python_str = nml.NMLReader.read_nml_str(my_nml_str)\n&gt;&gt;&gt; print(python_str)\nfoo\n&gt;&gt;&gt; print(type(python_str))\n&lt;class 'str'&gt;\n</code></pre>"},{"location":"nml/#glmpy.nml.nml.NMLReader.set_converters","title":"<code>set_converters(converters)</code>","text":"<p>Update methods for reading/writing NML parameters.</p> <p>Updates or overwrites the default methods that <code>NMLReader</code> and  <code>NMLWriter</code> use to convert parameter values from Python to NML and  vice versa.</p> <p>Parameters:</p> Name Type Description Default <code>converters</code> <code>Dict[str, Dict[str, Callable]]</code> <p>A nested dictionary where the keys are the NML block names and the values are a dictionary of parameter names (keys) and syntax  conversion methods (values, e.g., <code>NMLReader.read_nml_str</code> for use with <code>NMLReader</code> or <code>NMLWriter.write_nml_str</code> for use with  <code>NMLWriter</code>).</p> required <p>Examples:</p> <p>Use in <code>NMLWriter</code>:</p> <p>Consider an example where we have an unsupported configuration block that we wish to write to a NML file:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import nml\n&gt;&gt;&gt; nml_dict = {\n...     \"glm_setup\": {\n...         \"sim_name\": \"Sparkling Lake\",\n...         \"max_layers\": 500,\n...         \"min_layer_vol\": 0.5,\n...         \"min_layer_thick\": 0.15,\n...         \"max_layer_thick\": 0.5,\n...         \"density_model\": 1,\n...         \"non_avg\": True,\n...     },\n...     \"custom_block\": {\n...         \"custom_param\": True\n...     }\n... }\n</code></pre> <p>To write <code>custom_block</code>, we create a similarly structured dictionary where the value for <code>\"custom_param\"</code> is the appropriate  <code>NMLWriter.write_nml_*</code> static method:</p> <pre><code>&gt;&gt;&gt; converters = {\n...     \"custom_block\": {\n...         \"custom_block\": nml.NMLWriter.write_nml_bool\n...     }\n... }\n</code></pre> <p>After initialising <code>NMLWriter</code>, pass <code>converters</code> to the <code>set_converters()</code> method and write the NML file:</p> <pre><code>&gt;&gt;&gt; my_nml = nml.NMLWriter(nml_dict=nml_dict)\n&gt;&gt;&gt; my_nml.set_converters(converters)\n&gt;&gt;&gt; my_nml.write_nml(\"glm3.nml\")\n</code></pre> <p>Use in <code>NMLReader</code>:</p> <p>Consider an example where we have an unsupported configuration block that we wish to read from the following <code>glm3.nml</code> file: <pre><code>&amp;glm_setup\n   sim_name = 'GLM Simulation'\n   max_layers = 60\n   min_layer_vol = 0.0005\n   min_layer_thick = 0.05\n   max_layer_thick = 0.1\n   non_avg = .true.\n/\n&amp;custom_block\n   custom_param = .true.\n/\n</code></pre></p> <p>Define a nested dictionary where the block name is the key and the block value is a dictionary of parameter name and the appropriate  <code>NMLReader.read_nml_*</code> static method:</p> <pre><code>&gt;&gt;&gt; converters = {\n...     \"custom_block\": {\n...         \"custom_block\": nml.NMLReader.read_nml_bool\n...     }\n... }\n</code></pre> <p>After initialising <code>NMLReader</code>, pass <code>converters</code> to the <code>set_converters()</code> method and read the NML file:</p> <pre><code>&gt;&gt;&gt; my_nml = nml.NMLReader(\"glm3.nml\")\n&gt;&gt;&gt; my_nml.set_converters(converters)\n&gt;&gt;&gt; my_nml.get_nml()\n</code></pre>"},{"location":"nml/#glmpy.nml.nml.NMLReader.write_json","title":"<code>write_json(json_file)</code>","text":"<p>Write a JSON file of model parameters.</p> <p>Converts paramters in a NML file to valid JSON syntax and writes to file.</p> <p>Parameters:</p> Name Type Description Default <code>json_file</code> <code>Union[str, PathLike]</code> <p>Output path of the JSON file.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import nml\n&gt;&gt;&gt; my_nml = nml.NMLReader(nml_file=\"glm3.nml\")\n&gt;&gt;&gt; my_nml.write_json(json_file=\"glm3.json\")\n</code></pre>"},{"location":"nml/#glmpy.nml.nml.NMLWriter","title":"<code>NMLWriter</code>","text":"<p>             Bases: <code>_NML</code></p> <p>Write NML files.</p> <p>Write a NML file from a nested dictionary of block names (keys) and  parameter dictionaries (values). By default, <code>NMLWriter</code> will automatically determine the which syntax conversion methods should be used to write the  NML file. This functionality can be expicitly controlled using the  <code>set_converters</code> method.</p> <p><code>NMLWriter</code> provides the following static methods to convert from Python syntax to NML syntax:</p> <ul> <li> <p><code>write_nml_str</code>: Python string to NML string.</p> </li> <li> <p><code>write_nml_bool</code>: Python bool to NML bool.</p> </li> <li> <p><code>write_nml_list</code>: Python list to NML list (comma-separated values).</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>nml_dict</code> <code>Dict[str, Dict[str, Any]]</code> <p>A dictionary where the keys are the block names and the values are  dictionaries of parameter names (keys) and parameter values (values).</p> required <code>detect_types</code> <code>bool</code> <p>Let <code>NMLWriter</code> determine which syntax conversion methods should be  used to write the NML file. Default is <code>True</code>. If <code>False</code>, <code>NMLWriter</code> relies on an internal dictionary that stores the syntax conversion methods for each parameter. This dictionary can be updated/expanded with the <code>set_converters()</code> method.</p> <code>True</code> <code>list_len</code> <code>Union[int, None]</code> <p>The number of items in a comma-separated list to write before adding  a line break. When set to <code>None</code>, no line breaks are added. Default is  <code>None</code>.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import nml\n</code></pre> <p>Create a nested dictionary of blocks (keys) and parameters (values) to  write:</p> <pre><code>&gt;&gt;&gt; my_nml_dict = {\n...     \"glm_setup\": {\n...         \"sim_name\": \"Sparkling Lake\",\n...         \"max_layers\": 500,\n...         \"min_layer_vol\": 0.5,\n...         \"min_layer_thick\": 0.15,\n...         \"max_layer_thick\": 0.5,\n...         \"density_model\": 1,\n...         \"non_avg\": True,\n...     },\n...     \"mixing\": {\n...         \"surface_mixing\": 1,\n...         \"coef_mix_conv\": 0.2,\n...         \"coef_wind_stir\": 0.402,\n...         \"coef_mix_shear\": 0.2,\n...         \"coef_mix_turb\": 0.51,\n...         \"coef_mix_KH\": 0.3,\n...         \"deep_mixing\": 2,\n...         \"coef_mix_hyp\": 0.5,\n...         \"diff\": 0.0,\n...     }\n... }\n</code></pre> <p>Initialise <code>NMLWriter</code> and set the <code>nml_dict</code> attribute:</p> <pre><code>&gt;&gt;&gt; my_nml = nml.NMLWriter(nml_dict=my_nml_dict)\n</code></pre> <p>Write the NML to file by calling the <code>write_nml</code> method:</p> <pre><code>&gt;&gt;&gt; my_nml.write_nml(nml_file=\"glm3.nml\")\n</code></pre>"},{"location":"nml/#glmpy.nml.nml.NMLWriter.get_converters","title":"<code>get_converters(block=None)</code>","text":"<p>Get the current dictionary of methods for reading/writing NML  parameters.</p> <p>Returns a dictionary of the syntax conversion methods used in the  instance of <code>NMLReader</code>or <code>NMLWriter</code>.</p>"},{"location":"nml/#glmpy.nml.nml.NMLWriter.set_converters","title":"<code>set_converters(converters)</code>","text":"<p>Update methods for reading/writing NML parameters.</p> <p>Updates or overwrites the default methods that <code>NMLReader</code> and  <code>NMLWriter</code> use to convert parameter values from Python to NML and  vice versa.</p> <p>Parameters:</p> Name Type Description Default <code>converters</code> <code>Dict[str, Dict[str, Callable]]</code> <p>A nested dictionary where the keys are the NML block names and the values are a dictionary of parameter names (keys) and syntax  conversion methods (values, e.g., <code>NMLReader.read_nml_str</code> for use with <code>NMLReader</code> or <code>NMLWriter.write_nml_str</code> for use with  <code>NMLWriter</code>).</p> required <p>Examples:</p> <p>Use in <code>NMLWriter</code>:</p> <p>Consider an example where we have an unsupported configuration block that we wish to write to a NML file:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import nml\n&gt;&gt;&gt; nml_dict = {\n...     \"glm_setup\": {\n...         \"sim_name\": \"Sparkling Lake\",\n...         \"max_layers\": 500,\n...         \"min_layer_vol\": 0.5,\n...         \"min_layer_thick\": 0.15,\n...         \"max_layer_thick\": 0.5,\n...         \"density_model\": 1,\n...         \"non_avg\": True,\n...     },\n...     \"custom_block\": {\n...         \"custom_param\": True\n...     }\n... }\n</code></pre> <p>To write <code>custom_block</code>, we create a similarly structured dictionary where the value for <code>\"custom_param\"</code> is the appropriate  <code>NMLWriter.write_nml_*</code> static method:</p> <pre><code>&gt;&gt;&gt; converters = {\n...     \"custom_block\": {\n...         \"custom_block\": nml.NMLWriter.write_nml_bool\n...     }\n... }\n</code></pre> <p>After initialising <code>NMLWriter</code>, pass <code>converters</code> to the <code>set_converters()</code> method and write the NML file:</p> <pre><code>&gt;&gt;&gt; my_nml = nml.NMLWriter(nml_dict=nml_dict)\n&gt;&gt;&gt; my_nml.set_converters(converters)\n&gt;&gt;&gt; my_nml.write_nml(\"glm3.nml\")\n</code></pre> <p>Use in <code>NMLReader</code>:</p> <p>Consider an example where we have an unsupported configuration block that we wish to read from the following <code>glm3.nml</code> file: <pre><code>&amp;glm_setup\n   sim_name = 'GLM Simulation'\n   max_layers = 60\n   min_layer_vol = 0.0005\n   min_layer_thick = 0.05\n   max_layer_thick = 0.1\n   non_avg = .true.\n/\n&amp;custom_block\n   custom_param = .true.\n/\n</code></pre></p> <p>Define a nested dictionary where the block name is the key and the block value is a dictionary of parameter name and the appropriate  <code>NMLReader.read_nml_*</code> static method:</p> <pre><code>&gt;&gt;&gt; converters = {\n...     \"custom_block\": {\n...         \"custom_block\": nml.NMLReader.read_nml_bool\n...     }\n... }\n</code></pre> <p>After initialising <code>NMLReader</code>, pass <code>converters</code> to the <code>set_converters()</code> method and read the NML file:</p> <pre><code>&gt;&gt;&gt; my_nml = nml.NMLReader(\"glm3.nml\")\n&gt;&gt;&gt; my_nml.set_converters(converters)\n&gt;&gt;&gt; my_nml.get_nml()\n</code></pre>"},{"location":"nml/#glmpy.nml.nml.NMLWriter.write_nml","title":"<code>write_nml(nml_file='glm3.nml')</code>","text":"<p>Write the <code>.nml</code> file.</p> <p>Write the <code>.nml</code> of model parameters.</p> <p>Parameters:</p> Name Type Description Default <code>nml_file</code> <code>str</code> <p>File path to save .nml file, by default <code>glm3.nml</code>.</p> <code>'glm3.nml'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; nml_file.write_nml(nml_file=\"my_lake.nml\")\n</code></pre>"},{"location":"nml/#glmpy.nml.nml.NMLWriter.write_nml_bool","title":"<code>write_nml_bool(python_bool)</code>  <code>staticmethod</code>","text":"<p>Python boolean to NML boolean.</p> <p>Convert a Python boolean to a string representation of a NML  boolean. </p> <p>Parameters:</p> Name Type Description Default <code>python_bool</code> <code>bool</code> <p>A Python boolean</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import nml\n&gt;&gt;&gt; bool = nml.NMLWriter.write_nml_bool(True)\n&gt;&gt;&gt; print(bool)\n.true.\n</code></pre>"},{"location":"nml/#glmpy.nml.nml.NMLWriter.write_nml_list","title":"<code>write_nml_list(python_list, converter_func=None, list_len=None)</code>  <code>staticmethod</code>","text":"<p>Python list to NML comma-separated list.</p> <p>Convert a Python list to a comma-separated list. A function can be  optionally passed to the <code>converter_func</code> parameter to format the  syntax of each list item, e.g., <code>write_nml_str()</code> and  <code>write_nml_bool()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>python_list</code> <code>List[Any]</code> <p>A Python list</p> required <code>converter_func</code> <code>Union[Callable, None]</code> <p>A function used to format each list item. Default is <code>None</code>.</p> <code>None</code> <code>list_len</code> <code>Union[int, None]</code> <p>The number of list items to write before adding a line break. When set to <code>None</code>, no line breaks are added. Default is <code>None</code>.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import nml\n&gt;&gt;&gt; nml_list = nml.NMLWriter.write_nml_list([1, 2, 3])\n&gt;&gt;&gt; print(nml_list)\n1,2,3\n&gt;&gt;&gt; nml_list = nml.NMLWriter.write_nml_list(\n...     [True, False, True], \n...     converter_func=nml.NMLWriter.write_nml_bool\n... )\n&gt;&gt;&gt; print(nml_list)\n.true.,.false.,.true.\n&gt;&gt;&gt; nml_list = nml.NMLWriter.write_nml_list(\n...     [1, 2, 3, 4, 5, 6, 7, 8 ,9],\n...     None,\n...     3\n... )\n&gt;&gt;&gt; print(nml_list)\n1,2,3,\n4,5,6,\n7,8,9\n</code></pre>"},{"location":"nml/#glmpy.nml.nml.NMLWriter.write_nml_param","title":"<code>write_nml_param(param_name, param_value, converter_func=None)</code>  <code>staticmethod</code>","text":"<p>GLM parameter/value string.</p> <p>Construct a string containing a GLM parameter and value with the  correct<code>.nml</code> syntax formatting.</p> <p>Parameters:</p> Name Type Description Default <code>param_dict</code> <p>A dictionary containing GLM parameters (keys) and values, e.g., from the <code>__call__()</code> method of a <code>nml.NMLGLMSetup</code> instance.</p> required <code>param</code> <p>The dictionary key, i.e., GLM parameter, to construct the string for.</p> required <code>converter_func</code> <code>Union[Callable, None]</code> <p>A function used to format the syntax of the value. Default is  <code>None</code>.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import nml\n&gt;&gt;&gt; param_name = \"non_avg\"\n&gt;&gt;&gt; param_value = True\n&gt;&gt;&gt; nml_param = nml.NMLWriter.write_nml_param(\n...     param_name=param_name,\n...     param_value=param_value,\n...     converter_func=nml.NMLWriter.write_nml_bool\n... )\n&gt;&gt;&gt; print(formatted_param)\n   non_avg = .true.\n</code></pre>"},{"location":"nml/#glmpy.nml.nml.NMLWriter.write_nml_str","title":"<code>write_nml_str(python_str)</code>  <code>staticmethod</code>","text":"<p>Python string to NML string.</p> <p>Convert a Python string to a Fortran string by adding inverted commas.</p> <p>Parameters:</p> Name Type Description Default <code>python_str</code> <code>str</code> <p>A Python string</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.nml import nml\n&gt;&gt;&gt; string = nml.NMLWriter.write_nml_str(\"GLM\")\n&gt;&gt;&gt; print(string)\n'GLM'\n</code></pre>"},{"location":"outflows/","title":"Outflows","text":""},{"location":"outflows/#glmpy.outflows.CustomOutflows","title":"<code>CustomOutflows</code>","text":"<p>Create a simple outflow timeseries for GLM.</p> <p>Generates an outflow timeseries in m^3/second between a given start and end datetime. The timeseries can be updated in two ways: 1. Providing a dictionary with specific datetimes and their  corresponding outflows. 2. Specifying a fixed outflow value between two datetimes. The outflow timeseries can be returned as a pandas DataFrame or exported to  a CSV file.</p> <p>Attributes:</p> Name Type Description <code>start_datetime</code> <code>Union[str, Timestamp, datetime]</code> <p>The start datetime of the outflow timeseries. Must be of type  Timestamp, datetime, or a valid datetime string.</p> <code>end_datetime</code> <code>Union[str, Timestamp, datetime]</code> <p>The end datetime of the outflow timeseries. Must be of type  Timestamp, datetime, or a valid datetime string.</p> <code>frequency</code> <code>str</code> <p>Frequency of the outflow timeseries. Must be either '24h' (daily) or '1h' (hourly). Default is '24h'.</p> <code>base_outflow</code> <code>Union[int, float]</code> <p>Base flow of the outflow timeseries in m^3/day or m^3/hour depending  on <code>frequency</code>. Default is 0.0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import outflows\n</code></pre> <p>Initialise a daily outflow timeseries with a base outflow of 0.0 m^3/day:</p> <pre><code>&gt;&gt;&gt; outflows = outflows.CustomOutflows(\n...     start_datetime=\"2020-01-01\",\n...     end_datetime=\"2020-01-10\",\n...     frequency=\"24h\",\n...     base_outflow=0.0\n... )\nUpdate the timeseries with a dictionary of specific dates and their\ncorresponding outflows in m^3/day:\n&gt;&gt;&gt; outflows_dict = {\n...     \"2020-01-02\": 2, # 2m^3/day\n...     \"2020-01-03\": 4, # 4m^3/day\n...     \"2020-01-04\": 6 # 6m^3/day\n... }\n&gt;&gt;&gt; outflows.set_on_datetime(outflows_dict)\n</code></pre> <p>Return and print the outflows timeseries as a pandas DataFrame. Note, the outflow units have been converted to m^3/second as expected by GLM:</p> <pre><code>&gt;&gt;&gt; print(outflows.get_outflows())\n        time      flow\n0 2020-01-01  0.000000\n1 2020-01-02  0.000023\n2 2020-01-03  0.000046\n3 2020-01-04  0.000069\n4 2020-01-05  0.000000\n5 2020-01-06  0.000000\n6 2020-01-07  0.000000\n7 2020-01-08  0.000000\n8 2020-01-09  0.000000\n9 2020-01-10  0.000000\n</code></pre> <p>Update the timeseries with a fixed outflow between two dates:</p> <pre><code>&gt;&gt;&gt; outflows.set_over_datetime(\n...     from_datetime=\"2020-01-05\",\n...     to_datetime = \"2020-01-09\",\n...     outflow = 5 # 5m^3/day\n... )\n</code></pre> <p>Return and print the outflows timeseries as a pandas DataFrame:</p> <pre><code>&gt;&gt;&gt; print(outflows.get_outflows())\n        time      flow\n0 2020-01-01  0.000000\n1 2020-01-02  0.000023\n2 2020-01-03  0.000046\n3 2020-01-04  0.000069\n4 2020-01-05  0.000058\n5 2020-01-06  0.000058\n6 2020-01-07  0.000058\n7 2020-01-08  0.000058\n8 2020-01-09  0.000058\n9 2020-01-10  0.000000\n</code></pre> <p>Write the outflows to a CSV without the index:</p> <pre><code>&gt;&gt;&gt; outflows.write_outflows(file_path=\"outflows.csv\")\n</code></pre>"},{"location":"outflows/#glmpy.outflows.CustomOutflows.get_outflows","title":"<code>get_outflows()</code>","text":"<p>Get the outflow timeseries.</p> <p>Returns the outflow timeseries as a pandas DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import outflows\n&gt;&gt;&gt; outflows = outflows.CustomOutflows(\n...     start_datetime=\"2020-01-01\",\n...     end_datetime=\"2020-01-10\",\n...     frequency=\"24h\",\n...     base_outflow=0.0\n... )\n&gt;&gt;&gt; outflows.get_outflows()\n</code></pre>"},{"location":"outflows/#glmpy.outflows.CustomOutflows.set_on_datetime","title":"<code>set_on_datetime(datetime_outflows)</code>","text":"<p>Set the outflow volume for specific datetimes.</p> <p>The outflow volume for specific datetimes can be set by providing a dictionary with datetimes as keys and outflow volumes as values. Outflow volumes will be treated as having the same units as the base  outflow (m^3/day or m^3/hour depending on <code>frequency</code>).</p> <p>Parameters:</p> Name Type Description Default <code>datetime_outflows</code> <code>Dict[Union[str, pd.Timestamp, dt.datetime], </code> required <code>Union</code> <p>Dictionary with valid datetimes as keys and outflow volumes as  values.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import outflows\n&gt;&gt;&gt; outflows = outflows.CustomOutflows(\n...     start_datetime=\"2020-01-01 00:00:00\",\n...     end_datetime=\"2020-01-01 10:00:00\",\n...     frequency=\"1h\",\n...     base_outflow=0.0\n... )\n&gt;&gt;&gt; outflows_dict = {\n...     \"2020-01-01 01:00:00\": 10,\n...     \"2020-01-01 03:00:00\": 12,\n...     \"2020-01-01 05:00:00\": 14\n... }\n&gt;&gt;&gt; outflows.set_on_datetime(outflows_dict)\n&gt;&gt;&gt; print(outflows.get_outflows())\n                  time      flow\n0  2020-01-01 00:00:00  0.000000\n1  2020-01-01 01:00:00  0.002778\n2  2020-01-01 02:00:00  0.000000\n3  2020-01-01 03:00:00  0.003333\n4  2020-01-01 04:00:00  0.000000\n5  2020-01-01 05:00:00  0.003889\n6  2020-01-01 06:00:00  0.000000\n7  2020-01-01 07:00:00  0.000000\n8  2020-01-01 08:00:00  0.000000\n9  2020-01-01 09:00:00  0.000000\n10 2020-01-01 10:00:00  0.000000\n</code></pre>"},{"location":"outflows/#glmpy.outflows.CustomOutflows.set_over_datetime","title":"<code>set_over_datetime(from_datetime, to_datetime, outflow)</code>","text":"<p>Set the outflow volume between two datetimes.</p> <p>Outflow volumes between two datetimes can be set by providing a start datetime, end datetime, and an outflow volume. Outflows are updated on the start and end datetime.</p> <p>Parameters:</p> Name Type Description Default <code>from_datetime</code> <code>Union[str, Timestamp, datetime]</code> <p>The datetime to update the outflow timeseries from.</p> required <code>to_datetime</code> <code>Union[str, Timestamp, datetime]</code> <p>The datetime to update the outflow timeseries to.</p> required <code>outflow</code> <code>Union[float, int]</code> <p>The outflow volume to set between the <code>from_datetime</code> and <code>to_datetime</code> in m^3/day or m^3/hour (depending on <code>frequency</code>).</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import outflows\n&gt;&gt;&gt; outflows = outflows.CustomOutflows(\n...     start_datetime=\"2020-01-01 00:00:00\",\n...     end_datetime=\"2020-01-01 10:00:00\",\n...     frequency=\"1h\",\n...     base_outflow=0.0\n... )\n&gt;&gt;&gt; outflows.set_over_datetime(\n...     from_datetime=\"2020-01-01 01:00:00\",\n...     to_datetime = \"2020-01-01 09:00:00\",\n...     outflow = 5\n... )\n&gt;&gt;&gt; print(outflows.get_outflows())\n                  time      flow\n0  2020-01-01 00:00:00  0.000000\n1  2020-01-01 01:00:00  0.001389\n2  2020-01-01 02:00:00  0.001389\n3  2020-01-01 03:00:00  0.001389\n4  2020-01-01 04:00:00  0.001389\n5  2020-01-01 05:00:00  0.001389\n6  2020-01-01 06:00:00  0.001389\n7  2020-01-01 07:00:00  0.001389\n8  2020-01-01 08:00:00  0.001389\n9  2020-01-01 09:00:00  0.001389\n10 2020-01-01 10:00:00  0.000000\n</code></pre>"},{"location":"outflows/#glmpy.outflows.CustomOutflows.write_outflows","title":"<code>write_outflows(file_path)</code>","text":"<p>Write the outflow timeseries to a CSV file.</p> <p>The outflow timeseries can be written to a CSV file by providing a path to the CSV file. The index of the DataFrame is not included in the  CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the CSV file to which the outflow timeseries will be written.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import outflows\n&gt;&gt;&gt; outflows = outflows.CustomOutflows(\n...     start_datetime=\"2020-01-01\",\n...     end_datetime=\"2020-01-10\",\n...     frequency=\"24h\",\n...     base_outflow=10\n... )\n&gt;&gt;&gt; outflows.write_outflows(file_path=\"outflows.csv\")\n</code></pre>"},{"location":"plots/","title":"Plots","text":""},{"location":"plots/#glmpy.plots.LakePlotter","title":"<code>LakePlotter</code>","text":"<p>Common plots for the <code>lake.csv</code> output.</p> <p>Creates time series plots of lake characteristics (e.g., volume, temperature, heat fluxes, etc.) on provided matplotlib <code>Axes</code> objects. Reads daily lake measurement data from the <code>lake.csv</code> file generated by running a GLM simulation.</p> <p>Examples:</p> <p>Plot the lake volume (m^3):</p> <pre><code>&gt;&gt;&gt; from glmpy import plots\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; lake = plots.LakePlotter(\"lake.csv\")\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; lake.lake_volume(ax)\n&gt;&gt;&gt; plt.show()\n</code></pre> <p>Change the line colour by providing a dictionary of matplotlib <code>plot</code> parameters:</p> <pre><code>&gt;&gt;&gt; lake = plots.LakePlotter(\"lake.csv\")\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; lake.lake_volume(ax, {\"color\": \"red\"})\n&gt;&gt;&gt; plt.show()\n</code></pre>"},{"location":"plots/#glmpy.plots.LakePlotter.__init__","title":"<code>__init__(lake_csv_path)</code>","text":"<p>Initialise the LakePlotter with the <code>lake.csv</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>lake_csv_path</code> <code>str</code> <p>Path to the <code>lake.csv</code> file generated by GLM</p> required"},{"location":"plots/#glmpy.plots.LakePlotter.heat_balance_components","title":"<code>heat_balance_components(ax, daily_qsw_params={}, daily_qe_params={}, daily_qh_params={}, daily_qlw_params={})</code>","text":"<p>Lake heat fluxes.</p> <p>Daily line plot of four heat balance components (W/m^2):     - Mean shortwave radiation     - Mean latent heat     - Mean sensible heat     - Mean longwave radiation</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <p>The matplotlib Axes that the data will be plotted on.</p> required <code>daily_qsw_params</code> <code>Union[dict, None]</code> <p>Plotting parameters for <code>Daily Qsw</code>. If <code>None</code>, nothing will be plotted. Default is {}.</p> <code>{}</code> <code>daily_qe_params</code> <code>Union[dict, None]</code> <p>Plotting parameters for <code>Daily Qe</code>. If <code>None</code>, nothing will be plotted. Default is {}.</p> <code>{}</code> <code>daily_qh_params</code> <code>Union[dict, None]</code> <p>Plotting parameters for <code>Daily Qh</code>. If <code>None</code>, nothing will be plotted. Default is {}.</p> <code>{}</code> <code>daily_qlw_params</code> <code>Union[dict, None]</code> <p>Plotting parameters for <code>Daily Qlw</code>. If <code>None</code>, nothing will be plotted. Default is {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list of Line2D</code> <p>A list of lines representing the plotted data.</p>"},{"location":"plots/#glmpy.plots.LakePlotter.lake_level","title":"<code>lake_level(ax, param_dict={})</code>","text":"<p>Lake surface height.</p> <p>Line plot of the lake level (m).</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The matplotlib Axes that the data will be plotted on.</p> required <code>param_dict</code> <code>dict</code> <p>Plotting parameters that will be passed to <code>matplotlib.axes.Axes.plot</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list of Line2D</code> <p>A list of lines representing the plotted data.</p>"},{"location":"plots/#glmpy.plots.LakePlotter.lake_surface_area","title":"<code>lake_surface_area(ax, param_dict={})</code>","text":"<p>Lake surface area.</p> <p>Line plot of the lake surface area (m^2).</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The matplotlib Axes that the data will be plotted on.</p> required <code>param_dict</code> <code>dict</code> <p>Plotting parameters that will be passed to <code>matplotlib.axes.Axes.plot</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list of Line2D</code> <p>A list of lines representing the plotted data.</p>"},{"location":"plots/#glmpy.plots.LakePlotter.lake_temp","title":"<code>lake_temp(ax, min_temp_params={}, max_temp_params={})</code>","text":"<p>Min./max. temperature within lake.</p> <p>Line plot of the minimum and maximum temperature (celsius) within the lake.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The matplotlib Axes that the data will be plotted on.</p> required <code>min_temp_params</code> <code>Union[dict, None]</code> <p>Plotting parameters for <code>Min Temp</code>. If <code>None</code>, nothing will be plotted. Default is {}.</p> <code>{}</code> <code>max_temp_params</code> <code>Union[dict, None]</code> <p>Plotting parameters for <code>Max Temp</code>. If <code>None</code>, nothing will be plotted. Default is {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list of Line2D</code> <p>A list of lines representing the plotted data.</p>"},{"location":"plots/#glmpy.plots.LakePlotter.lake_volume","title":"<code>lake_volume(ax, param_dict={})</code>","text":"<p>Lake volume.</p> <p>Line plot of the lake volume (m^3).</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The matplotlib Axes that the data will be plotted on.</p> required <code>param_dict</code> <code>dict</code> <p>Plotting parameters that will be passed to <code>matplotlib.axes.Axes.plot</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list of Line2D</code> <p>A list of lines representing the plotted data.</p>"},{"location":"plots/#glmpy.plots.LakePlotter.surface_temp","title":"<code>surface_temp(ax, param_dict={})</code>","text":"<p>Lake surface temperature.</p> <p>Line plot of the lake surface temperature (celsius).</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The matplotlib Axes that the data will be plotted on.</p> required <code>param_dict</code> <code>dict</code> <p>Plotting parameters that will be passed to <code>matplotlib.axes.Axes.plot</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list of Line2D</code> <p>A list of lines representing the plotted data.</p>"},{"location":"plots/#glmpy.plots.LakePlotter.water_balance","title":"<code>water_balance(ax, param_dict={})</code>","text":"<p>Lake water balance.</p> <p>Line plot of the net water balance (m^3/day). Calculated by: <code>Rain + Snowfall + Local Runoff + Tot Inflow Vol + Evaporation - Tot Outflow Vol</code>.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The matplotlib Axes that the data will be plotted on.</p> required <code>param_dict</code> <code>dict</code> <p>Plotting parameters that will be passed to <code>matplotlib.axes.Axes.plot</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list of Line2D</code> <p>A list of lines representing the plotted data.</p>"},{"location":"plots/#glmpy.plots.LakePlotter.water_balance_components","title":"<code>water_balance_components(ax, tot_inflow_vol_params={}, tot_outflow_vol_params={}, overflow_vol_params={}, evaporation_params={}, rain_params={}, local_runoff_params={}, snowfall_params={})</code>","text":"<p>Lake water balance components.</p> <p>Daily line plot of the water balance components (m^3/day):     - Total inflow     - Total outflow     - Overflow     - Evaporation     - Rain     - Local runoff     - Snowfall</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The matplotlib Axes that the data will be plotted on.</p> required <code>tot_inflow_vol_params</code> <code>Union[dict, None]</code> <p>Plotting parameters for <code>Tot Inflow Vol</code>. If <code>None</code>, nothing will be plotted. Default is {}.</p> <code>{}</code> <code>tot_outflow_vol_params</code> <code>Union[dict, None]</code> <p>Plotting parameters for <code>Tot Outflow Vol</code>. If <code>None</code>, nothing will be plotted. Default is {}.</p> <code>{}</code> <code>overflow_vol_params</code> <code>Union[dict, None]</code> <p>Plotting parameters for <code>Overflow Vol</code>. If <code>None</code>, nothing will be plotted. Default is {}.</p> <code>{}</code> <code>evaporation_params</code> <code>Union[dict, None]</code> <p>Plotting parameters for <code>Evaporation</code>. If <code>None</code>, nothing will be plotted. Default is {}.</p> <code>{}</code> <code>rain_params</code> <code>Union[dict, None]</code> <p>Plotting parameters for <code>Rain</code>. If <code>None</code>, nothing will be plotted. Default is {}.</p> <code>{}</code> <code>local_runoff_params</code> <code>Union[dict, None]</code> <p>Plotting parameters for <code>Local Runoff</code>. If <code>None</code>, nothing will be plotted. Default is {}.</p> <code>{}</code> <code>snowfall_params</code> <code>Union[dict, None]</code> <p>Plotting parameters for <code>Snowfall</code>. If <code>None</code>, nothing will be plotted. Default is {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list of Line2D</code> <p>A list of lines representing the plotted data.</p>"},{"location":"plots/#glmpy.plots.NCProfile","title":"<code>NCProfile</code>","text":"<p>Profile timeseries plots for the <code>output.nc</code> file.</p> <p>Creates a profile plot of a variable for all depths and timesteps of a GLM simulation. Reads the <code>output.nc</code> NetCDF file generated by GLM.</p> <p>Examples:</p> <p>Plot the lake temperature and add a colour bar:</p> <pre><code>&gt;&gt;&gt; from glmpy import plots\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; nc = plots.NCProfile(\"output.nc\")\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; out = nc.plot_var(ax, \"temp\")\n&gt;&gt;&gt; col_bar = fig.colorbar(out)\n&gt;&gt;&gt; col_bar.set_label(\"Temperature (\u00b0C)\")\n&gt;&gt;&gt; plt.show()\n</code></pre> <p>Plot the lake temperature with surface reference (instead of bottom reference) and change the colour map:</p> <pre><code>&gt;&gt;&gt; nc = plots.NCProfile(\"plots_module_misc/example_outputs/output.nc\")\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; out = nc.plot_var(ax, \"temp\", \"surface\", {\"cmap\": \"viridis\"})\n&gt;&gt;&gt; col_bar = fig.colorbar(out)\n&gt;&gt;&gt; col_bar.set_label(\"Temperature (\u00b0C)\")\n&gt;&gt;&gt; plt.show()\n</code></pre> <p>Use <code>get_vars()</code> to return every valid variable name. Set the colour bar label with <code>get_long_name()</code> (the unabbreviated variable name) and <code>get_units()</code>:</p> <pre><code>&gt;&gt;&gt; var = nc.get_vars()[3]\n&gt;&gt;&gt; long_name = nc.get_long_name(var)\n&gt;&gt;&gt; units = nc.get_units(var)\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; out = nc.plot_var(ax, var)\n&gt;&gt;&gt; col_bar = fig.colorbar(out)\n&gt;&gt;&gt; col_bar.set_label(f\"{long_name} ({units})\")\n&gt;&gt;&gt; plt.show()\n</code></pre>"},{"location":"plots/#glmpy.plots.NCProfile.__init__","title":"<code>__init__(glm_nc_path, resolution=0.1, remove_ice=False, remove_white_ice=False, remove_snow=False)</code>","text":"<p>Initialise the NCProfile with the <code>output.nc</code> NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>glm_nc_path</code> <code>str</code> <p>Path to the GLM <code>output.nc</code> NetCDF file.</p> required <code>resolution</code> <code>float</code> <p>Vertical resolution of plots in meters. Default is 0.1.</p> <code>0.1</code> <code>remove_ice</code> <code>bool</code> <p>Exclude black ice thickness from surface height. Default is False.</p> <code>False</code> <code>remove_white_ice</code> <code>bool</code> <p>Exclude white ice thickness from surface height. Default is False.</p> <code>False</code> <code>remove_snow</code> <code>bool</code> <p>Exclude snow thickness from surface height. Default is False.</p> <code>False</code>"},{"location":"plots/#glmpy.plots.NCProfile.get_long_name","title":"<code>get_long_name(var)</code>","text":"<p>Get the long name description of a variable.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>Name of the variable.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Long name description of the variable.</p>"},{"location":"plots/#glmpy.plots.NCProfile.get_start_datetime","title":"<code>get_start_datetime()</code>","text":"<p>Get the simulation start time.</p> <p>Returns:</p> Type Description <code>datetime</code> <p>Start time of the GLM simulation.</p>"},{"location":"plots/#glmpy.plots.NCProfile.get_units","title":"<code>get_units(var)</code>","text":"<p>Get the units of a variable.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>Name of the variable.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Units of the variable.</p>"},{"location":"plots/#glmpy.plots.NCProfile.get_vars","title":"<code>get_vars()</code>","text":"<p>Get all available variables that can be plotted with <code>plot_var()</code>.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of plottable variables in the NetCDF file</p>"},{"location":"plots/#glmpy.plots.NCProfile.plot_var","title":"<code>plot_var(ax, var, reference='bottom', param_dict={})</code>","text":"<p>Plot the profile timeseries of a variable on a matplotlib Axes.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The Axes to plot on.</p> required <code>var</code> <code>str</code> <p>Name of the variable to plot. To list valid variables, see the <code>get_vars()</code> method.</p> required <code>reference</code> <code>str</code> <p>Reference frame for depth, either \"bottom\" or \"surface\". Default is \"bottom\".</p> <code>'bottom'</code> <code>param_dict</code> <code>dict</code> <p>Parameters passed to matplotlib.axes.Axes.imshow. Default is {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>AxesImage</code> <p>The plotted image</p>"},{"location":"simulation/","title":"Simulation","text":""},{"location":"simulation/#glmpy.simulation.GLMPostProcessor","title":"<code>GLMPostProcessor</code>","text":"<p>Class to process outputs of GLM simulation.</p> <p>Attributes:</p> Name Type Description <code>outputs_path</code> <code>str</code> <p>Path to directory where GLM outputs have been written.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; import shutil\n</code></pre> <pre><code>&gt;&gt;&gt; from glmpy import simulation as sim\n</code></pre> <pre><code>&gt;&gt;&gt; files = {\n&gt;&gt;&gt;    \"glm3.nml\": os.path.join(os.getcwd(), \"glm3.nml\"),\n&gt;&gt;&gt;    \"met.csv\": os.path.join(os.getcwd(), \"met.csv\"),\n&gt;&gt;&gt; }\n</code></pre> <pre><code>&gt;&gt;&gt; # running local instance of GLM\n&gt;&gt;&gt; glm_run = sim.GLMSim(files, False, \"/inputs\")\n&gt;&gt;&gt; inputs_dir = glm_run.prepare_inputs()\n</code></pre> <pre><code>&gt;&gt;&gt; glm_run.glm_run(inputs_dir, \"/glm/glm\")\n</code></pre> <pre><code>&gt;&gt;&gt; outputs_dir = os.path.join(inputs_dir, \"output\")\n</code></pre> <pre><code>&gt;&gt;&gt; # initialise GLMPostProcessor object\n&gt;&gt;&gt; glm_process = sim.GLMPostProcessor(outputs_dir)\n</code></pre> <pre><code>&gt;&gt;&gt; # create zipfile of GLM outputs\n&gt;&gt;&gt; # csv file and netcdf\n&gt;&gt;&gt; # returns path to zipfile of outputs\n&gt;&gt;&gt; files_zip_path = glm_process.zip_outputs()\n</code></pre> <pre><code>&gt;&gt;&gt; # create zipfile of csv GLM outputs\n&gt;&gt;&gt; files_zip_csv_path = glm_process.zip_csvs()\n</code></pre> <pre><code>&gt;&gt;&gt; # create zipfile of JSON GLM outputs\n&gt;&gt;&gt; files_zip_json_path = glm_process.zip_json()\n</code></pre>"},{"location":"simulation/#glmpy.simulation.GLMPostProcessor.csv_to_json","title":"<code>csv_to_json(csv_lake_fname, variables)</code>","text":"<p>Converts outputs of GLM simulation in csv format to JSON.</p> <p>Can be used as a step before saving GLM results to JSON files or to generate JSON formatted data that can be returned to clients for rendering in web browers; for example, if GLM is being used as part of a web application.</p> <p>Parameters:</p> Name Type Description Default <code>csv_lake_fname</code> <code>str</code> <p>File name of csv of outputs from GLM - <code>lake.csv</code>.</p> required <code>variables</code> <code>list</code> <p>List of variable names from <code>lake.csv</code> to select and convert to JSON format..</p> required <p>Returns:</p> Type Description <code>dict     JSON formatted results of GLM simulation.</code>"},{"location":"simulation/#glmpy.simulation.GLMPostProcessor.csv_to_json_files","title":"<code>csv_to_json_files()</code>","text":"<p>Convert csv of GLM outputs to JSON format and writes to a <code>.json</code> file.</p>"},{"location":"simulation/#glmpy.simulation.GLMPostProcessor.zip_csvs","title":"<code>zip_csvs()</code>","text":"<p>Creates a zipfile of csv GLM outputs (csv outputs only).</p> <p>Use this if you do not need a netcdf file of GLM outputs.</p> <p>Returns:</p> Type Description <code>str     Path to zipfile of GLM outputs.</code>"},{"location":"simulation/#glmpy.simulation.GLMPostProcessor.zip_json","title":"<code>zip_json()</code>","text":"<p>Creates a zipfile of csv GLM outputs converted to JSON format.</p> <p>Use this, for example, if you are using GLM within a web application and outputs from GLM simulations are being passed between clients and servers. Saving outputs of GLM simulations to JSON format is useful if you want to render results in a web browser, for example.</p> <p>Returns:</p> Type Description <code>str     Path to zipfile of GLM outputs.</code>"},{"location":"simulation/#glmpy.simulation.GLMPostProcessor.zip_outputs","title":"<code>zip_outputs()</code>","text":"<p>Creates a zipfile of GLM outputs (csv and netcdf outputs).</p> <p>Returns:</p> Type Description <code>str     Path to zipfile of GLM outputs.</code>"},{"location":"simulation/#glmpy.simulation.GLMSim","title":"<code>GLMSim</code>","text":"<p>Prepare inputs and run a GLM simulation.</p> <p>The <code>GLMSim</code> class has attributes and methods that handle running GLM simulations and processing the results.</p> <p>The class is designed to work with GLM simulations running on local instances of GLM or instances of GLM behind a FastAPI web API (i.e. when running GLM simulations as a web service). When running GLM locally input files required for a simulation (e.g. glm3.nml, met.csv) should be passed in as dict object with the format: <code>{\"&lt;filename&gt;\": \"&lt;path-to-file&gt;\"}. When running GLM behind a web API, input files can be sent to the server from a client through a HTTP request and will be processed as a FastAPI</code>UploadFile` object: https://fastapi.tiangolo.com/tutorial/request-files/#uploadfile</p> <p>Attributes:</p> Name Type Description <code>input_files</code> <code>Union[UploadFile, dict]</code> <p>FastAPI <code>UploadFile</code> object storing input files for a GLM simulation or, if running GLM locally or outside a FastAPI environment a dict of filenames (keys) and paths to files (values).</p> <code>api</code> <code>bool</code> <p>If True, GLM is run using FastAPI engine. Otherwise, local GLM versions.</p> <code>inputs_dir</code> <code>str</code> <p>File path to directory to save input files for GLM simulation.</p> <p>Examples:</p> <p>Running GLM as a web service behind a FastAPI endpoint. <code>files</code> is a FastAPI <code>UploadFile</code> object.</p> <pre><code>&gt;&gt;&gt; import glmpy.simulation as sim\n&gt;&gt;&gt; glm_sim = sim.GLMSim(files, True, \"/inputs\")\n&gt;&gt;&gt; inputs_dir = glm_sim.prepare_inputs()\n&gt;&gt;&gt; glm_sim.glm_run(inputs_dir, \"/glm/glm\")\n</code></pre> <p>Running GLM locally. <code>files</code> is a dict object with paths to where input files are stored.</p> <pre><code>&gt;&gt;&gt; import glmpy.simulation as sim\n&gt;&gt;&gt; files = {\n&gt;&gt;&gt;    \"glm3.nml\": \"/path/to/glm3.nml\",\n&gt;&gt;&gt;    \"met.csv\": \"/path/to/met.csv\"\n&gt;&gt;&gt; }\n&gt;&gt;&gt; glm_sim = sim.GLMSim(files, False, \"/inputs\")\n&gt;&gt;&gt; inputs_dir = glm_sim.prepare_inputs()\n&gt;&gt;&gt; glm_sim.glm_run(inputs_dir, \"/glm/glm\")\n</code></pre>"},{"location":"simulation/#glmpy.simulation.GLMSim.bundled_glm_path","title":"<code>bundled_glm_path()</code>  <code>staticmethod</code>","text":"<p>Path of the bundled GLM executable.</p> <p>Returns the path of the internally bundled GLM executable. If the  executable does not exist in the expected path, <code>bundled_glm_path()</code>  returns <code>None</code>.</p>"},{"location":"simulation/#glmpy.simulation.GLMSim.glm_run","title":"<code>glm_run(inputs_dir, glm_path=None)</code>","text":"<p>Run a GLM simulation.</p> <p>Parameters:</p> Name Type Description Default <code>inputs_dir</code> <code>str</code> <p>File path to directory with input files required for a GLM simulation.</p> required <code>glm_path</code> <code>Union[str, None]</code> <p>Path to location of GLM binary. If None, the internally bundled GLM executable will be called.</p> <code>None</code>"},{"location":"simulation/#glmpy.simulation.GLMSim.prepare_inputs","title":"<code>prepare_inputs()</code>","text":"<p>Prepare input files for a GLM simulation.</p> <p>If <code>inputs_dir</code> exists, it will be deleted and a new directory created with new input files.</p> <p>Returns:</p> Type Description <code>str</code> <p>File path to directory with input files required for a GLM  simulation.</p>"},{"location":"sparkling/","title":"Sparkling","text":""},{"location":"sparkling/#glmpy.example_sims.sparkling.load_bcs","title":"<code>load_bcs()</code>","text":"<p>Load the Sparkling Lake meteorology CSV file.</p> <p>Returns:</p> Type Description <code>Dataframe</code> <p>Pandas dataframe of the Sparkling Lake meteorology CSV file.</p>"},{"location":"sparkling/#glmpy.example_sims.sparkling.load_nml","title":"<code>load_nml()</code>","text":"<p>Load the Sparkling Lake NML file.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of the Sparkling Lake NML file.</p>"},{"location":"sparkling/#glmpy.example_sims.sparkling.run_sim","title":"<code>run_sim(inputs_dir='sparkling', glm_path=None)</code>","text":"<p>Run the Sparkling Lake simulation.</p> <p>Sparkling Lake is an oligotrophic, northern temperate lake  (89.7 \u00baN, 46.3 \u00baW) in Winconsin, USA. The lake has a surface area of 0.638  km2, and is about 20 m deep. The model is set-up to simulate the  hydrological domain of Sparkling Lake for 2 years, from 1980-04-15 to  1982-04-15 (&amp;time), with water balance and heat fluxes hypothetically  calculated based on the lake configuration and input data. In this model,  water quality functionality (AED2) (&amp;wq_setup) is disabled. For more information see: https://github.com/AquaticEcoDynamics/glm-aed/tree/main/glm-examples/Sparkling.</p> <p>Parameters:</p> Name Type Description Default <code>inputs_dir</code> <code>str</code> <p>Directory path where the model inputs will be saved. Default is  <code>\"sparkling\"</code>.</p> <code>'sparkling'</code> <code>glm_path</code> <code>Union[str, None]</code> <p>Optional. Path to an external GLM binary. Default is <code>None</code>.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy.example_sims import sparkling\n&gt;&gt;&gt; sparkling.run_sim()\n</code></pre>"},{"location":"blog/","title":"Blog","text":""},{"location":"contributing/","title":"Contributing","text":"<p>glm-py is an open source project that is actively maintained by the Aquatic  EcoDynamics research group at the University of Western Australia. If you'd like to contribute to the project, please familiarise yourself with the contributing guide below.</p>"},{"location":"contributing/#environment","title":"Environment","text":"<p>A Docker container can be used to create a development environment. You can  either build the Docker image:</p> <p><pre><code>docker build -t glm-py-dev .devcontainer\n</code></pre> Or, you can develop glm-py using a dev-container.</p>"},{"location":"contributing/#code-style","title":"Code style","text":"<p>Code linting and formatting uses ruff and black. A script to format the glm-py  repository can be run: <code>./scripts/format.sh</code>. </p> <p>pre-commit is used to run ruff and black. </p>"},{"location":"contributing/#tests","title":"Tests","text":"<p>pytest is used  for testing glm-py. </p> <p>If testing, please add tests under the <code>tests</code> directory. If you need test data  for running tests, add them as <code>pytest.fixtures</code> in <code>conftest.py</code>. </p>"},{"location":"contributing/#pull-requests","title":"Pull requests","text":"<p>Submit pull requests to the <code>next-release</code> branch. This is where glm-py is  actively developed.</p>"},{"location":"contributing/#suggested-contributions","title":"Suggested contributions","text":"<ul> <li>An <code>aed_nml</code> sub-module for the <code>nml</code> module that mirrors the functionality of the <code>glm_nml</code> sub-module. </li> <li>Parameter documentation for the <code>glm_nml</code> sub-module.</li> <li>Additional simple morphometries in the <code>dimensions</code> module.</li> </ul>"},{"location":"how_to/how-to-dimensions/","title":"How-to: <code>dimensions</code> module","text":""},{"location":"how_to/how-to-dimensions/#calculating-the-morphometry-parameters-for-simple-water-bodies","title":"Calculating the morphometry parameters for simple water bodies","text":"<p>For simple water bodies, the <code>dimensions</code> module provides classes to easily  calculate the <code>H</code> and <code>A</code> (height and surface area) parameters for the  <code>MorphometryBlock</code> class, i.e., the <code>&amp;morphometry</code> configuration block.</p> <p>The <code>InvertedTruncatedPyramid</code> class can be used for pyramidal water bodies  with a square/rectangular base while <code>InvertedTruncatedCone</code> is useful for  circular water bodies.</p> <p> </p> <p> </p> <pre><code>from glmpy import dimensions\n\nmy_dimensions = dimensions.InvertedTruncatedSquarePyramid(\n    height=6,\n    surface_length=40,\n    side_slope=1/3,\n    num_vals=7,\n    surface_elevation=0\n)\n</code></pre> <p>Heights and surface areas can be then returned with the <code>get_heights()</code> and <code>get_surface_areas()</code> methods:</p> <pre><code>print(my_dimensions.get_heights())\nprint(my_dimensions.get_surface_areas())\n</code></pre> <pre><code>[-6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0]\n[16.0, 100.0, 256.0, 484.0, 784.0, 1156.0, 1600.0]\n</code></pre>"},{"location":"how_to/how-to-dimensions/#num_vals","title":"<code>num_vals</code>","text":"<p>Notice how the length of lists returned by <code>get_heights()</code> and <code>get_surface_areas</code> equals the <code>num_vals</code> attribute? <code>num_vals</code> can be used to increase or decrease the the number of <code>H</code> and <code>A</code> values calculated between the top and bottom of the water body.</p> <p>Increasing <code>num_vals</code>:</p> <pre><code>my_dimensions = dimensions.InvertedTruncatedSquarePyramid(\n    height=6,\n    surface_length=40,\n    side_slope=1/3,\n    num_vals=9,\n    surface_elevation=0\n)\nprint(my_dimensions.get_heights())\nprint(my_dimensions.get_surface_areas())\n</code></pre> <pre><code>[-6.0, -5.25, -4.5, -3.75, -3.0, -2.25, -1.5, -0.75, 0.0]\n[16.0, 72.25, 169.0, 306.25, 484.0, 702.25, 961.0, 1260.25, 1600.0]\n</code></pre> <p>Decreasing <code>num_vals</code>:</p> <pre><code>my_dimensions = dimensions.InvertedTruncatedSquarePyramid(\n    height=6,\n    surface_length=40,\n    side_slope=1/3,\n    num_vals=4,\n    surface_elevation=0\n)\nprint(my_dimensions.get_heights())\nprint(my_dimensions.get_surface_areas())\n</code></pre> <pre><code>[-6.0, -4.0, -2.0, 0.0]\n[16.0, 256.0, 784.0, 1600.0]\n</code></pre>"},{"location":"how_to/how-to-dimensions/#surface_elevation","title":"<code>surface_elevation</code>","text":"<p>The elevation of the water body can be adjusted through the <code>surface_elevation</code> attribute.</p> <p>Surface elevation of 100m:</p> <pre><code>my_dimensions = dimensions.InvertedTruncatedSquarePyramid(\n    height=6,\n    surface_length=40,\n    side_slope=1/3,\n    num_vals=7,\n    surface_elevation=100\n)\nprint(my_dimensions.get_heights())\n</code></pre> <pre><code>[94.0, 95.0, 96.0, 97.0, 98.0, 99.0, 100.0]\n</code></pre> <p>Surface elevation of -100m:</p> <pre><code>my_dimensions = dimensions.InvertedTruncatedSquarePyramid(\n    height=6,\n    surface_length=40,\n    side_slope=1/3,\n    num_vals=7,\n    surface_elevation=100\n)\nprint(my_dimensions.get_heights())\n</code></pre> <pre><code>[-106.0, -105.0, -104.0, -103.0, -102.0, -101.0, -100.0]\n</code></pre>"},{"location":"how_to/how-to-dimensions/#invalid-dimensions","title":"Invalid dimensions","text":"<p>If <code>InvertedTruncatedSquarePyramid</code> is initialised with invalid dimensions, glm-py will raise an error and tell you how to correct it:</p> <pre><code>my_dimensions = dimensions.InvertedTruncatedSquarePyramid(\n    height=6,\n    surface_length=1, # &lt;-- invlaid surface_length\n    side_slope=1/3,\n    num_vals=7,\n    surface_elevation=0\n)\n</code></pre> <pre><code>ValueError: Invalid combination of height, surface_length, and side_slope attributes. The calculated base_length of the water body is currently &lt;= 0. base_length is calculated by (surface_length-(height/side_slope)*2). Adjust your input attributes to calculate a positive base_length value.\n</code></pre>"},{"location":"how_to/how-to-dimensions/#constructing-the-morphometry-parameters","title":"Constructing the <code>&amp;morphometry</code> parameters","text":"<p>You can plug the lists returned by the <code>get_heights()</code> and <code>get_surface_areas</code> methods directly into the <code>NMLMorphometry</code> class from the <code>nml</code> module. Remember to set the <code>bsn_vals</code> attribute in <code>NMLMorphometry</code> to equal the <code>num_vals</code> attribute:</p> <pre><code>from glmpy import dimensions, nml\n\nnum_vals=7\n\nmy_dimensions = dimensions.InvertedTruncatedSquarePyramid(\n    height=6,\n    surface_length=40,\n    side_slope=1/3,\n    num_vals=num_vals,\n    surface_elevation=0\n)\n\nmorphometry = nml.NMLMorphometry(\n    H=my_dimensions.get_heights(),\n    A=my_dimensions.get_areas(),\n    bsn_vals=num_vals\n)\n</code></pre>"},{"location":"how_to/how-to-glm_json/","title":"How-to: <code>glm_json</code> module","text":""},{"location":"how_to/how-to-glm_json/#converting-json-to-nml","title":"Converting JSON to <code>.nml</code>","text":"<p>For software development applications, it's often useful to store and transmit the model parameters of a GLM simulation in JSON format. glm-py's <code>glm_json</code>  module provides a <code>JSONReader</code> class that reads a JSON file and returns  dictionaries of model parameters.</p> <p>Consider the following JSON file saved as <code>json_parameters.json</code>:</p> <pre><code>{\n  \"&amp;glm_setup\": {\n    \"sim_name\": \"Sparkling Lake\",\n    \"max_layers\": 500,\n    \"min_layer_vol\": 0.5,\n    \"min_layer_thick\": 0.15,\n    \"max_layer_thick\": 0.5,\n    \"density_model\": 1,\n    \"non_avg\": true\n  },\n  \"&amp;morphometry\": {\n    \"lake_name\": \"Sparkling\",\n    \"latitude\": 46.00881,\n    \"longitude\": -89.69953,\n    \"crest_elev\": 320.0,\n    \"bsn_len\": 901.0385,\n    \"bsn_wid\": 901.0385,\n    \"bsn_vals\": 15,\n    \"H\": [301.712, 303.018285714286, 304.324571428571, 305.630857142857, 306.937142857143, 308.243428571429, 309.549714285714, 310.856, 312.162285714286, 313.468571428571, 314.774857142857, 316.081142857143, 317.387428571429, 318.693714285714, 320, 321],\n    \"A\": [0, 45545.8263571429, 91091.6527142857, 136637.479071429, 182183.305428571, 227729.131785714, 273274.958142857, 318820.7845, 364366.610857143, 409912.437214286, 455458.263571429, 501004.089928571, 546549.916285714, 592095.742642857, 637641.569, 687641.569]\n  },\n  \"&amp;time\": {\n    \"timefmt\": 3,\n    \"start\": \"1980-04-15\",\n    \"stop\": \"2012-12-10\",\n    \"dt\": 3600,\n    \"timezone\": -6,\n    \"num_days\": 730\n  },\n  \"&amp;init_profiles\": {\n    \"lake_depth\": 18.288,\n    \"num_depths\": 3,\n    \"the_depths\": [0, 0.2, 18.288],\n    \"the_temps\": [3, 4, 4],\n    \"the_sals\": [0, 0, 0],\n    \"num_wq_vars\": 6,\n    \"wq_names\": [\"OGM_don\", \"OGM_pon\", \"OGM_dop\", \"OGM_pop\", \"OGM_doc\", \"OGM_poc\"],\n    \"wq_init_vals\": [1.1, 1.2, 1.3, 1.2, 1.3, 2.1, 2.2, 2.3, 1.2, 1.3, 3.1, 3.2, 3.3, 1.2, 1.3, 4.1, 4.2, 4.3, 1.2, 1.3, 5.1, 5.2, 5.3, 1.2, 1.3, 6.1, 6.2, 6.3, 1.2, 1.3]\n  }\n}\n</code></pre> <p>To convert this JSON file to <code>.nml</code>, first import the <code>glm_json</code> module:</p> <pre><code>from glmpy import glm_json\n</code></pre> <p>Then, create an instance of the <code>JSONReader</code> class and provide the path to the  JSON file:</p> <pre><code>json_file = glm_json.JSONReader('json_parameters.json')\n</code></pre> <p>For each configuration block in the JSON file, you can return a dictionary of  model parameters with the <code>get_nml_parameters()</code> method. These can be use to set the attributes of the corresponding <code>nml.NML*</code> class, or be  passed directly to the <code>nml.NML</code> class (note, no error checking will be  applied):</p> <pre><code>glm_setup_attrs = json_file.get_nml_parameters(\"&amp;glm_setup\")\nprint(glm_setup_attrs)\n</code></pre> <pre><code>{'sim_name': 'Sparkling Lake', 'max_layers': 500, 'min_layer_vol': 0.5, 'min_layer_thick': 0.15, 'max_layer_thick': 0.5, 'density_model': 1, 'non_avg': True}\n</code></pre> <pre><code>from glmpy import nml\n\nglm_setup = nml.NMLGLMSetup()\nglm_setup.set_attributes(glm_setup_attrs)\n\nnml = nml.NML(\n  glm_setup=glm_setup(),\n  morphometry=json_file.get_nml_parameters(\"&amp;morphometry\"),\n  time=json_file.get_nml_parameters(\"&amp;time\"),\n  init_profiles=json_file.get_nml_parameters(\"&amp;init_profiles\")\n)\n\nnml.write_nml(nml_file_path='glm3.nml')\n</code></pre>"},{"location":"how_to/how-to-inflows/","title":"How-to: <code>inflows</code> module","text":""},{"location":"how_to/how-to-inflows/#calculating-inflows-from-catchment-runoff","title":"Calculating inflows from catchment runoff","text":"<p>The <code>CatchmentRunoffInflows</code>  class provides functionality for calculating inflows from catchment runoff during  rainfall events. The amount of runoff is calculated as a function of the  catchment area, precipitation, and a runoff coefficient/threshold.</p> <p>To use <code>CatchmentRunoffInflows</code>, you must first have a CSV or  <code>pandas.DataFrame</code> object of precipitation data in an hourly or daily  frequency. Consider the following timeseries:</p> <pre><code>import pandas as pd \n\nmet_data = pd.DataFrame({\n    'Date': pd.date_range(\n        start='1997-01-01',\n        end='2004-12-31',\n        freq='24h'),\n    'Rain': 0.024 #m per day\n})\n</code></pre> <p>We can now initalise the <code>CatchmentRunoffInflows</code> class by passing in this  DataFrame, the catchment area (in m<sup>2</sup>), the date and rainfall column  names, and either a runoff coefficient or a runoff threshold:</p> <pre><code>from glmpy import inflows\n\nmy_inflows = inflows.CatchmentRunoffInflows(\n    met_data=met_data,\n    catchment_area=1000, # a 1000 m^2 catchment area\n    runoff_coef=0.5, \n    precip_col='Rain',\n    date_time_col='Date'\n)\n</code></pre>"},{"location":"how_to/how-to-inflows/#inspect-the-catchment-inflows","title":"Inspect the catchment inflows","text":"<p>Upon calling the <code>get_inflows()</code>  method, <code>CatchmentRunoffInflows</code> will calculate runoff and return a DataFrame of infows in units of m<sup>3</sup>/sec:</p> <pre><code>my_inflows.get_inflows()\n</code></pre> <pre><code>time        flow            \n1997-01-01  0.000139\n1997-01-02  0.000139\n1997-01-03  0.000139\n1997-01-04  0.000139\n1997-01-05  0.000139\n...              ...\n2004-12-27  0.000139\n2004-12-28  0.000139\n2004-12-29  0.000139\n2004-12-30  0.000139\n2004-12-31  0.000139\n\n[2922 rows x 1 columns]\n</code></pre>"},{"location":"how_to/how-to-inflows/#writing-catchment-inflows-to-a-csv","title":"Writing catchment inflows to a CSV","text":"<p>The inflows DataFrame can then be saved to file by simply calling the  <code>write_inflows</code> method:</p> <pre><code>my_inflows.write_inflows(\n    file_path=\"runoff.csv\"\n)\n</code></pre>"},{"location":"how_to/how-to-nml/","title":"How-to: <code>nml</code> module","text":"<p>The <code>nml</code> module of glm-py provides tools for reading and writing NML  configuration files. The module is divided into two sub-modules that cater to different use cases and levels of control: </p> <ul> <li><code>nml.glm_nml</code>: High-level tools for writing GLM NML files only. Provides  classes to construct each configuration block with parameter documentation and  error checking. Applicable for most use cases.  </li> <li><code>nml.nml</code>: Low-level tools for reading and writing any NML file, i.e., for  GLM or AED. To write files, users will need to create a nested dictionary of  parameters. Does not enforce any requirements on the supplied parameters.  Applicable to users who need to do something custom or go beyond what is  currently supported with the high-level tools.</li> </ul>"},{"location":"how_to/how-to-nml/#the-nmlglm_nml-sub-module","title":"The <code>nml.glm_nml</code> sub-module","text":""},{"location":"how_to/how-to-nml/#writing-a-glm-nml-file","title":"Writing a GLM NML file","text":"<p>The <code>nml.glm_nml</code> sub-module provides tools for writing GLM NML files only. To write a file, start by importing the <code>glm_nml</code> sub-module from the <code>nml</code> module  of <code>glmpy</code>:</p> <pre><code>from glmpy.nml import glm_nml\n</code></pre>"},{"location":"how_to/how-to-nml/#classes-for-nml-configuration-blocks","title":"Classes for NML configuration blocks","text":"<p>Each configuration block in a GLM NML file (e.g., <code>&amp;glm_setup</code>,  <code>&amp;morphometry</code>, and <code>&amp;init_profiles</code>) has a respective class in the <code>glm_nml</code>  sub-module, e.g., <code>glm_nml.SetupBlock</code>, <code>glm_nml.MorphometryBlock</code>, and  <code>glm_nml.InitProfilesBlock</code>. These classes are used to construct dictionaries  of model parameters which can be combined in the <code>glm_nml.GLMNML</code> class to  write the NML file. For example, the <code>&amp;glm_setup</code> parameters can be constructed  with the <code>glm_nml.SetupBlock</code> class as follows:</p> <pre><code>my_setup = glm_nml.SetupBlock(\n    sim_name='GLMSimulation',\n    max_layers=500,\n    min_layer_vol=0.5,\n    min_layer_thick=0.15,\n    max_layer_thick=0.5,\n    density_model=1,\n    non_avg=True\n)\n</code></pre> <p>Alternatively, the class attributes can be set/updated with the  <code>set_attrs()</code> method:</p> <pre><code>my_setup = glm_nml.SetupBlock()\n\nsetup_params = {\n    'sim_name': 'GLMSimulation',\n    'max_layers': 500,\n    'min_layer_vol': 0.5,\n    'min_layer_thick': 0.15,\n    'max_layer_thick': 0.5,\n    'density_model': 1,\n    'non_avg': True\n}\n\nmy_setup.set_attrs(setup_params)\n</code></pre> <p>Refer to the API Reference for detailed information about the attributes  (i.e., the GLM model parameters) for each block.</p>"},{"location":"how_to/how-to-nml/#returning-a-dictionary-consolidated-model-parameters","title":"Returning a dictionary consolidated model parameters","text":"<p>When you call the <code>get_params()</code> method of the <code>SetupBlock</code> class (or any  configuration block class), a dictionary of consolidated model parameters will  be returned. </p> <pre><code>print(my_setup.get_params())\n</code></pre> <pre><code>{'sim_name': 'GLMSimulation', 'max_layers': 500, 'min_layer_vol': 0.5, 'min_layer_thick': 0.15, 'max_layer_thick': 0.5, 'density_model': 1, 'non_avg': True}\n</code></pre> <p>Note</p> <p><code>get_params()</code> has an optional <code>check_params</code> parameter for the purpose of validating your model parameters and raising errors if they are not  compliant with what GLM expects. As of glm-py <code>0.2.0</code>, <code>check_params</code> is accessible but no error checking  is currently implemented.</p>"},{"location":"how_to/how-to-nml/#writing-the-nml-file","title":"Writing the NML file","text":"<p>At a minimum, the GLM NML file requires model parameters set for the following  blocks:</p> <ul> <li><code>&amp;glm_setup</code> with the <code>SetupBlock</code> class</li> <li><code>&amp;morphometry</code> with the <code>MorphometryBlock</code> class</li> <li><code>&amp;time</code> with the <code>TimeBlock</code> class</li> <li><code>&amp;init_profiles</code> with the <code>InitProfilesBlock</code> class</li> </ul> <p>The parameter dictionaries returned by these classes can then be combined into  a NML file with the <code>GLMNML</code> class:</p> <pre><code>my_nml = glm_nml.GLMNML(\n    setup=my_setup.get_params(),\n    morphometry=my_morphometry.get_params(),\n    time=my_time.get_params(),\n    init_profiles=my_init_profiles.get_params()\n)\n</code></pre> <p>Note</p> <p>The <code>GLMNML</code> class also provides an optional <code>check_params</code> attribute to validate model parameters that have dependencies between blocks. As of  <code>0.2.0</code> this error checking is not currently implemented</p> <p>To write the NML file to disk, call the <code>write_nml()</code> method and provide the output file path:</p> <pre><code>my_nml.write_nml(nml_file_path='my_nml.nml')\n</code></pre>"},{"location":"how_to/how-to-nml/#the-nmlnml-sub-module","title":"The <code>nml.nml</code> sub-module","text":"<p>The <code>nml.nml</code> sub-module provides tools for reading and writing any NML file. It provides greater control on how to read/write each parameter but comes at the cost of some of the more user-friendly features of the <code>nml.glm_nml</code> sub-module, e.g., model parameter documentation and error checking. </p>"},{"location":"how_to/how-to-nml/#writing-a-nml-file-with-nmlwriter","title":"Writing a NML file with <code>NMLWriter</code>","text":"<p>In advanced use-cases, you may wish to write a NML file that goes beyond  what is possible with the <code>nml.glm_nml</code> sub-module, e.g., writing custom  configuration blocks or extending existing ones. In these situations the  <code>NMLWriter</code> class in the <code>nml.nml</code> sub-module provides near complete control over the contents of a NML file.</p>"},{"location":"how_to/how-to-nml/#writing-a-custom-block","title":"Writing a custom block","text":"<p>Consider the example NML file below:</p> <pre><code>&amp;custom_block1\n   param1 = 123\n   param2 = 1.23\n   param3 = 'foo'\n   param4 = .true.\n/\n&amp;custom_block2\n   param1 = 1,2,3\n   param2 = 'foo','bar','baz'\n   param3 = .true.,.false.,.true.,\n            .true.,.false.,.true.,\n            .true.,.false.,.true.\n/\n</code></pre> <p>It's not possible to produce an output like this with tools in the  <code>nml.glm_nml</code> sub-module - you're restricted to the standard configuration  blocks and parameters. </p> <p>To write this file with <code>NMLWriter</code>, first import the <code>nml.nml</code> sub-module:</p> <pre><code>from glmpy.nml import nml\n</code></pre> <p>Next, create a nested dictionary where they keys are the block names and the values are a dictionary of parameters:</p> <pre><code>custom_nml = {\n    \"custom_block1\": {\n        \"param1\": 123,\n        \"param2\": 1.23,\n        \"param3\": \"foo\",\n        \"param4\": True\n    },\n    \"custom_block2\": {\n        \"param1\": [1, 2, 3],\n        \"param2\": [\"foo\", \"bar\", \"baz\"],\n        \"param3\": [True, False, True]\n    }\n}\n</code></pre> <p>This is your NML file in Python syntax. Be mindful of the Python data types you use for your parameter values. They map to the respective syntax of data types in a NML file. Python integers will be converted to NML integers, floats to  floats, etc. Notice too the use of Python lists for NML comma-separated lists.</p> <p>Note</p> <p>For lists, don't mix and match your Python data types -  especially integers and floats. </p> <p>Now create an instance of <code>NMLWriter</code> and provide your nested dictionary:</p> <pre><code>my_nml = nml.NMLWriter(custom_nml)\n</code></pre> <p>To write the file, simply call the <code>write_nml</code> method and provide and path for the NML output:</p> <pre><code>my_nml.write_nml(nml_file=\"custom_nml.nml\")\n</code></pre>"},{"location":"how_to/how-to-nml/#setting-the-parameter-converters","title":"Setting the parameter converters","text":"<p>In even more advanced use-cases, you may wish to explicitly control how  <code>NMLWriter</code> converts a Python data type to the syntax of a NML data type. By  default, <code>NMLWriter</code> is initialised with the <code>detect_types</code> attribute set to <code>True</code>. This will trigger <code>NMLWriter</code> to automatically convert parameters to  the most appropriate NML data types (ints to ints, floats to floats, etc).  By setting <code>detect_types</code> to <code>False</code> you can override the automatic conversion  and provide your own syntax conversion functions. </p> <p>Consider again the example from above:</p> <pre><code>custom_nml = {\n    \"custom_block1\": {\n        \"param1\": 123,\n        \"param2\": 1.23,\n        \"param3\": \"foo\",\n        \"param4\": True\n    },\n    \"custom_block2\": {\n        \"param1\": [1, 2, 3],\n        \"param2\": [\"foo\", \"bar\", \"baz\"],\n        \"param3\": [True, False, True]\n    }\n}\n</code></pre> <p>When <code>NMLWriter</code> is initialised with <code>custom_nml</code> and <code>detect_types</code> set to  <code>True</code>, it will construct the following dictionary of syntax conversion  methods:</p> <p><pre><code>{\n    \"custom_block1\": {\n        \"param1\": None,\n        \"param2\": None,\n        \"param3\": nml.NMLWriter.write_nml_str,\n        \"param4\": nml.NMLWriter.write_nml_bool\n    },\n    \"custom_block2\": {\n        \"param1\": nml.NMLWriter.write_nml_list,\n        \"param2\": lambda x: nml.NMLWriter.write_nml_list(\n            x, nml.NMLWriter.write_nml_str\n        ),\n        \"param3\": lambda x: nml.NMLWriter.write_nml_list(\n            x, nml.NMLWriter.write_nml_bool\n        )\n    }\n}\n</code></pre> What are <code>write_nml_str</code>, <code>write_nml_bool</code>, and <code>write_nml_list</code>? These are  static methods that you can call independently of initialising <code>NMLWriter</code> to  convert Python syntax to NML syntax:</p> <p><pre><code>nml_string = nml.NMLWriter.write_nml_str(\"GLM\")\nprint(nml_string)\n</code></pre> <pre><code>'GLM'\n</code></pre> <pre><code>nml_bool = nml.NMLWriter.write_nml_bool(True)\nprint(nml_bool)\n</code></pre> <pre><code>.true.\n</code></pre> <pre><code>nml_list = nml.NMLWriter.write_nml_list([1, 2, 3])\nprint(nml_list)\n</code></pre> <pre><code>1,2,3\n</code></pre></p> <p>Note</p> <p>No static methods are required for converting integers and floats. </p> <p>When writing lists with string or boolean elements, lambda functions  can used create new combinations of these methods.</p> <p>By creating a nested dictionary in the same fashion as shown above, you can  tell <code>NMLWriter</code> how to write each parameter. Simply initialise the class with  <code>detect_types</code> set to <code>False</code> and then call the <code>set_converters</code> method  with your nested dictionary of conversion functions:</p> <pre><code>my_nml = nml.NMLWriter(custom_nml, detect_types=False)\nmy_nml.set_converters(my_conversion_methods_dict) \nmy_nml.write_nml(nml_file=\"custom_nml.nml\")\n</code></pre> <p>To see this in action, let's consider an example where we wish to write the  complex number <code>0.5 + 1.2j</code> to a NML file. The desired output would be:</p> <pre><code>&amp;custom_block\n   param1 = (0.5, 1,2)\n/\n</code></pre> <p>Here, the first component within the parentheses is a real number and the  second component is an imaginary number. We can easily write a Python function that returns a string of the NML complex number:</p> <p><pre><code>import cmath\n\ndef write_nml_complex_num(py_complex_num: complex) -&gt; str:\n    return f\"({py_complex_num.real}, {py_complex_num.imag})\"\n\nz = 0.5 + 1.2j\n\nprint(write_nml_complex_num(z))\n</code></pre> <pre><code>(0.5, 1.2)\n</code></pre></p> <p>Now we can write the NML file by creating a dictionary with the parameter  value and another with our custom syntax conversion function:</p> <pre><code>custom_nml = {\n    \"custom_block\": {\n        \"param1\": 0.5 + 1.2j\n    }\n}\ncustom_converters = {\n    \"custom_block\": {\n        \"param1\": write_nml_complex_num\n    }\n}\n\nmy_nml = nml.NMLWriter(nml_dict=custom_nml, detect_types=False)\nmy_nml.set_converters(custom_converters)\nmy_nml.write_nml(nml_file=\"custom_nml.nml\")\n</code></pre>"},{"location":"how_to/how-to-nml/#reading-a-nml-file-with-nmlreader","title":"Reading a NML file with <code>NMLReader</code>","text":"<p>glm-py makes it easy to run simulations from pre-existing NML files with the  <code>NMLReader</code> class. </p>"},{"location":"how_to/how-to-nml/#reading-blocks","title":"Reading blocks","text":"<p>Consider the following exert from <code>example_glm_nml.nml</code>:</p> <pre><code>!-------------------------------------------------------------------------------\n! general model setup\n!-------------------------------------------------------------------------------\n!\n! sim_name         [string]  title of simulation\n! max_layers       [integer] maximum number of layers\n! min_layer_vol    [real]    minimum layer volume (m3 * 1000)\n! min_layer_thick  [real]    minimum layer thickness (m)\n! max_layer_thick  [real]    maximum layer thickness (m)\n! Kw               [real]    background light attenuation (m**-1)\n! coef_mix_conv    [real]    mixing efficiency - convective overturn\n! coef_wind_stir   [real]    mixing efficiency - wind stirring\n! coef_mix_turb    [real]    mixing efficiency - unsteady turbulence effects\n! coef_mix_shear   [real]    mixing efficiency - shear production\n! coef_mix_KH      [real]    mixing efficiency - hypolimnetic Kelvin-Helmholtz turbulent billows\n! coef_mix_hyp     [real]    mixing efficiency - hypolimnetic turbulence\n! deep_mixing      [bool]    flag to disable deep-mixing\n!-------------------------------------------------------------------------------\n&amp;glm_setup\n   sim_name = 'GLM Simulation'\n   max_layers = 60\n   min_layer_vol = 0.0005\n   min_layer_thick = 0.05\n   max_layer_thick = 0.1\n   non_avg = .true.\n   !  mobility_off = .true.\n/\n\n&amp;mixing\n   !-- Mixing Parameters\n   coef_mix_conv = 0.125\n   coef_wind_stir = 0.23\n   coef_mix_shear = 0.00\n   coef_mix_turb = 0.51\n   coef_mix_KH = 0.30\n   coef_mix_hyp = 0.5\n  deep_mixing = 0\n  surface_mixing = 1\n/\n&amp;light\n!-- Light Parameters\nlight_mode = 0\nKw = 3.5\n/\n</code></pre> <p>With <code>NMLReader</code> you can convert this to a nested python dictionary that's ready for use with the rest of tools in the <code>nml</code> and <code>glm_nml</code> sub-modules. To read the file, import the <code>nml</code> sub-module and initialise an instance of <code>NMLReader</code> by providing the path to <code>example_nml.nml</code>:</p> <pre><code>from glmpy.nml import nml\n\nexample_nml = nml.NMLReader(\"example_nml.nml\")\n</code></pre> <p>Now call the <code>get_nml</code> method to convert and return the entire NML file as a nested dictionary:</p> <p><pre><code>nml_dict = example_nml.get_nml()\nprint(nml_dict)\n</code></pre> <pre><code>{'glm_setup': {'sim_name': 'GLM Simulation', 'max_layers': 60, 'min_layer_vol': 0.0005, 'min_layer_thick': 0.05, 'max_layer_thick': 0.1, 'non_avg': True}, 'mixing': {'coef_mix_conv': 0.125, 'coef_wind_stir': 0.23, 'coef_mix_shear': 0.0, 'coef_mix_turb': 0.51, 'coef_mix_KH': 0.3, 'coef_mix_hyp': 0.5, 'deep_mixing': 0, 'surface_mixing': 1}, 'light': {'light_mode': 0, 'Kw': 3.5}}\n</code></pre></p> <p>To return a specific block, call the <code>get_block</code> method and provide the block name:</p> <p><pre><code>light_block = example_nml.get_block(\"light\")\nprint(light_block)\n</code></pre> <pre><code>{'light_mode': 0, 'Kw': 3.5}\n</code></pre></p> <p>Bug</p> <p><code>NMLReader</code> will return erroneous results if the NML file has the  following:</p> <ul> <li> <p>Exclamation marks (<code>!</code>) within a string parameters, e.g., <code>sim_name =  'A very important sim!'</code>. Exclamation marks are used to declare comments in  NML files.</p> </li> <li> <p>Comma-separated lists terminating with commas, e.g.,  <code>A = 100, 3600, 5600,</code>. Remove the final comma: <code>A = 100, 3600, 5600</code>.</p> </li> </ul>"},{"location":"how_to/how-to-nml/#setting-the-parameter-converters_1","title":"Setting the parameter converters","text":"<p>As of glm-py <code>0.2.0</code>, <code>NMLReader</code> lacks a similar implementation of the automatic syntax conversion that <code>NMLWriter</code> performs when <code>detect_types</code> is  set to <code>True</code>, i.e., it does not go build a dictionary of the appropriate  syntax conversion methods to use from the data types it sees. As a result,  <code>NMLReader</code> relies on an internal dictionary of syntax conversion methods that  currently only covers GLM configuration blocks. To read AED NML files or  custom GLM NML files, you'll need to provide your own nested dictionary syntax  conversion methods.</p> <p>Note</p> <p>Support for automatic syntax conversion in <code>NMLReader</code> is planned.</p> <p>Consider the following AED NML file saved as <code>aed.nml</code>:</p> <pre><code>&amp;aed_tracer\n    retention_time = .true.\n    num_tracers = 1\n    decay = 0,0\n    Fsed = 0,0\n/\n</code></pre> <p>Attempting to read this file with <code>NMLReader</code> will raise the following warning:</p> <p><pre><code>from glmpy.nml import nml\n\naed_nml = nml.NMLReader(\"aed.nml\")\nnml_dict = aed_nml.get_nml()\n</code></pre> <pre><code>UserWarning: Unexpected block 'aed_tracer' in the NML file. If parsing this block is desired, update the conversion methods with `set_converters()`. Provide a dictionary containing the block name as the key and a nested dictionary of parameter conversion methods as the value. For example: \n&gt;&gt;&gt; converters = {\"aed_tracer\": {\"param1\": NMLReader.read_nml_str}}\n</code></pre></p> <p>As prompted we need to create a nested dictionary that contains the conversion methods to convert NML data types to Python data types. Just like <code>NMLWriter</code>, <code>NMLReader</code> provides a suite of static methods for reading various string representations of NML data types:</p> <p><pre><code>nml_string = 'GLM'\npython_string = nml.NMLReader.read_nml_str(nml_string)\nprint(python_string)\nprint(type(python_string))\n</code></pre> <pre><code>GLM\n&lt;class 'str'&gt;\n</code></pre></p> <p><pre><code>nml_int = '123'\npython_int = nml.NMLReader.read_nml_int(nml_int)\nprint(python_int)\nprint(type(python_int))\n</code></pre> <pre><code>123\n&lt;class 'int'&gt;\n</code></pre></p> <p><pre><code>nml_float = '1.23'\npython_float = nml.NMLReader.read_nml_float(nml_float)\nprint(python_float)\nprint(type(python_float))\n</code></pre> <pre><code>1.23\n&lt;class 'float'&gt;\n</code></pre></p> <p><pre><code>nml_bool = '.true.'\npython_bool = nml.NMLReader.read_nml_bool(nml_bool)\nprint(python_bool)\nprint(type(python_bool))\n</code></pre> <pre><code>True\n&lt;class 'bool'&gt;\n</code></pre></p> <p><pre><code>nml_list = '1,2,3'\npython_list = nml.NMLReader.read_nml_list(\n    nml_list,\n    nml.NMLReader.read_nml_int\n)\nprint(python_list)\nprint(type(python_list))\n</code></pre> <pre><code>[1, 2, 3]\n&lt;class 'list'&gt;\n</code></pre></p> <p>To read the tracer block, we need to create a nested dictionary that tells <code>NMLReader</code> which static methods to use:</p> <pre><code>nml_conversion_dict = {\n    \"aed_tracer\": {\n        \"retention_time\": nml.NMLReader.read_nml_bool,\n        \"num_tracers\":  nml.NMLReader.read_nml_int,\n        \"decay\": lambda x: nml.NMLReader.read_nml_list(\n            x,\n            nml.NMLReader.read_nml_int\n        ),\n        \"Fsed\": lambda x: nml.NMLReader.read_nml_list(\n            x,\n            nml.NMLReader.read_nml_int\n        )\n    }\n}\n</code></pre> <p>This can be passed to <code>NMLReader</code> by calling the <code>set_converters</code> method. Calling <code>get_nml</code> will now return a dictionary of the NML file with Python data types:</p> <p><pre><code>aed_nml = nml.NMLReader(\"aed.nml\")\naed_nml.set_converters(nml_conversion_dict)\nnml_dict = aed_nml.get_nml()\nprint(nml_dict)\n</code></pre> <pre><code>{'aed_tracer': {'retention_time': True, 'num_tracers': 1, 'decay': [0, 0], 'Fsed': [0, 0]}}\n</code></pre></p>"},{"location":"how_to/how-to-outflows/","title":"How-to: <code>outflows</code> module","text":""},{"location":"how_to/how-to-outflows/#writing-an-outflows-csv","title":"Writing an outflows CSV","text":"<p>The  <code>CustomOutflows</code>  class supports the creation of outflow CSV files. It  provides a wrapper around the <code>pandas.DataFrame</code> object and converts outflows set in units of m<sup>3</sup>/day, or m<sup>3</sup>/hour, to  m<sup>3</sup>/second.</p>"},{"location":"how_to/how-to-outflows/#creating-the-outflows-dataframe","title":"Creating the outflows DataFrame","text":"<p>To create an outflows CSV, import the outflows module and initalise the <code>CustomOutflows</code> class. The duration of the timeseries is set with the  <code>start_datetime</code> and <code>end_datetime</code> attributes. These attributes can be  provided in the form of a <code>pandas.Timestamp</code>, <code>datetime.datetime</code>, or a valid datetime string. Make sure your <code>start_datetime</code> and <code>end_datetime</code> match the  <code>start</code> and <code>stop</code> parameters used to configure <code>&amp;time</code> block with  <code>NMLTime</code>. Outflows can be defined at an hourly  (<code>1h</code>) or daily frequency (<code>24h</code>) with the <code>frequency</code> attribute. An optional  <code>base_outflow</code> attribute can be used to set a constant outflow. The input units  of <code>base_outflow</code> will be in either m<sup>3</sup>/day or m<sup>3</sup>/hour  depending on the <code>frequency</code> you set.</p> <pre><code>from glmpy import outflows\n\nmy_outflows = outflows.CustomOutflows(\n    start_datetime=\"2020-01-01\",\n    end_datetime=\"2020-01-10\",\n    frequency=\"24h\",\n    base_outflow = 0.0\n)\n</code></pre>"},{"location":"how_to/how-to-outflows/#set-outflows-for-specific-dates","title":"Set outflows for specific dates","text":"<p>By default, the <code>CustomOutflows</code> class will have a constant outflow rate for  the entire simulation period. To set outflows for specific dates, use the  <code>set_on_datetime()</code>  method and provide a dictionary with dates (as keys) and outflows (as values):</p> <pre><code>outflows_dict = {\n    \"2020-01-02\": 2, # 2m^3/day\n    \"2020-01-03\": 4, # 4m^3/day\n    \"2020-01-04\": 6 # 6m^3/day\n}\nmy_outflows.set_on_datetime(outflows_dict)\n</code></pre>"},{"location":"how_to/how-to-outflows/#return-the-outflow-dataframe","title":"Return the outflow DataFrame","text":"<p>To return the <code>pandas.DataFrame</code> of outflows, use the  <code>get_outflows()</code>  method:</p> <pre><code>outflows_dataframe = my_outflows.get_outflows()\nprint(outflows_dataframe)\n</code></pre> <pre><code>        time      flow\n0 2020-01-01  0.000000\n1 2020-01-02  0.000023\n2 2020-01-03  0.000046\n3 2020-01-04  0.000069\n4 2020-01-05  0.000000\n5 2020-01-06  0.000000\n6 2020-01-07  0.000000\n7 2020-01-08  0.000000\n8 2020-01-09  0.000000\n9 2020-01-10  0.000000\n</code></pre>"},{"location":"how_to/how-to-outflows/#set-outflows-over-a-date-range","title":"Set outflows over a date range","text":"<p>Constant outflows can be set over a date range with the  <code>set_over_datetime()</code>  method:</p> <pre><code>outflows.set_over_datetime(\n    from_datetime=\"2020-01-05\",\n    to_datetime = \"2020-01-09\",\n    outflow = 5 # 5m^3/day\n)\n\noutflows_dataframe = my_outflows.get_outflows()\n\nprint(outflows_dataframe)\n</code></pre> <pre><code>        time      flow\n0 2020-01-01  0.000000\n1 2020-01-02  0.000023\n2 2020-01-03  0.000046\n3 2020-01-04  0.000069\n4 2020-01-05  0.000058\n5 2020-01-06  0.000058\n6 2020-01-07  0.000058\n7 2020-01-08  0.000058\n8 2020-01-09  0.000058\n9 2020-01-10  0.000000\n</code></pre>"},{"location":"how_to/how-to-outflows/#writing-the-outflows-file","title":"Writing the outflows file","text":"<p>Once the outflows have been defined, they can be saved as a CSV with the  <code>write_outflows()</code>  method:</p> <pre><code>outflows.write_outflows(file_path=\"outflows.csv\")\n</code></pre>"},{"location":"how_to/how-to-plots/","title":"How-to: <code>plots</code> module","text":"<p>The <code>plots</code> module of glm-py has been implemented to follow the recommended  signature function for wrapping the Matplotlib library:</p> <pre><code>def my_plotter(ax, data, param_dict):\n    \"\"\"\n    A helper function to make a graph.\n    \"\"\"\n    out = ax.plot(data, **param_dict)\n    return out\n</code></pre> <p>Where <code>ax</code> is a matplotlib <code>Axes</code> object, <code>data</code> is the data to  plot, and <code>param_dict</code> is a dictionary of parameters that configure the wrapped <code>plot</code> method. This approach leaves the figure and axes creation to the user  and avoids adding unnecessary complexity to the wrapping method/function. See example use below:</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\n\n# Creates two arrays of random data\ndata1, data2 = np.random.randn(2, 25)  \n# Creates two subplots (the `Axes` object) and the enclosing `Figure` object\nfig, axs = plt.subplots(1, 2, figsize=(10, 2.7))\n# Plots data1 to the first axes with 'x' markers\nmy_plotter(axs[0], data1, {'marker': 'x'})\n# Plots data2 to the second axes with 'o' markers\nmy_plotter(axs[1], data2, {'marker': 'o'})\n</code></pre> <p> </p> <p>glm-py's implementation differs slightly by abstracting away the <code>data</code>  parameter of the plotting methods. This removes the need for the user to read and post-process GLM's output files when creating common plots. At most, the  user may need to provide a GLM variable name as a string, e.g., when using the <code>NCProfile.plot_var</code> method.</p>"},{"location":"how_to/how-to-plots/#run-the-sparkling-example-simulation","title":"Run the Sparkling example simulation","text":"<p>Before any GLM plots can be made, a simulation must first be run to create the output files.  For this how-to, the Sparkling simulation will be used. glm-py's <code>example_sims.sparkling</code> sub-module provides a convient function for running the simulation:</p> <p><pre><code>from glmpy.example_sims import sparkling\n\nsparkling.run_sim()\n</code></pre> Once the Sparkling simulation has run, glm-py will write output files to <code>sparkling/output</code>. Within this sub-directory are the <code>lake.csv</code> and <code>output.nc</code> files that can be visualised with the <code>plots</code> module.</p>"},{"location":"how_to/how-to-plots/#lakecsv-plots-with-lakeplotter","title":"<code>lake.csv</code> plots with <code>LakePlotter</code>","text":"<p>The <code>plots</code> module's <code>LakePlotter</code> class provides the following methods for plotting different aspects of the <code>lake.csv</code> file:</p> <ul> <li><code>lake_volume</code></li> <li><code>lake_level</code></li> <li><code>lake_surface_area</code></li> <li><code>lake_temp</code></li> <li><code>surface_temp</code></li> <li><code>water_balance</code></li> <li><code>water_balance_components</code></li> <li><code>heat_balance_components</code></li> </ul> <p>To use one of these methods, first initialise <code>LakePlotter</code> with the path to  the <code>lake.csv</code> file:</p> <pre><code>from glmpy import plots\n\nlake = plots.LakePlotter(\"sparkling/output/lake.csv\")\n</code></pre> <p>Next, create the matplotlib <code>Figure</code> (<code>fig</code>) and <code>Axes</code> (<code>ax</code>) objects and pass the  <code>Axes</code> object to the desired plot method. Here, the lake volume is plotted:</p> <pre><code>fig, ax = plt.subplots(figsize=(10, 5))\nlake.lake_volume(ax=ax)\n</code></pre> <p> </p> <p>Plots created by <code>LakePlotter</code> can be easily customised using the <code>param_dict</code> parameter and the various setter/getter methods of the <code>Figure</code> and <code>Axes</code> objects. Below, the lake water balance is plotted with a different line colour and tick label formatter:  </p> <pre><code>import matplotlib.dates as mdates\n\n# Create a new date formatter\ndate_formatter = mdates.DateFormatter(\"%b %Y\")\n\nfig, ax = plt.subplots(figsize=(10, 5))\n# Change the line colour\nlake.water_balance(ax=ax, param_dict={\"color\": \"tomato\"})\n\n# Set the new date formatter\nax.xaxis.set_major_formatter(date_formatter)\n</code></pre> <p> </p> <p><code>LakePlotter</code> also provides two methods, <code>water_balance_components</code> and <code>heat_balance_components</code>, that plot multiple lines to the axes. Each line has its own <code>param_dict</code> parameter that, when set to <code>None</code>, removes the line from the plot. For example, the plot below turns off all but the rain and evaporation lines:</p> <pre><code>fig, ax = plt.subplots(figsize=(10, 5))\nout = lake.water_balance_components(\n    ax=ax, \n    rain_params={\"linestyle\": \"--\"},\n    local_runoff_params=None, \n    overflow_vol_params=None,\n    snowfall_params=None\n)\nax.legend(handles=out)\n</code></pre> <p> </p> <p>The following example shows how <code>LakePlotter</code> can be easily used to populate a grid of subplots. Create the grid by setting the <code>nrows</code>/<code>ncols</code> parameters of  <code>plt.subplots</code> and then call the desired plot method for each axes.</p> <pre><code>fig, ax = plt.subplots(2, 2, figsize=(15, 15))\ndate_formatter = mdates.DateFormatter(\"%m/%y\")\n\nout = lake.water_balance(ax=ax[0, 0])\nax[0, 0].xaxis.set_major_formatter(date_formatter)\nout = lake.water_balance_components(\n    ax=ax[0,1], \n    local_runoff_params=None, \n    overflow_vol_params=None,\n    snowfall_params=None\n)\nax[0, 1].legend(handles=out, ncols=2, loc=0)\nax[0, 1].xaxis.set_major_formatter(date_formatter)\nout = lake.lake_temp(ax[1, 0])\nax[1, 0].legend(handles=out, ncols=2, loc=0)\nax[1, 0].xaxis.set_major_formatter(date_formatter)\nout = lake.heat_balance_components(ax[1, 1])\nax[1, 1].legend(handles=out, ncols=2, loc=0)\nax[1, 1].xaxis.set_major_formatter(date_formatter)\n</code></pre> <p> </p>"},{"location":"how_to/how-to-plots/#outputnc-profile-plots-with-ncprofile","title":"<code>output.nc</code> profile plots with <code>NCProfile</code>","text":"<p>The <code>NCProfile</code> class of the <code>plots</code> module can be used plot a variable for all depths and timesteps of the simulation. This class is initialised by providing a path to the <code>output.nc</code> NetCDF file:</p> <pre><code>nc = plots.NCProfile(\"sparkling/output/output.nc\")\n</code></pre> <p><code>NCProfile</code>'s <code>plot_var</code> method will plot all 3-D variables from the NetCDF file onto an <code>Axes</code> object. Below, the lake temperature  (<code>\"temp\"</code> in the NetCDF) is plotted:</p> <pre><code>fig, ax = plt.subplots(figsize=(10, 5))\nnc.plot_var(ax=ax, var=\"temp\")\n</code></pre> <p> </p> <p>To add a colour bar, the <code>AxesImage</code> object returned by <code>plot_var</code> can be  passed to the <code>colorbar</code> method of the figure object:</p> <pre><code>fig, ax = plt.subplots(figsize=(10, 5))\nout = nc.plot_var(ax=ax, var=\"temp\")\ncol_bar = fig.colorbar(out)\ncol_bar.set_label(\"Temperature (\u00b0C)\")\n</code></pre> <p> </p> <p>By default, <code>plot_var</code> will measure the lake depth from the bottom  (<code>reference=\"bottom\"</code>) as this provides the most realistic representation of  fluctuating surface levels. To reference lake depth from the surface, set the  <code>reference</code> to <code>\"surface\"</code>:</p> <pre><code>fig, ax = plt.subplots(figsize=(10, 5))\nout = nc.plot_var(ax=ax, var=\"temp\", reference=\"surface\")\ncol_bar = fig.colorbar(out)\ncol_bar.set_label(\"Temperature (\u00b0C)\")\n</code></pre> <p> </p> <p><code>plot_var</code> wraps matplotlib's <code>imshow</code> method. Just like the methods of  <code>LakePlotter</code>, you can customise how <code>plot_var</code> plots by passing a dictionary  of <code>imshow</code> parameters to the <code>param_dict</code> parameter. Here, a profile plot  of the lake salinity is created with the colour map changed to <code>\"viridis\"</code>:</p> <pre><code>fig, ax = plt.subplots(figsize=(10, 5))\nparams = {\"cmap\": \"viridis\"}\nout = nc.plot_var(ax=ax, var=\"salt\", param_dict=params)\ncol_bar = fig.colorbar(out)\ncol_bar.set_label(\"Salinity (g/kg)\")\ntype(out)\n</code></pre> <p> </p> <p>Finally, <code>NCProfile</code> also provides methods to assist with automating the  plotting of variables:</p> <ul> <li><code>get_vars</code> returns a list of variables that can be plotted with <code>plot_var</code></li> <li><code>get_long_name</code> returns the unabbreviated name of a variable</li> <li><code>get_units</code> returns the units of a variable</li> </ul> <p><pre><code>vars = nc.get_vars()\nprint(vars)\n</code></pre> <pre><code>['z', 'H', 'V', 'salt', 'temp', 'dens', 'radn', 'extc', 'umean', 'uorb', 'taub']\n</code></pre> <pre><code>[nc.get_long_name(var) for var in vars[3:5]]\n</code></pre> <pre><code>['salinity', 'temperature']\n</code></pre> <pre><code>[nc.get_units(var) for var in vars[3:5]]\n</code></pre> <pre><code>['g/kg', 'celsius']\n</code></pre></p> <pre><code>plot_vars = vars[3:5]\nfig, axs = plt.subplots(nrows=2, ncols=1, figsize=(10, 10))\nfor idx, var, in enumerate(plot_vars):\n    out = nc.plot_var(axs[idx], var)\n    long_name = nc.get_long_name(var)\n    units = nc.get_units(var)\n    col_bar = fig.colorbar(out)\n    col_bar.set_label(f\"{long_name} ({units})\")\n</code></pre> <p> </p>"},{"location":"release_notes/","title":"Release Notes","text":""},{"location":"release_notes/#glm-py","title":"glm-py","text":""},{"location":"release_notes/#0.4.0","title":"0.4.0 (17 January, 2025)","text":"<ul> <li>Added <code>restart_variables</code> to <code>InitProfilesBlock</code>,  <code>NMLReader._default_converters</code>, and <code>NMLWriter._default_converters</code></li> <li>Added <code>subm_elev</code> to <code>InflowBlock</code>,  <code>NMLReader._default_converters</code>, and <code>NMLWriter._default_converters</code></li> <li>Added <code>list_len</code> parameter to <code>NMLWriter.write_nml_list</code> which inserts line  breaks to the comma-separated output after a specified number of items.  <code>list_len</code> parameter also added to <code>NMLWriter</code> and <code>GLMNML</code>.</li> <li>Removed <code>NMLWriter.write_nml_array</code> and <code>NMLReader.read_nml_array</code>. Usage  replaced in <code>glm_nml</code> and <code>nml</code> modules with  <code>NMLWriter.write_nml_list</code>/<code>NMLReader.read_nml_list</code></li> </ul>"},{"location":"release_notes/#0.3.1","title":"0.3.1 (13 December, 2024)","text":"<ul> <li>Added a <code>plots</code> module for visualising GLM's output files with Matplotlib</li> <li><code>LakePlotter</code> class for plotting the <code>lake.csv</code> file</li> <li><code>NCProfile</code> class for plotting a timeseries profile of variables in the      <code>output.nc</code> file</li> <li><code>matplotlib</code> and <code>netcdf4</code> dependencies added</li> <li>Added a how-to documentation page for the <code>plots</code> module</li> <li>Added a <code>example_sims.sparkling</code> sub-module for running the Sparkling Lake simulation</li> <li><code>load_nml</code> function for returning a dictionary of the Sparkling NML</li> <li><code>load_bcs</code> function for returning a pandas dataframe of the boundary    condition data</li> <li><code>run_sim</code> function for running the Sparkling simulation</li> <li>Added <code>InvertedTruncatedPyramid</code> class to the <code>dimensions</code> module</li> <li>Deprecation warning added to <code>InvertedTruncatedSquarePyramid</code></li> </ul>"},{"location":"release_notes/#0.2.0","title":"0.2.0 (24 June, 2024)","text":"<ul> <li>The <code>nml</code> module has been split into <code>nml</code> and <code>glm_nml</code> sub-modules.</li> <li>The <code>glm_nml</code> sub-module provides high-level NML tools and implements all the  existing classes from the <code>nml</code> module in <code>0.1.3</code>.</li> <li>Classes from <code>0.1.3</code> are automatically imported using    <code>from glmpy import nml</code> to maintain backwards compatibility until <code>1.0.0</code>.</li> <li>Class names from <code>0.1.3</code> will be deprecated by <code>1.0.0</code> in favour of a new    naming convention that ensures forwards compatibility with AED. Warnings are    raised to encourage you to migrate to the new class names.</li> <li>The new <code>nml</code> sub-module provides low-level tools for reading and writing any NML file (GLM or AED).</li> <li><code>NMLWriter</code> converts a nested Python dictionary to an NML file. </li> <li><code>NMLReader</code> converts an NML file to a nested Python dictionary. </li> <li>Both classes provide functionality to explicitly control how each parameter   is read/written to file.</li> <li><code>InvertedTruncatedCone</code> class added to the <code>dimensions</code> module to calculate morphometry parameters for simple circular water bodies.</li> </ul>"},{"location":"release_notes/#0.1.3","title":"0.1.3 (22 March, 2024)","text":"<ul> <li>glm-py released! \ud83d\ude80</li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/2024/06/24/modelling-sparkling-lake-with-glm-py/","title":"Modelling Sparkling Lake with glm-py","text":"<p>This tutorial guides users through the process of setting up a model of  Sparkling Lake using glm-py.</p> <p> </p> <p>Sparkling Lake is an oligotrophic, northern temperate lake (89.7 \u00baN, 46.3 \u00baW) in Winconsin, USA. The lake is approximately 20m deep and covers a surface area of 0.638km<sup>2</sup>. This tutorial serves an introduction to the two core modules of glm-py - <code>nml</code> and <code>simulation</code>. You will use glm-py to model Sparkling Lake for 2 years (1980-04-15 to 1982-04-15).</p> <p>First, install glm-py using <code>pip</code>:</p> <pre><code>pip install glm-py\n</code></pre>"},{"location":"tutorials/2024/06/24/modelling-sparkling-lake-with-glm-py/#creating-a-glm-nml-file","title":"Creating a GLM NML file","text":"<p>Next, import the <code>glm_nml</code> sub-module from the <code>nml</code> module of <code>glmpy</code>:</p> <pre><code>from glmpy.nml import glm_nml\n</code></pre> <p>The <code>glm_nml</code> module provides a set of classes to construct GLM's NML file (<code>.nml</code>).  A NML file is divided into multiple \"blocks\" that configure specific aspects of the model, e.g., the <code>morphometry</code> block defines morphometry of the water body. The structure of a NML file is shown below for the four minimum required blocks (<code>...</code> indicates that the block contains more parameters than shown):</p> <pre><code>&amp;glm_setup\n  sim_name = 'GLMSimulation'\n  ...\n/\n&amp;morphometry\n  lake_name = 'my_lake'\n  ...\n/\n&amp;time\n  timefmt = 3\n  ...\n/\n&amp;init_profiles\n  lake_depth = 10\n  ...\n/\n</code></pre>"},{"location":"tutorials/2024/06/24/modelling-sparkling-lake-with-glm-py/#model-setup","title":"Model setup","text":"<p>GLM simulates the dynamics of a water body by dividing it into a vertically stacked series of layers. The compulsory <code>glm_setup</code> block defines the structure of these layers, e.g., the maximum number of layers, the minimum layer volume, and the minimum and maximum layer thicknesses. To configure the <code>glm_setup</code> parameters for Sparkling Lake, you would typically write a NML file that contains the following:</p> <pre><code>&amp;glm_setup \n   sim_name = 'Sparkling Lake'\n   max_layers = 500\n   min_layer_vol = 0.5\n   min_layer_thick = 0.15\n   max_layer_thick = 0.5\n   density_model = 1\n   non_avg = .true.\n/\n</code></pre> <p>Using glm-py, you instead configure the <code>glm_setup</code> block by using the <code>SetupBlock</code> class from the <code>glm_nml</code> module. Each model parameter of the <code>glm_setup</code> block has a corresponding attribute in the <code>SetupBlock</code> class:</p> <pre><code>glm_setup = glm_nml.SetupBlock(\n    sim_name='Sparkling Lake',\n    max_layers=500,\n    min_layer_vol=0.5,\n    min_layer_thick=0.15,\n    max_layer_thick=0.5,\n    density_model=1,\n    non_avg=True\n)\n</code></pre> <p>This approach offers a number of advantages over editing a raw NML file:</p> <ul> <li>Explicit type hinting for parameter types</li> <li>Native Python syntax</li> <li>Error checking</li> </ul> <p>Once the attributes are set, you can return a dictionary of the consolidated model parameters by calling the <code>get_params</code> method:</p> <pre><code>glm_setup_params = glm_setup.get_params()\nprint(glm_setup_params)\n</code></pre> <pre><code>{'sim_name': 'Sparkling Lake', 'max_layers': 500, 'min_layer_vol': 0.5, 'min_layer_thick': 0.15, 'max_layer_thick': 0.5, 'density_model': 1, 'non_avg': True}\n</code></pre>"},{"location":"tutorials/2024/06/24/modelling-sparkling-lake-with-glm-py/#mixing-and-morphometry","title":"Mixing and morphometry","text":"<p>Next, let's set the parameters that control the mixing processes within Sparkling Lake. Just as <code>SetupBlock</code> defines the <code>glm_setup</code> block, we can configure the <code>mixing</code> block using the <code>MixingBlock</code> class:</p> <pre><code>mixing = glm_nml.MixingBlock(\n    surface_mixing=1,\n    coef_mix_conv=0.2,\n    coef_wind_stir=0.402,\n    coef_mix_shear=0.2,\n    coef_mix_turb=0.51,\n    coef_mix_KH=0.3,\n    deep_mixing=2,\n    coef_mix_hyp=0.5,\n    diff=0.0\n)\n</code></pre> <p>Let's repeat the same for the <code>morphometry</code> block - use the <code>MorphometryBlock</code> class:</p> <pre><code>morphometry = glm_nml.MorphometryBlock(\n    lake_name='Sparkling',\n    latitude=46.00881,\n    longitude=-89.69953,\n    bsn_len=901.0385,\n    bsn_wid=901.0385,\n    crest_elev=320.0,\n    bsn_vals=15,\n    H=[301.712, 303.018285714286, 304.324571428571,\n        305.630857142857, 306.937142857143, 308.243428571429,\n        309.549714285714, 310.856, 312.162285714286,\n        313.468571428571, 314.774857142857, 316.081142857143,\n        317.387428571429, 318.693714285714, 320, 321],\n    A=[0, 45545.8263571429, 91091.6527142857,\n        136637.479071429, 182183.305428571, 227729.131785714,\n        273274.958142857, 318820.7845, 364366.610857143,\n        409912.437214286, 455458.263571429, 501004.089928571,\n        546549.916285714, 592095.742642857, 637641.569, 687641.569]\n)\n</code></pre>"},{"location":"tutorials/2024/06/24/modelling-sparkling-lake-with-glm-py/#setting-the-remaining-blocks","title":"Setting the remaining blocks","text":"<p>There are up to 14 configurable blocks in the GLM NML file - setting each will take some time! Let's speed up the process by reading the remaining blocks from an existing NML file. Download the NML file to your working directory using <code>curl</code>:</p> <pre><code>!curl https://raw.githubusercontent.com/AquaticEcoDynamics/glm-py/main/notebooks/glmpy-demo/glm3.nml --output sparkling_lake.nml\n</code></pre> <p>To read <code>sparkling_lake.nml</code>, we'll use the <code>NMLReader</code> class from the <code>nml.nml</code> sub-module. After importing the sub-module, initalise the <code>NMLReader</code> class and provide the NML file path:</p> <p><pre><code>from glmpy.nml import nml\n\nmy_nml_file = nml.NMLReader(\"sparkling_lake.nml\")\n</code></pre> Next, let's extract the parameters for the <code>meteorology</code> block using the <code>get_block</code> method:</p> <pre><code>meteorology_params = my_nml_file.get_block(\"meteorology\")\n</code></pre> <p>Take a look at what <code>meteorology_params</code> contains:</p> <pre><code>print(meteorology_attrs)\n</code></pre> <pre><code>{'met_sw': True, 'lw_type': 'LW_IN', 'rain_sw': False, 'atm_stab': 0, 'catchrain': False, 'rad_mode': 1, 'albedo_mode': 1, 'cloud_mode': 4, 'fetch_mode': 0, 'subdaily': False, 'meteo_fl': 'bcs/nldas_driver.csv', 'wind_factor': 1.0, 'sw_factor': 1.08, 'lw_factor': 1.0, 'at_factor': 1.0, 'rh_factor': 1.0, 'rain_factor': 1.0, 'ce': 0.00132, 'ch': 0.0014, 'cd': 0.0013, 'rain_threshold': 0.01, 'runoff_coef': 0.3}\n</code></pre> <p>This is a dictionary containing all <code>meteorology</code> parameters from <code>sparkling_lake.nml</code> in Python data types. Look closely at the <code>meteo_fl</code> parameter - what's <code>bcs/nldas_driver.csv</code>? This is a path to a CSV that contains boundary condition data for Sparkling Lake, e.g., daily rainfall, wind speed, and air temperature. You'll need this file to run the model. Let's download it with <code>curl</code> and place it in sub-directory called <code>bcs</code>:</p> <pre><code>!mkdir bcs\n!curl https://raw.githubusercontent.com/AquaticEcoDynamics/glm-py/main/notebooks/glmpy-demo/bcs/nldas_driver.csv --output bcs/nldas_driver.csv\n</code></pre> <p>Now, let's get the parameters for the remaining blocks:  <code>output</code>, <code>init_profiles</code>, <code>time</code>, <code>bird_model</code>, <code>light</code>, <code>sediment</code>. We'll use the <code>get_block</code> method from our instance of <code>NMLReader</code>:</p> <pre><code>output_params=my_nml_file.get_block(\"output\")\ninit_profiles_params=my_nml_file.get_block(\"init_profiles\")\ntime_params=my_nml_file.get_block(\"time\")\nlight_params=my_nml_file.get_block(\"light\")\nbird_model_params=my_nml_file.get_block(\"bird_model\")\nsediment_params=my_nml_file.get_block(\"sediment\")\n</code></pre>"},{"location":"tutorials/2024/06/24/modelling-sparkling-lake-with-glm-py/#writing-the-nml-file","title":"Writing the NML file","text":"<p>We now have a dictionary of model parameters for each block. Let's combine them to create the NML file. First, create an instance of the <code>GLMNML</code> class from the <code>glm_nml</code> sub-module. Then pass in the dictionaries of parameters:</p> <pre><code>my_nml = glm_nml.GLMNML(\n  glm_setup=glm_setup.get_params(),\n  mixing=mixing.get_params(),\n  morphometry=morphometry.get_params(),\n  time=time_params,\n  output=output_params,\n  init_profiles=init_profiles_params,\n  meteorology=meteorology_params,\n  bird_model=bird_model_params,\n  light=light_params,\n  sediment=sediment_params\n)\n</code></pre> <p>Finally, use the <code>write_nml()</code> method to save the <code>.nml</code> to your working directory:</p> <pre><code>my_nml.write_nml(nml_file_path='glm3.nml')\n</code></pre>"},{"location":"tutorials/2024/06/24/modelling-sparkling-lake-with-glm-py/#running-the-model","title":"Running the model","text":"<p>Model configuration is now complete! To run our Sparkling Lake simulation, import the <code>simulation</code> module:</p> <pre><code>from glmpy import simulation\n</code></pre> <p>We now need to specify the location of any files that we'll use in the simulation. For Sparkling Lake, that's just your newly created <code>glm3.nml</code> and the meterological boundary condition file <code>nldas_driver.csv</code>. These will be defined in a dictionary where the key is the filename and the value is the file path:</p> <pre><code>files = {\n    \"glm3.nml\": \"glm3.nml\",\n    \"nldas_driver.csv\": \"bcs/nldas_driver.csv\"\n}\n</code></pre> <p>Now pass this dictionary to a new instance of the <code>GLMSim</code> class. <code>GLMSim</code> is used prepare a new directory of model inputs that we'll point GLM at . Set <code>api</code> to <code>False</code> to run the simulation locally and set <code>inputs_dir</code> to the name of the inputs directory that will be created:</p> <pre><code>glm_sim = simulation.GLMSim(\n  input_files=files,\n  api=False,\n  inputs_dir=\"inputs\"\n)\n</code></pre> <p>Create the <code>inputs</code> directory by calling the <code>.prepare_inputs()</code> method:</p> <pre><code>inputs_dir = glm_sim.prepare_inputs()\n</code></pre> <p>You should now have a new directory that looks like this:</p> <pre><code>\u251c\u2500\u2500 bcs\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 nldas_driver.csv\n\u251c\u2500\u2500 glm3.nml\n</code></pre> <p>Finally, run the simulation by calling the <code>.glm_run()</code> method and pass in the <code>inputs_dir</code> object:</p> <pre><code>glm_sim.glm_run(inputs_dir=inputs_dir)\n</code></pre> <p>Congratulations! You've now configured and run a GLM simulation entirely in Python. You should see a new sub-directory called <code>outputs</code> within the <code>inputs</code> directory that contains the model results.</p>"},{"location":"tutorials/archive/2024/","title":"2024","text":""}]}