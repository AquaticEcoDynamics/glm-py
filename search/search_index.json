{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"glm-py","text":"<p>Python tools for running General Lake Model (GLM) simulations.</p>"},{"location":"#glm","title":"GLM","text":"<p>GLM is a 1-dimensional lake water balance and stratification model. It can also be coupled with a powerful ecological modelling library to support simulations of lake water quality and ecosystem processes.</p> <p>GLM is suitable for a wide range of natural and engineered lakes, including shallow (well-mixed) and deep (stratified) systems. The model has been successfully applied to systems from the scale of individual ponds and wetlands to the scale of Great Lakes.</p> <p>For more information about running GLM, please see the model website's scientific basis description and the GLM workbook. </p> <p>The GLM model is available as an executable for Linux (Ubuntu), MacOS, and Windows. It is actively developed by the  Aquatic EcoDynamics research group at The University of Western Australia.</p>"},{"location":"#why-glm-py","title":"Why glm-py?","text":"<p>glm-py provides a series of classes, functions, and data structures that support running GLM simulations, preparing model input data and configurations, and processing model outputs. </p> <p>Its goal is to make running and deploying GLM in a range of environments easy, e.g., building APIs for web applications or cloud services that use GLM, running batches of GLM simulations on HPCs, and running GLM simulations locally within Python environments such as JupyterLab or QGIS. </p>"},{"location":"#nml","title":"NML","text":"<p>Classes that store model parameters and methods that generate <code>.nml</code> configuration files for running GLM. </p>"},{"location":"#dimensions","title":"Dimensions","text":"<p>Turns simple user descriptions of lake geometries and dimensions into appropriate morphometry parameters.</p>"},{"location":"#glm_json","title":"GLM_JSON","text":"<p>Tools to convert JSON data to <code>.nml</code> format data. Useful for handling client requests if GLM is deployed within a web API / REST API.</p>"},{"location":"#simulation","title":"Simulation","text":"<p>Classes to handle running GLM simulations and processing output data into CSV, JSON, NetCDF files, or generating a JSON stream to pass onto clients. </p>"},{"location":"development/","title":"Development setup","text":""},{"location":"development/#environment","title":"Environment","text":"<p>A Docker container can be used to create a development environment. You can either build the Docker image:</p> <p><pre><code>docker build -t glmpy-dev .devcontainer\n</code></pre> Or, you can develop glmpy using a dev container. </p>"},{"location":"development/#code-style","title":"Code style","text":"<p>Code linting and formatting uses ruff and black. A script to format the glm-met repository can be run: <code>./scripts/format.sh</code>. </p> <p>pre-commit is used to run ruff and black. </p>"},{"location":"development/#tests","title":"Tests","text":"<p>pytest is used for testing glm-py. </p> <p>If testing, please add tests under the <code>tests</code> directory. If you need test data for running tests, add them as <code>pytest.fixtures</code> in <code>conftest.py</code>. </p>"},{"location":"development/#docs","title":"Docs","text":"<p>Build the docs (from the package root): </p> <pre><code>mkdocs serve \n</code></pre>"},{"location":"development/#build-package","title":"Build package","text":"<pre><code>python -m build\n</code></pre>"},{"location":"development/#release-to-pypi","title":"Release to PyPI","text":"<p>Use semantic versioning, versioneer, GitHub Actions workflows. Push to GitHub with a <code>vX.X.X</code> tag to trigger a the <code>build-and-deploy.yml</code> workflow.</p> <p><code>build-and-deploy.yml</code> will build glm-py and push the new release to PyPI. </p> <p>To use versioneer:</p> <pre><code>pip install versioneer\n</code></pre> <p>Then add the following to <code>pyproject.toml</code>:</p> <pre><code>[build-system]\nrequires = [\"setuptools&gt;=61.0.0\", \"versioneer[toml]\"]\nbuild-backend = \"setuptools.build_meta\"\n</code></pre> <p>and</p> <pre><code># See the docstring in versioneer.py for instructions. Note that you must\n# re-run 'versioneer.py setup' after changing this section, and commit the\n# resulting files.\n\n[tool.versioneer]\nVCS = \"git\"\nstyle = \"pep440\"\nversionfile_source = \"glmpy/_version.py\"\nversionfile_build = \"glmpy/_version.py\"\ntag_prefix = \"v\"\nparentdir_prefix = \"glmpy-\"\n</code></pre> <p>and</p> <pre><code>[project.optional-dependencies]\ntoml = [\"tomli; python_version &lt; '3.11'\"]\n</code></pre> <p>Create <code>setup.py</code>:</p> <pre><code>touch setup.py\n</code></pre> <p>and add the following to <code>setup.py</code>:</p> <pre><code>from setuptools import setup\n\nimport versioneer\n\n# see pyproject.toml for static project metadata\nsetup(\n    version=versioneer.get_version(),\n    cmdclass=versioneer.get_cmdclass(),\n)\n</code></pre> <p>Run:</p> <pre><code>versioneer install --vendor\n</code></pre>"},{"location":"development/#code-style_1","title":"Code style","text":"<ul> <li>Format all code using black (see <code>./scripts/format.sh</code>)</li> <li>Manually correct all ruff errors</li> <li>Use pre-commit to format Python code before git commits</li> <li>Use NumPy style docstrings - follow NumPy conventions</li> </ul>"},{"location":"development/#methods-function-docstring","title":"Methods / function docstring","text":"<p>Example from Pandas:</p> <ul> <li>Summary - one line function / method summary.</li> <li>Extended summary - one or two sentences outlining what the function achieves and when / where it is used.</li> <li>Parameter description - list function arguments, keywords, and types.</li> <li>Returns / yields section - list returns / yields from the function and their types.</li> <li>Notes - optional notes section.</li> <li>Examples - example to illustrate how the function can be used.</li> </ul> <pre><code>\"\"\"\nAdd up two integer numbers.\n\nThis function simply wraps the ``+`` operator, and does not\ndo anything interesting, except for illustrating what\nthe docstring of a very simple function looks like.\n\nParameters\n----------\nnum1 : int\n    First number to add.\nnum2 : int\n    Second number to add.\n\nReturns\n-------\nint\n    The sum of ``num1`` and ``num2``.\n\nSee Also\n--------\nsubtract : Subtract one integer from another.\n\nExamples\n--------\n&gt;&gt;&gt; add(2, 2)\n4\n&gt;&gt;&gt; add(25, 0)\n25\n&gt;&gt;&gt; add(10, -10)\n0\n\"\"\"\n</code></pre>"},{"location":"development/#class-docstring","title":"Class docstring","text":"<ul> <li>Summary - one line class summary.</li> <li>Extended summary - one or two sentences outlining the class purpose and use.</li> <li>Attributes description - list function arguments, keywords, and types.</li> <li>Example - short example indicating class usage.</li> <li>Notes - optional notes section</li> </ul> <p>Do not list methods - add docstrings to methods within the class. </p>"},{"location":"dimensions/","title":"Dimensions","text":""},{"location":"dimensions/#glmpy.dimensions.InvertedTruncatedSquarePyramid","title":"<code>InvertedTruncatedSquarePyramid</code>","text":"<p>Calculates the volume and surface area of an inverted truncated square  pyramid.</p> <p>Useful for calculating the <code>A</code> and <code>H</code> morphometry parameters for simple  water bodies such as on-farm reservoirs. Assumes only the height  (i.e., depth), side slope, and surface length of the water body are known. </p> <p>Attributes:</p> Name Type Description <code>height</code> <code>Union[float, int]</code> <p>Height of water body from the base to surface in metres.</p> <code>surface_length</code> <code>Union[float, int]</code> <p>Surface length of the water body in metres. Assumes surface width and  length are equal.</p> <code>num_vals</code> <code>int</code> <p>The number of values to be returned by the <code>get_volumes()</code>,  <code>get_surface_areas()</code>, and <code>get_heights()</code> methods. <code>num_vals</code> should  be the same as the <code>bsn_vals</code> parameter from the <code>&amp;morphometry</code>  configuration block (see <code>bsn_vals</code> in <code>nml.NMLMorphometry()</code>).</p> <code>side_slope</code> <code>Union[float, int]</code> <p>Side slope of water body - the rise over run (metre/metre). Default is  1/3.</p> <code>surface_elevation</code> <code>float</code> <p>Elevation at the water body surface. Shifts the values returned by <code>get_heights()</code> up or down. Default is 0.0.</p> <p>Examples:</p> <p>Import the <code>dimensions</code> and <code>nml</code> modules:</p> <pre><code>&gt;&gt;&gt; from glmpy import dimensions, nml\n</code></pre> <p>Consider a square on-farm reservoir (OFR) that is 40m long, 40m wide, 6m  deep, and has a side slope of 1/3:</p> <pre><code>&gt;&gt;&gt; ofr = dimensions.InvertedTruncatedSquarePyramid(\n...     height=6,\n...     surface_length=40,\n...     num_vals=7,\n...     side_slope=1/3,\n...     surface_elevation=0\n... )\n</code></pre> <p>Get a list of height values to use for the <code>H</code> parameter in the  <code>&amp;morphometry</code> configuration block. The length of the list is determined by the <code>num_vals</code> attribute:</p> <pre><code>&gt;&gt;&gt; print(ofr.get_heights())\n[-6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0]\n</code></pre> <p>Get the water surface area at each of these heights:</p> <pre><code>&gt;&gt;&gt; print(ofr.get_surface_areas())\n[16.0, 100.0, 256.0, 484.0, 784.0, 1156.0, 1600.0]\n</code></pre> <p>Get the volumes at each of these heights:</p> <pre><code>&gt;&gt;&gt; print(ofr.get_volumes())\n[0.0, 52.0, 224.0, 588.0, 1216.0, 2180.0, 3552.0]\n</code></pre> <p>Set the <code>A</code>, <code>H</code>, and <code>bsn_vals</code> attributes of <code>nml.NMLMorphometry()</code>:</p> <pre><code>&gt;&gt;&gt; morphometry = nml.NMLMorphometry(\n...     A=ofr.get_surface_areas(),\n...     H=ofr.get_heights(),\n...     bsn_vals=7\n... )\n</code></pre>"},{"location":"dimensions/#glmpy.dimensions.InvertedTruncatedSquarePyramid.get_heights","title":"<code>get_heights()</code>","text":"<p>Calculates heights.</p> <p>Returns a list of heights (m) from base to surface. The number of  heights is determined by the <code>num_vals</code> attribute. Heights can be  adjusted for different surface elevations by increasing or decreasing the <code>surface_elevation</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Name Type Description <code>heights</code> <code>list</code> <p>Heights (m) from base to surface.</p> <p>Examples:</p> <p>Get the height values for a water body that has a surface elevation of -3m:</p> <pre><code>&gt;&gt;&gt; from glmpy import dimensions\n&gt;&gt;&gt; ofr = dimensions.InvertedTruncatedSquarePyramid(\n...     height=6,\n...     surface_length=40,\n...     num_vals=7,\n...     side_slope=1/3,\n...     surface_elevation=-3\n... )\n&gt;&gt;&gt; print(ofr.get_heights())\n[-9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0]\n</code></pre>"},{"location":"dimensions/#glmpy.dimensions.InvertedTruncatedSquarePyramid.get_surface_areas","title":"<code>get_surface_areas()</code>","text":"<p>Calculates surface areas.</p> <p>Returns a list of surface areas (m^2) that correspond with the heights  returned by <code>get_heights()</code>. The length of the list is determined by  the <code>num_vals</code> attribute. Surface areas are returned as a list of  floats where the first item is the area at the bottom of the water body  and the last is the area at the surface.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Name Type Description <code>surface_areas</code> <code>list</code> <p>Surface areas of water body (m^2).</p> <p>Examples:</p> <p>Get a list of 7 surface areas at each height in <code>get_heights()</code>:</p> <pre><code>&gt;&gt;&gt; from glmpy import dimensions\n&gt;&gt;&gt; ofr = dimensions.InvertedTruncatedSquarePyramid(\n...     height=6,\n...     surface_length=40,\n...     num_vals=7,\n...     side_slope=1/3,\n...     surface_elevation=0\n... )\n&gt;&gt;&gt; print(ofr.get_heights())\n[-6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0]\n&gt;&gt;&gt; print(ofr.get_surface_areas())\n[16.0, 100.0, 256.0, 484.0, 784.0, 1156.0, 1600.0]\n</code></pre> <p>Get a list of 4 surface areas at each height in <code>get_heights()</code>:</p> <pre><code>&gt;&gt;&gt; ofr = dimensions.InvertedTruncatedSquarePyramid(\n...     height=6,\n...     surface_length=40,\n...     num_vals=4,\n...     side_slope=1/3\n... )\n&gt;&gt;&gt; print(ofr.get_heights())\n[-6.0, -4.0, -2.0, 0.0]\n&gt;&gt;&gt; print(ofr.get_surface_areas())\n[16.0, 256.0, 784.0, 1600.0]\n</code></pre>"},{"location":"dimensions/#glmpy.dimensions.InvertedTruncatedSquarePyramid.get_volumes","title":"<code>get_volumes()</code>","text":"<p>Calculates volumes.</p> <p>Returns a list of volumes (m^3) that correspond with the heights  returned by <code>get_heights()</code>. The length of the list is determined by  the <code>num_vals</code> attribute. Volumes are returned as a list of floats  where the first item is the volume at the bottom of the water body and  the last is the volume at the surface.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Name Type Description <code>volume</code> <code>list</code> <p>The water body volumes (m^3).</p> <p>Examples:</p> <p>Get a list of 7 volumes at each height in <code>get_heights()</code>:</p> <pre><code>&gt;&gt;&gt; from glmpy import dimensions\n&gt;&gt;&gt; ofr = dimensions.InvertedTruncatedSquarePyramid(\n...     height=6,\n...     surface_length=40,\n...     num_vals=7,\n...     side_slope=1/3,\n...     surface_elevation=0\n... )\n&gt;&gt;&gt; print(ofr.get_heights())\n[-6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0]\n&gt;&gt;&gt; print(ofr.get_volumes())\n[0.0, 52.0, 224.0, 588.0, 1216.0, 2180.0, 3552.0]\n</code></pre> <p>Get a list of 4 volumes at each height in <code>get_heights()</code>:</p> <pre><code>&gt;&gt;&gt; ofr = dimensions.InvertedTruncatedSquarePyramid(\n...     height=6,\n...     surface_length=40,\n...     num_vals=4,\n...     side_slope=1/3\n... )\n&gt;&gt;&gt; print(ofr.get_heights())\n[-6.0, -4.0, -2.0, 0.0]\n&gt;&gt;&gt; print(ofr.get_volumes())\n[0.0, 224.0, 1216.0, 3552.0]\n</code></pre>"},{"location":"farm-dam-tutorial/","title":"Tutorials","text":""},{"location":"farm-dam-tutorial/#farm-dam","title":"Farm Dam","text":""},{"location":"farm-dam-tutorial/#introduction","title":"Introduction","text":"<p>In this tutorial, you will use <code>glmpy</code> to construct a simple model of a farm dam in the Western Australian (WA) Wheatbelt. The WA Wheatbelt is a semi-arid agricultural region dominated by rain-fed cropping and livestock production. Farm dams play a crucial role in storing fresh water for irrigation and animal consumption during the dry summer months. Climate change is warming the Wheatbelt and increasingly disrupting the winter rainfall patterns that fill farm dams. When dams dry out, the impact to farmers and animals can be servere. Modelling the water balance of these small water bodies is important to minimise their risk of failure under a drying climate.</p> <p>In the map below, you can see the dam is connected to a large catchment area. These catchments are often constructed up-hill from the dam and consist of a compacted clay surface. This design increases runoff during rainfall events and channels the water into the dam. To accurately model the dam, we will need to incorporate the inflows from this catchment.</p>"},{"location":"farm-dam-tutorial/#model-setup","title":"Model setup","text":"<p>Let's start building the model. <code>glmpy</code> provides a set of classes in the <code>nml</code> module that can be used to construct the GLM namelist file (<code>.nml</code>). The <code>.nml</code> file is simply a text file that contains a set of parameters which configure the model. These parameters are grouped into different components that each configure different aspects of the model. For every component, there is a corresponding class in the <code>nml</code> module that you can use to construct the namelist file, e.g., the <code>NMLMeteorology</code> class configures the <code>&amp;meteorology</code> parameters. Go ahead and import the <code>nml</code> module:</p> <pre><code>from glmpy import nml\n</code></pre> <p>The first component we will configure is the <code>&amp;setup</code> component. These parameters control the model layers. GLM is a 1-D model that simulates a water body as a vertical series of layers. The number of layers, and their thickness, is dynamic. Layers will expand, contract, merge, and split in response to water and surface mass fluxes.  The <code>&amp;setup</code> component defines the initial state of these layers. The <code>NMLSetup</code> class constructor takes the following arguments:</p> <ul> <li><code>sim_name</code>: The name of your simulation</li> <li><code>max_layers</code>: The maximum number of layers that can be created during the simulation</li> <li><code>min_layer_vol</code>: The minimum volume of a layer in cubic metres</li> <li><code>min_layer_thick</code>: The minimum thickness of a layer in metres</li> <li><code>max_layer_thick</code>: The maximum thickness of a layer in metres</li> <li><code>density_model</code>: The equation used to calculate the density of water in each layer</li> <li><code>non_avg</code>: A flag to indicate whether the model should use non-averaged layers</li> </ul> <p>Let's initialise our model with a maximum of 100 layers. Each layer must contain at least 0.1 m<sup>3</sup> of water and range in thickness from 0.01-1.0 m. By setting <code>density_model</code> to 1, we'll use a model from TEOS-10 that calculates the density as a function of local temperature and salinity. Finally, we'll set <code>non_avg</code> to <code>True</code> to indicate that we want to use non-averaged layers.</p> <pre><code>setup = nml.NMLSetup(\n    sim_name='farm_dam',\n    max_layers=100,\n    min_layer_vol=0.1,\n    min_layer_thick=0.01,\n    max_layer_thick=1.0,\n    density_model=1,\n    non_avg=True\n)\n</code></pre>"},{"location":"farm-dam-tutorial/#model-duration","title":"Model duration","text":"<p>Our model will run over a 10 year period from 2010 to 2020 at an hourly timestep. The <code>&amp;time</code> component defines the start and stop time of the simulation, the time step, and the time zone. We can use <code>NMLTime</code> class constructor to configure these properties:</p> <pre><code>time = nml.NMLTime(\n    timefmt=2,\n    start=\"2010-01-01 00:00:00\",\n    stop=\"2020-12-31 00:00:00\",\n    dt=3600,\n    timezone=8\n)\n</code></pre> <p>Here, we have specified the <code>timefmt</code> as <code>2</code> which configures GLM to accept <code>start</code> and <code>stop</code> times. Alternatively, a <code>timefmt=3</code> allows GLM to read the <code>num_days</code> parameter. The <code>start</code> and <code>stop</code> times are specified as strings in the format <code>YYYY-MM-DD HH:MM:SS</code>. The <code>dt</code> parameter is the time step in seconds (3600 seconds in an hour). The <code>timezone</code> parameter is the time zone offset from UTC in hours.</p>"},{"location":"farm-dam-tutorial/#dam-morphometry","title":"Dam morphometry","text":"<p>Next, we'll define the dam morphometry, i.e., the physical dimensions that capture the shape of the water body. GLM records the morphometry of a water body by a list of height and surface area pairs. The heights are vertical distances from the bottom of the water body to the surface. Similarly, the surface areas are the horizontal area of the water body at the each height increment. The number of height/surface-area pairs you need to provide largely depends on how complex the morphometry is. For dams, the morphometry is simple. Most farm dams often resembles an truncated pyramid that has been inverted. Conveniently, <code>glmpy</code> provides a <code>SimpleTruncatedPyramidWaterBody</code> class in the <code>dimensions</code> module to easily calculate the height/surface-area pairs!</p> <p><pre><code>from glmpy import dimensions\n</code></pre> The <code>SimpleTruncatedPyramidWaterBody</code> constructor takes the following arguments:</p> <ul> <li><code>height</code>: The height (i.e., the depth) of the dam in metres.</li> <li><code>surface_width</code>: The width of the dam surface in metres.</li> <li><code>surface_length</code>: The length of the dam surface in metres.</li> <li><code>side_slope</code>: The rise over run of the dam side slopes</li> </ul> <p> </p> <p>Three of these arguments are known from the information on our map: <code>height</code>, <code>surface_width</code>, and <code>surface_length</code>. The <code>side_slope</code> is unknown so here we will make an assumption. Farm dams in the WA Wheatbelt are typically constructed with a side slope of 3:1. This means the dam slopes 3 metres vertically for every 1 metre horizontally. Based on this assumption we can now construct the <code>SimpleTruncatedPyramidWaterBody</code> object.</p> <pre><code>dam_morphometry = dimensions.SimpleTruncatedPyramidWaterBody(\n    height=5,\n    surface_width=40,\n    surface_length=62,\n    side_slope=3\n)\n</code></pre> <p>By calling the  <code>get_heights()</code> and <code>get_surface_areas()</code> method on the <code>dam_morphometry</code> object you can return a list of height/surface-area pairs.</p> <pre><code>dam_morphometry.get_heights()\n</code></pre> <pre><code>[-5, -4, -3, -2, -1, 0]\n</code></pre> <pre><code>dam_morphometry.get_surface_areas()\n</code></pre> <pre><code>[2151.111, 2215.111, 2280.0, 2345.774, 2412.444, 2480.0]\n</code></pre> <p>We now have the morphometry of our dam! Let's use these values as inputs to the <code>NMLMorphometry</code> constructor. We'll need to set the following arguments:</p> <ul> <li><code>lake_name</code>: The name of the water body</li> <li><code>latitude</code>: The latitude of the water body</li> <li><code>longitude</code>: The longitude of the water body</li> <li><code>base_elev</code>: The elevation of the bottom of the water body</li> <li><code>crest_elev</code>: The elevation of the top of the water body</li> <li><code>bsn_len</code>: The surface length of the water body in metres</li> <li><code>bsn_wid</code>: The surface width of the water body in metres</li> <li><code>A</code>: A list of surface areas. We just calculated this!</li> <li><code>H</code>: A list of heights. We just calculated this!</li> </ul> <p><code>latitude</code> and <code>longitude</code> are easy, just check the map! What about <code>base_elev</code> and <code>crest_elev</code>? On this farm in the Wheatbelt we're 332 m above sea level. We'll set the <code>crest_elev</code> to <code>332</code>, and the <code>base_elev</code> to <code>332 - 5</code>, i.e., minus the dam depth. <code>bsn_wid</code> and <code>bsn_len</code> are the surface dimensions of the dam while <code>A</code> and <code>H</code> are values we calculated from the <code>dam_morphometry</code> object.</p> <pre><code>morphometry = nml.NMLMorphometry(\n    lake_name = \"Farm dam\",\n    latitude = -32.474,\n    longitude = 116.988,\n    base_elev = 327,\n    crest_elev = 332,\n    bsn_len = 62,\n    bsn_wid = 40,\n    H = dam_morphometry.get_heights(),\n    A = dam_morphometry.get_surface_areas()\n)\n</code></pre>"},{"location":"farm-dam-tutorial/#initial-profiles","title":"Initial profiles","text":"<p>Let's fill up the dam! The <code>&amp;init_profiles</code> component of the GLM <code>.nml</code> file defines the initial state of water in the dam. We provide the initial water level (<code>lake_depth</code>), the water quality variables we want to simulate, and a set of depths where we can set the initialise certain conditions in the water profile.</p> <p>In this simulation, we're only interested in the water balance of our farm dam so we'll ignore the water quality variables. Our dam will start with 4 m of water and we'll set two depths at which we we'll initialise water temperature/salinity. The first depth will be at 1 m and the second at 3 m. We'll set the temperature and salinity at both depths to 18 \u00b0C and 0 ppt, respectively.</p> <pre><code>init_profiles = nml.NMLInitProfiles(\n    lake_depth = 4,\n    num_depth = 2,\n    the_depths = [1, 3],\n    the_temps = [18.0, 18.0],\n    the_sals = [0.0, 0.0]\n)\n</code></pre>"},{"location":"farm-dam-tutorial/#meteorology","title":"Meteorology","text":"<p>To setup the meteorology component of the <code>.nml</code> file we need some nearby data on rainfall and temperature for each day of our simulation. Click here to download some pre-prepared data from the Bureau of Meteorology's weather station at the nearby town of Pingelly:</p> <p>Inspecting the CSV, you'll see daily observations from <code>2010-01-01 00:00:00</code> to <code>2020-12-31 00:00:00</code>:</p> date temperature rainfall 2010-01-01 00:00:00 29.5 0.0 2010-01-02 00:00:00 33.4 0.0 2010-01-03 00:00:00 38.6 0.0 2010-01-04 00:00:00 32.2 0.0 2010-01-05 00:00:00 37.2 0.0 <pre><code>meteorology = nml.NMLMeteorology(\n    met_sw = True,\n    meteo_fl = 'path/to/dam_tutorial_met_data.csv',\n    subdaily = False,\n    time_fmt = 'YYYY-MM-DD hh:mm:ss',\n    ???\n)\n</code></pre>"},{"location":"farm-dam-tutorial/#catchment-inflows","title":"Catchment inflows","text":"<p>Let's now return to the large catchment mentioned at the beginning of this tutorial. During a rainfall event, this catchment captures additional inputs from beyond the spatial extent of the dam. This can be accounted for by configuring the <code>&amp;inflow</code> component of the <code>.nml</code>. Catchment inflows are a function of the catchment area, rainfall, and a runoff threshold. The <code>NMLInflow</code> class expects a CSV with inflows pre-calculated for each day of the simulation. We'll use some of the additional functionality in <code>glmpy</code> to calculate this timeseries.</p> <p>Start by importing the <code>inflows</code> module:</p> <pre><code>from glmpy import inflows\n</code></pre> <p>The <code>CatchmentInflows</code> class will calculate daily inflows from the catchment area and our meteorological data. Dam catchments typically start producing runoff when rainfall exceeds 8 mm.</p> <pre><code>inflows = inflows.CatchmentInflows(\n    input_type = 'dataframe',\n    met_data = met_data,\n    catchment_area = 32000,\n    runoff_threshold = 0.008,\n    precip_col = 'rainfall',\n    date_time_col = 'time'\n)\n</code></pre>"},{"location":"inflows/","title":"Inflows","text":""},{"location":"inflows/#glmpy.inflows.CatchmentRunoffInflows","title":"<code>CatchmentRunoffInflows</code>","text":"<p>Calculate runoff inflows from a catchment.</p> <p>Generates an inflows timeseries by calculating catchment runoff from a pandas DataFrame of precipitation data. Requires a catchment area, a runoff coefficient or threshold, and a precipitation timeseries in either hourly or daily timesteps. Inflows are calculated at the same timestep as the precipitation data but in units of m^3/s. <code>CatchmentRunoffInflows</code> provides methods to return the calculated inflows timeseries as a pandas DataFrame or to write the timeseries to a CSV.</p> <p>Attributes:</p> Name Type Description <code>met_data</code> <code>DataFrame</code> <p>A pandas DataFrame of meteorological data.</p> <code>precip_col</code> <code>str</code> <p>Name of the column in the DataFrame containing precipitation data in m/day or m/hour.</p> <code>date_time_col</code> <code>str</code> <p>Name of the column in the DataFrame containing datetime data.</p> <code>catchment_area</code> <code>Union[float, int]</code> <p>Area of the catchment in square meters.</p> <code>runoff_coef</code> <code>Union[float, None]</code> <p>Runoff coefficient for the catchment. The fraction of rainfall that will result in runoff. Either <code>runoff_coef</code> or <code>runoff_threshold</code> must be provided.</p> <code>runoff_threshold</code> <code>Union[float, None]</code> <p>Runoff threshold for the catchment. The amount of rainfall in mm to generate runoff. Either <code>runoff_coef</code> or <code>runoff_threshold</code> must be provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import inflows\n</code></pre> <p>Generate a daily timeseries of rainfall:</p> <pre><code>&gt;&gt;&gt; daily_met_data = pd.DataFrame({\n...     'Date': pd.date_range(\n...         start='1997-01-01',\n...         end='2004-12-31',\n...         freq='24h'),\n...     'Rain': 0.024 #m per day\n... })\n</code></pre> <p>Calculate inflows with a 50% runoff coefficient and a 1000 m^2 catchment area:</p> <pre><code>&gt;&gt;&gt; inflows_data = inflows.CatchmentRunoffInflows(\n...     met_data = daily_met_data,\n...     catchment_area = 1000,\n...     runoff_coef = 0.5,\n...     precip_col = 'Rain',\n...     date_time_col = 'Date'\n... )\n&gt;&gt;&gt; inflows_data.get_inflows()\n</code></pre> <p>Generate a hourly timeseries of rainfall:</p> <pre><code>&gt;&gt;&gt; hourly_met_data = pd.DataFrame({\n...     'Date': pd.date_range(\n...         start='1997-01-01',\n...         end='2004-12-31',\n...         freq='1h'),\n...     'Rain': 0.001\n... })\n</code></pre> <p>Calculate inflows with a 50% runoff coefficient and a 1000 m^2 catchment area:</p> <pre><code>&gt;&gt;&gt; inflows_data = inflows.CatchmentRunoffInflows(\n...     met_data = hourly_met_data,\n...     catchment_area = 1000,\n...     runoff_coef = 0.5,\n...     precip_col = 'Rain',\n...     date_time_col = 'Date'\n... )\n&gt;&gt;&gt; inflows_data.get_inflows()\n</code></pre>"},{"location":"inflows/#glmpy.inflows.CatchmentRunoffInflows.get_inflows","title":"<code>get_inflows()</code>","text":"<p>Get the inflows timeseries.</p> <p>Returns a pandas dataframe of the calculated catchment runoff inflows.</p> <p>Returns:</p> Name Type Description <code>inflows</code> <code>DataFrame</code> <p>DataFrame of inflow data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import inflows\n&gt;&gt;&gt; import pandas as pd\n</code></pre> <p>Generate an hourly timeseries of rainfall:</p> <pre><code>&gt;&gt;&gt; hourly_met_data = pd.DataFrame({\n...     'Date': pd.date_range(\n...         start='1997-01-01',\n...         end='2004-12-31',\n...         freq='1h'\n...     ),\n...     'Rain': 0.001\n... })\n</code></pre> <p>Calculate inflows with a 50% runoff coefficient and a 1000 m^2 catchment area</p> <pre><code>&gt;&gt;&gt; inflows_data = inflows.CatchmentRunoffInflows(\n...     met_data = hourly_met_data,\n...     catchment_area = 1000,\n...     runoff_coef = 0.5,\n...     precip_col = 'Rain',\n...     date_time_col = 'Date'\n... )\n</code></pre> <p>Call <code>get_inflows()</code> to return the inflows timeseries:</p> <pre><code>&gt;&gt;&gt; inflows_data.get_inflows()\n</code></pre>"},{"location":"inflows/#glmpy.inflows.CatchmentRunoffInflows.write_inflows","title":"<code>write_inflows(file_path)</code>","text":"<p>Write the inflow timeseries to a CSV file.</p> <p>Calculates catchment runoff inflows and writes the timeseries to a CSV.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the output CSV file.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import inflows\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; daily_met_data = pd.DataFrame({\n...     'Date': pd.date_range(\n...         start='1997-01-01',\n...         end='2004-12-31',\n...         freq='24h'),\n...     'Rain': 0.024\n... })\n&gt;&gt;&gt; inflows_data = inflows.CatchmentRunoffInflows(\n...     met_data = daily_met_data,\n...     catchment_area = 1000,\n...     runoff_coef = 0.5,\n...     precip_col = 'Rain',\n...     date_time_col = 'Date'\n... )\n</code></pre> <p>Call <code>write_inflows</code> to write the inflows timeseries to a CSV:</p> <pre><code>&gt;&gt;&gt; inflows_data.write_inflows(file_path='runoff.csv')\n</code></pre>"},{"location":"installation/","title":"Install","text":""},{"location":"installation/#quick-start","title":"Quick start","text":"<p>Install glm-py with <code>pip</code>:</p> <pre><code>pip install glm-py\n</code></pre>"},{"location":"installation/#built-distribution-recommended","title":"Built distribution (recommended)","text":"<p>The built distribution of glm-py comes bundled with the GLM binary.  <code>pip</code> will automatically download the built distribution of glm-py providing:</p> <ul> <li>You have CPython 3.9-3.12 or PyPy 3.9-3.10 installed </li> <li>You are running one of the supported OS/architectures listed in the table below</li> </ul> Linux Macos Windows x86_64 \u2705 \u2705 \u2705 ARM64 \u2705 \u2705 \u274c"},{"location":"installation/#source-distribution","title":"Source distribution","text":"<p>In the event your system does not meet the above requirements, <code>pip</code> will install the source distribution. The source distribution does not ship with the GLM binary. You will still be able to use glm-py (e.g., to create <code>.nml</code> files) but the package will raise an error when you call the <code>glm_run()</code> method from the <code>simulation.GLMSim</code> class.</p> <p>To run GLM, you will either need to source a pre-compiled binary or compile GLM yourself. The <code>glm_path</code> parameter of the <code>glm_run()</code> method can be used to tell glm-py where to run the binary from.</p>"},{"location":"installation/#release-history","title":"Release history","text":"<p>The following table lists the GLM version that is bundled with the built distribution of each glm-py release:</p> glm-py version GLM version <code>0.1.3</code> <code>3.3.1a12</code>"},{"location":"json-to-nml/","title":"GLM_JSON","text":""},{"location":"json-to-nml/#glmpy.glm_json.JSONReader","title":"<code>JSONReader</code>","text":"<p>Supports the reading of GLM configuration blocks in a JSON format or working with GLM configuration blocks in dictionary format.</p> <p>Reads and parses a JSON file into a dictionary object which can be used to set the attributes of the corresponding NML class. Useful for converting a JSON file of GLM parameters from a web application.</p> <p>Attributes:</p> Name Type Description <code>json_file</code> <code>str | PathLike | dict</code> <p>The path to the json file to be read or dict representation of the nml file in memory.</p> <code>nml_file</code> <code>str</code> <p>The path to the nml file to be written.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import glm_json\n&gt;&gt;&gt; json_to_nml = glm_json.JSONReader(\"sparkling_lake.json\")\n</code></pre>"},{"location":"json-to-nml/#glmpy.glm_json.JSONReader.get_nml_blocks","title":"<code>get_nml_blocks()</code>","text":"<p>Reads a JSON file or dictionary of GLM configuration blocks and returns a list of the block names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import glm_json\n&gt;&gt;&gt; json_to_nml = glm_json.JSONReader(\"config.json\")\n&gt;&gt;&gt; json_to_nml.get_nml_blocks()\n</code></pre>"},{"location":"json-to-nml/#glmpy.glm_json.JSONReader.get_nml_parameters","title":"<code>get_nml_parameters(nml_block)</code>","text":"<p>Get the model parameters for a GLM configuration block.</p> <p>Returns a dictionary of model parameters for a specified GLM  configuration block. Used for setting the attributes of the  corresponding <code>nml.NML*</code> classes.</p> <p>Parameters:</p> Name Type Description Default <code>nml_block</code> <code>str</code> <p>The name of the GLM configuration block</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the model parameters for a specified GLM  configuration block.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import glm_json, nml\n&gt;&gt;&gt; json = glm_json.JSONReader(\"sparkling_lake.json\")\n&gt;&gt;&gt; setup_dict = json.get_nml_parameters(\"&amp;glm_setup\")\n&gt;&gt;&gt; setup = nml.NMLSetup()\n&gt;&gt;&gt; setup.set_attributes(setup_dict)\n</code></pre>"},{"location":"json-to-nml/#glmpy.glm_json.JSONReader.read_json","title":"<code>read_json()</code>","text":"<p>Read a JSON file of <code>.nml</code> parameters. </p> <p>Reads a JSON file of GLM configuration blocks and returns a dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import glm_json\n&gt;&gt;&gt; json_to_nml = glm_json.JSONReader(\"sparkling_lake.json\")\n&gt;&gt;&gt; json_to_nml.read_json()\n</code></pre>"},{"location":"nml/","title":"NML","text":""},{"location":"nml/#glmpy.nml.NML","title":"<code>NML</code>","text":"<p>Generate .nml files.</p> <p>The General Lake Model (GLM) namelist file (<code>.nml</code>) describes the parameter configuration for running simulations. The <code>NML</code> class builds an <code>.nml</code>  file by combining dictionaries of parameters that correspond with each  configuration block, e.g., <code>&amp;glm_setup</code>, <code>&amp;morphometry</code>, and <code>&amp;time</code>. Each dictionary of parameters can be created using the respective <code>nml.NML*</code> classes, e.g., <code>nml.NMLGLMSetup</code>, <code>nml.NMLMorphometry</code>, and <code>nml.NMLTime</code>. An optional <code>check_errors</code> argument can be set to raise errors when  parameters from separate configuration blocks are in conflict. The <code>.nml</code> file can be saved using the <code>write_nml()</code> method.</p> <p>Attributes:</p> Name Type Description <code>glm_setup</code> <code>dict</code> <p>Dictionary of <code>&amp;glm_setup</code> parameters. See <code>nml.NMLGLMSetup</code>. Required  for every GLM simulation.</p> <code>morphometry</code> <code>dict</code> <p>Dictionary of <code>&amp;morphometry</code> parameters. See <code>nml.NMLMorphometry</code>.  Required for every GLM simulation.</p> <code>time</code> <code>dict</code> <p>Dictionary of <code>&amp;time</code> parameters. See <code>nml.NMLTime</code>. Required for every  GLM simulation.</p> <code>init_profiles</code> <code>dict</code> <p>Dictionary of <code>&amp;init_profiles</code> parameters. See <code>nml.NMLInitProfiles</code>.  Required for every GLM simulation.</p> <code>mixing</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;mixing</code> parameters. See <code>nml.NMLMixing</code>. Default is  <code>None</code>.</p> <code>output</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;output</code> parameters. See <code>nml.NMLOutput</code>. Default is  <code>None</code>.</p> <code>meteorology</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;meteorology</code> parameters. See <code>nml.NMLMeteorology</code>.  Default is <code>None</code>.</p> <code>light</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;light</code> parameters. See <code>nml.NMLLight</code>. Default is  <code>None</code>.</p> <code>bird_model</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;bird_model</code> parameters. See <code>nml.NMLBirdModel</code>. Default  is <code>None</code>.</p> <code>inflow</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;inflow</code> parameters. See <code>nml.NMLInflow</code>. Default is  <code>None</code>.</p> <code>outflow</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;outflow</code> parameters. See <code>nml.NMLOutflow</code>. Default is  <code>None</code>.</p> <code>sediment</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;sediment</code> parameters. See <code>nml.NMLSediment</code>. Default is  <code>None</code>.</p> <code>snow_ice</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;snow_ice</code> parameters. See <code>nml.NMLSnowIce</code>. Default is  <code>None</code>.</p> <code>wq_setup</code> <code>Union[dict, None]</code> <p>Dictionary of <code>&amp;wq_setup</code> parameters. See <code>nml.NMLWQSetup</code>. Default is  <code>None</code>.</p> <p>Examples:</p> <p>Import the <code>nml</code> module:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n</code></pre> <p>Initialise <code>nml.NML*</code> class instances:</p> <pre><code>&gt;&gt;&gt; glm_setup = nml.NMLGLMSetup()\n&gt;&gt;&gt; morphometry = nml.NMLMorphometry()\n&gt;&gt;&gt; time = nml.NMLTime()\n&gt;&gt;&gt; init_profiles = nml.NMLInitProfiles()\n&gt;&gt;&gt; mixing = nml.NMLMixing()\n&gt;&gt;&gt; output = nml.NMLOutput()\n&gt;&gt;&gt; meteorology = nml.NMLMeteorology()\n&gt;&gt;&gt; light = nml.NMLLight()\n&gt;&gt;&gt; bird_model = nml.NMLBirdModel()\n&gt;&gt;&gt; inflow = nml.NMLInflow()\n&gt;&gt;&gt; outflow = nml.NMLOutflow()\n&gt;&gt;&gt; sediment = nml.NMLSediment()\n&gt;&gt;&gt; snow_ice = nml.NMLSnowIce()\n&gt;&gt;&gt; wq_setup = nml.NMLWQSetup()\n</code></pre> <p>Set the instance attributes from dictionaries of GLM parameters (omitted  for brevity):</p> <pre><code>&gt;&gt;&gt; glm_setup.set_attributes(glm_setup_attrs)\n&gt;&gt;&gt; morphometry.set_attributes(morphometry_attrs)\n&gt;&gt;&gt; time.set_attributes(time_attrs)\n&gt;&gt;&gt; init_profiles.set_attributes(init_profiles_attrs)\n&gt;&gt;&gt; mixing.set_attributes(mixing_attrs)\n&gt;&gt;&gt; output.set_attributes(output_attrs)\n&gt;&gt;&gt; meteorology.set_attributes(meteorology_attrs)\n&gt;&gt;&gt; light.set_attributes(light_attrs)\n&gt;&gt;&gt; bird_model.set_attributes(bird_model_attrs)\n&gt;&gt;&gt; inflow.set_attributes(inflow_attrs)\n&gt;&gt;&gt; outflow.set_attributes(outflow_attrs)\n&gt;&gt;&gt; sediment.set_attributes(sediment_attrs)\n&gt;&gt;&gt; snow_ice.set_attributes(snow_ice_attrs)\n&gt;&gt;&gt; wq_setup.set_attributes(wq_setup_attrs)\n</code></pre> <p>Initialise the <code>NML</code> class and pass in the consolidated dictionaries ( returned by the call method of <code>nml.NML*</code> class instances).</p> <pre><code>&gt;&gt;&gt; nml_file = nml.NML(\n...     glm_setup=glm_setup(),\n...     morphometry=morphometry(),\n...     time=time(),\n...     init_profiles=init_profiles(),\n...     mixing=mixing(),\n...     output=output(),\n...     meteorology=meteorology(),\n...     light=light(),\n...     bird_model=bird_model(),\n...     inflow=inflow(),\n...     outflow=outflow(),\n...     sediment=sediment(),\n...     snow_ice=snow_ice(),\n...     wq_setup=wq_setup()\n...     check_errors=False\n... )\n</code></pre> <p>Write the <code>.nml</code> file with the <code>write_nml()</code> method.</p> <pre><code>&gt;&gt;&gt; nml_file.write_nml(nml_file_path=\"glm3.nml\")\n</code></pre>"},{"location":"nml/#glmpy.nml.NML.nml_bool","title":"<code>nml_bool(python_bool)</code>  <code>staticmethod</code>","text":"<p>Python boolean to Fortran boolean.</p> <p>Convert a Python boolean to a string representation of a Fortran  boolean. </p> <p>Parameters:</p> Name Type Description Default <code>python_bool</code> <code>bool</code> <p>A Python boolean</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; bool = nml.NML.nml_bool(True)\n&gt;&gt;&gt; print(bool)\n.true.\n</code></pre>"},{"location":"nml/#glmpy.nml.NML.nml_list","title":"<code>nml_list(python_list, syntax_func=None)</code>  <code>staticmethod</code>","text":"<p>Python list to comma-separated list.</p> <p>Convert a Python list to a comma-separated list. A function can be  optionally passed to the <code>syntax_func</code> parameter to format the syntax  of each list item, e.g., <code>nml_str()</code> and <code>nml_bool()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>python_list</code> <code>List[Any]</code> <p>A Python list</p> required <code>syntax_func</code> <code>Union[Callable, None]</code> <p>A function used to format each list item. Default is <code>None</code>.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; list = nml.NML.nml_list([1, 2, 3])\n&gt;&gt;&gt; print(list)\n1,2,3\n&gt;&gt;&gt; list = nml.NML.nml_list(\n...     [True, False, True], \n...     syntax_func=nml.NML.nml_bool\n... )\n&gt;&gt;&gt; print(list)\n.true.,.false.,.true.\n</code></pre>"},{"location":"nml/#glmpy.nml.NML.nml_param_val","title":"<code>nml_param_val(param_dict, param, syntax_func=None)</code>  <code>staticmethod</code>","text":"<p>GLM parameter/value string.</p> <p>Construct a string containing a GLM parameter and value with the  correct<code>.nml</code> syntax formatting.</p> <p>Parameters:</p> Name Type Description Default <code>param_dict</code> <code>dict</code> <p>A dictionary containing GLM parameters (keys) and values, e.g., from the <code>__call__()</code> method of a <code>nml.NMLGLMSetup</code> instance.</p> required <code>param</code> <code>str</code> <p>The dictionary key, i.e., GLM parameter, to construct the string for.</p> required <code>syntax_func</code> <code>Union[Callable, None]</code> <p>A function used to format the syntax of the value. Default is  <code>None</code>.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; light_params = {\n...     \"light_mode\": 0,\n...     \"Kw\": 0.4,\n...     \"n_bands\": 4,\n...     \"light_extc\": [1.0, 0.5, 2.0, 4.0],\n...     \"energy_frac\": [0.51, 0.45, 0.035, 0.005],\n...     \"Benthic_Imin\": 10\n... }\n&gt;&gt;&gt; formatted_param = nml.NML.nml_param_val(\n...     param_dict=light_params,\n...     param=\"energy_frac\",\n...     syntax_func=nml.NML.nml_list\n... )\n&gt;&gt;&gt; print(formatted_param)\n   energy_frac = 0.51,0.45,0.035,0.005\n</code></pre>"},{"location":"nml/#glmpy.nml.NML.nml_str","title":"<code>nml_str(python_str)</code>  <code>staticmethod</code>","text":"<p>Python string to Fortran string.</p> <p>Convert a Python string to a Fortran string by adding inverted commas.</p> <p>Parameters:</p> Name Type Description Default <code>python_str</code> <code>str</code> <p>A Python string</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; string = nml.NML.nml_str(\"GLM\")\n&gt;&gt;&gt; print(string)\n'GLM'\n</code></pre>"},{"location":"nml/#glmpy.nml.NML.write_nml","title":"<code>write_nml(nml_file_path='glm3.nml')</code>","text":"<p>Write the <code>.nml</code> file.</p> <p>Write the <code>.nml</code> of model parameters.</p> <p>Parameters:</p> Name Type Description Default <code>nml_file_path</code> <code>str</code> <p>File path to save .nml file, by default <code>glm3.nml</code>.</p> <code>'glm3.nml'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; nml_file.write_nml(nml_file_path=\"my_lake.nml\")\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLBase","title":"<code>NMLBase</code>","text":"<p>Base class for all <code>nml.NML*</code> classes.</p>"},{"location":"nml/#glmpy.nml.NMLBase.set_attributes","title":"<code>set_attributes(attrs_dict)</code>","text":"<p>Set attributes for an instance of a <code>nml.NML*</code> class.</p> <p>Set attributes using a dictionary of model parameters for <code>nml.NML*</code>  classes, e.g., <code>nml.NMLGLMSetup</code>, <code>nml.NMLMixing</code>,  <code>nml.NMLWQSetup</code>.</p> <p>Parameters:</p> Name Type Description Default <code>attrs_dict</code> <code>dict</code> <p>A dictionary of GLM parameters to set the respective attributes in  a <code>nml.NML*</code> class instance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"sim_name\": \"Example Simulation #1\",\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup = nml.NMLGLMSetup()\n&gt;&gt;&gt; glm_setup.set_attributes(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLBirdModel","title":"<code>NMLBirdModel</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Construct the <code>&amp;bird_model</code> model parameters.</p> <p>The <code>&amp;bird_model</code> parameters define the surface irradiance based on the  Bird Clear Sky Model (BCSM) (Bird, 1984). <code>NMLBirdModel</code> provides the means  to construct a dictionary containing these parameters for use in the  <code>nml.NML</code> class. Model parameters are set as attributes upon initialising  an instance of the class or using the <code>set_attributes()</code> method. Class  instances are callable and return the dictionary of parameters.</p> <p>Attributes:</p> Name Type Description <code>AP</code> <code>Union[float, None]</code> <p>Atmospheric pressure (hPa). Default is <code>None</code>.</p> <code>Oz</code> <code>Union[float, None]</code> <p>Ozone concentration (atm-cm). Default is <code>None</code>.</p> <code>WatVap</code> <code>Union[float, None]</code> <p>Total Precipitable water vapor (atm-cm). Default is <code>None</code>.</p> <code>AOD500</code> <code>Union[float, None]</code> <p>Dimensionless Aerosol Optical Depth at wavelength 500 nm. Default is <code>None</code>.</p> <code>AOD380</code> <code>Union[float, None]</code> <p>Dimensionless Aerosol Optical Depth at wavelength 380 nm. Default is <code>None</code>.</p> <code>Albedo</code> <code>Union[float, None]</code> <p>Albedo of the surface used for Bird Model insolation calculation. Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; bird_model = nml.NMLBirdModel(\n...     AP=973,\n...     Oz=0.2\n... )\n&gt;&gt;&gt; bird_model_attrs = {\n...     \"Oz\": 0.279,\n...     \"WatVap\": 1.1,\n...     \"AOD500\": 0.033,\n...     \"AOD380\": 0.038,\n...     \"Albedo\": 0.2\n... }\n&gt;&gt;&gt; bird_model.set_attributes(bird_model_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLBirdModel.__call__","title":"<code>__call__(check_errors=False)</code>","text":"<p>Consolidate the <code>&amp;bird_model</code> parameters and return them as a  dictionary.</p> <p>The <code>__call__()</code> method consolidates model parameters set during class  instance initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>nml.NML</code> class. If <code>check_errors</code>  is <code>True</code>, the method performs validation checks on the parameters to  ensure they comply with expected formats and constraints. </p> <p>Parameters:</p> Name Type Description Default <code>check_errors</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Union[float, None]]</code> <p>A dictionary containing the <code>&amp;bird_model</code> parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; bird_model = nml.NMLBirdModel(\n...     AP=973,\n...     Oz=0.2\n... )\n&gt;&gt;&gt; print(bird_model(check_errors=False))\n{\n    'AP': 973, \n    'Oz': 0.2, \n    'WatVap': None, \n    'AOD500': None, \n    'AOD380': None, \n    'Albedo': None\n}\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLGLMSetup","title":"<code>NMLGLMSetup</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Construct the <code>&amp;glm_setup</code> model parameters.</p> <p>The <code>&amp;glm_setup</code> parameters define the vertical series of layers that GLM  resolves when modelling a water body. <code>NMLGLMSetup</code> provides the means to construct a dictionary containing these parameters for use in the <code>nml.NML</code> class. Model parameters are set as attributes upon initialising an instance of the class or using the <code>set_attributes()</code> method. Class instances are  callable and return the dictionary of parameters.</p> <p>Attributes:</p> Name Type Description <code>sim_name</code> <code>Union[str, None]</code> <p>Title of simulation. Default is <code>None</code>.</p> <code>max_layers</code> <code>Union[int, None]</code> <p>Maximum number of layers. Default is <code>None</code>.</p> <code>min_layer_vol</code> <code>Union[float, None]</code> <p>Minimum layer volume (m^3). Default is <code>None</code>.</p> <code>min_layer_thick</code> <code>Union[float, None]</code> <p>Minimum thickness of a layer (m). Default is <code>None</code>.</p> <code>max_layer_thick</code> <code>Union[float, None]</code> <p>Maximum thickness of a layer (m). Default is <code>None</code>.</p> <code>density_model</code> <code>Union[int, None]</code> <p>Switch to set the density equation. Options are <code>1</code> for TEOS-10, <code>2</code>  for UNESCO(1981), and <code>3</code> for a custom implementation. Default is  <code>None</code>.</p> <code>non_avg</code> <code>Union[bool, None]</code> <p>Switch to configure flow boundary condition temporal interpolation. Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; glm_setup = nml.NMLGLMSetup(\n...     sim_name=\"Example Simulation #1\",\n...     max_layers=250\n... )\n&gt;&gt;&gt; glm_setup_attrs = {\n...     \"max_layers\": 500,\n...     \"min_layer_thick\": 0.15,\n...     \"max_layer_thick\": 1.50,\n...     \"min_layer_vol\": 0.025,\n...     \"density_model\": 1,\n...     \"non_avg\": False\n... }\n&gt;&gt;&gt; glm_setup.set_attributes(glm_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLGLMSetup.__call__","title":"<code>__call__(check_errors=False)</code>","text":"<p>Consolidate the <code>&amp;glm_setup</code> parameters and return them as a  dictionary.</p> <p>The <code>__call__()</code> method consolidates model parameters set during class  instance initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>nml.NML</code> class. If <code>check_errors</code>  is <code>True</code>, the method performs validation checks on the parameters to  ensure they comply with expected formats and constraints. </p> <p>Parameters:</p> Name Type Description Default <code>check_errors</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Union[float, int, str, bool, None]]</code> <p>A dictionary containing the <code>&amp;glm_setup</code> parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; glm_setup = NMLGLMSetup(\n...     sim_name=\"Example Simulation #1\", \n...     max_layers=100\n... )\n&gt;&gt;&gt; print(glm_setup(check_errors=False))\n{\n    'sim_name': 'Example Simulation #1', \n    'max_layers': 100, \n    'min_layer_vol': None, \n    'min_layer_thick': None, \n    'max_layer_thick': None, \n    'density_model': None, \n    'non_avg': None\n}\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLInflow","title":"<code>NMLInflow</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Construct the <code>&amp;inflow</code> model parameters.</p> <p>The <code>&amp;inflow</code> parameters define river inflows and submerged inflows.  <code>NMLInflow</code> provides the means to construct a dictionary containing these  parameters for use in the <code>nml.NML</code> class. Model parameters are set as  attributes upon initialising an instance of the class or using the  <code>set_attributes()</code> method. Class instances are callable and return the  dictionary of parameters.</p> <p>Attributes:</p> Name Type Description <code>num_inflows</code> <code>Union[int, None]</code> <p>Number of inflows to be simulated in this simulation. Default is  <code>None</code>.</p> <code>names_of_strms</code> <code>Union[List[str], str, None]</code> <p>Names of each inflow. A list if <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>subm_flag</code> <code>Union[List[bool], bool, None]</code> <p>Switch indicating if the inflow is entering as a submerged input. A  list if <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>strm_hf_angle</code> <code>Union[List[float], float, None]</code> <p>Angle describing the width of an inflow river channel (\"half angle\"). A  list if <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>strmbd_slope</code> <code>Union[List[float], float, None]</code> <p>Slope of the streambed / river thalweg for each river (degrees). A  list if <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>strmbd_drag</code> <code>Union[List[float], float, None]</code> <p>Drag coefficient of the river inflow thalweg, to calculate entrainment during insertion. A list if <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>coef_inf_entrain</code> <code>Union[List[float], float, None]</code> <p>Undocumented parameter. A list if <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>inflow_factor</code> <code>Union[List[float], float, None]</code> <p>Scaling factor that can be applied to adjust the provided input data. A list if <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>inflow_fl</code> <code>Union[List[str], str, None]</code> <p>Filename(s) of the inflow CSV boundary condition files. A list if  <code>num_inflows &gt; 1</code>. Default is <code>None</code>.</p> <code>inflow_varnum</code> <code>Union[int, None]</code> <p>Number of variables being listed in the columns of <code>inflow_fl</code>. Can  include GLM variables. Default is <code>None</code>.</p> <code>inflow_vars</code> <code>Union[List[str], str, None]</code> <p>Names of the variables in the <code>inflow_fl</code>. Provide variables in the  order as they are in the file. Default is <code>None</code>.</p> <code>time_fmt</code> <code>Union[str, None]</code> <p>Time format of the 1st column in the <code>inflow_fl</code>. For example,  <code>'YYYY-MM-DD hh:mm:ss'</code>. Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; inflow = nml.NMLInflow(\n...     num_inflows=5,\n...     names_of_strms= ['Inflow1','Inflow2','Inflow3','Inflow4','Inflow5']\n... )\n&gt;&gt;&gt; inflow_attrs = {\n...     \"num_inflows\": 6,\n...     \"names_of_strms\": [\n...         'Inflow1','Inflow2','Inflow3','Inflow4','Inflow5','Inflow6'\n...     ],\n...     \"subm_flag\": [False, False, False, True, False, False],\n...     \"strm_hf_angle\": [85.0, 85.0, 85.0, 85.0, 85.0, 85.0],\n...     \"strmbd_slope\": [4.0, 4.0, 4.0, 4.0, 4.0, 4.0],\n...     \"strmbd_drag\": [0.0160, 0.0160, 0.0160, 0.0160, 0.0160, 0.0160],\n...     \"inflow_factor\": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n...     \"inflow_fl\": [\n...         'bcs/inflow_1.csv', 'bcs/inflow_2.csv', 'bcs/inflow_3.csv', \n...         'bcs/inflow_4.csv', 'bcs/inflow_5.csv', 'bcs/inflow_6.csv'\n...     ],\n...     \"inflow_varnum\": 3,\n...     \"inflow_vars\": ['FLOW', 'TEMP', 'SALT'],\n...     \"coef_inf_entrain\": 0.0,\n...     \"time_fmt\": 'YYYY-MM-DD hh:mm:ss'\n... }\n&gt;&gt;&gt; inflow.set_attributes(inflow_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLInflow.__call__","title":"<code>__call__(check_errors=False)</code>","text":"<p>Consolidate the <code>&amp;inflow</code> parameters and return them as a  dictionary.</p> <p>The <code>__call__()</code> method consolidates model parameters set during class  instance initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>nml.NML</code> class. If <code>check_errors</code>  is <code>True</code>, the method performs validation checks on the parameters to  ensure they comply with expected formats and constraints. </p> <p>Parameters:</p> Name Type Description Default <code>check_errors</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[</code> <code>(str)</code> <code>Union[</code> <code>(float, int, str, bool, List[float], List[str], List[bool], None)</code> <code>]</code> <code>]</code> <p>A dictionary containing the <code>&amp;inflow</code> parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; inflow = nml.NMLInflow(\n...     num_inflows=5,\n...     names_of_strms= [\n...         'Inflow1','Inflow2','Inflow3','Inflow4','Inflow5'\n...     ]\n... )\n&gt;&gt;&gt; print(inflow(check_errors=False))\n{\n    'num_inflows': 5, \n    'names_of_strms': [\n        'Inflow1', 'Inflow2', 'Inflow3', 'Inflow4', 'Inflow5'\n    ], \n    'subm_flag': None, \n    'strm_hf_angle': None, \n    'strmbd_slope': None, \n    'strmbd_drag': None, \n    'coef_inf_entrain': None, \n    'inflow_factor': None, \n    'inflow_fl': None, \n    'inflow_varnum': None, \n    'inflow_vars': None, \n    'time_fmt': None\n}\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLInitProfiles","title":"<code>NMLInitProfiles</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Construct the <code>&amp;init_profiles</code> model parameters.</p> <p>The <code>&amp;init_profiles</code> parameters define the initial conditions at specific  depths in the water body. <code>NMLInitProfiles</code> provides the means to construct  a dictionary containing these parameters for use in the <code>nml.NML</code> class.  Model parameters are set as attributes upon initialising an instance of  the class or using the <code>set_attributes()</code> method. Class instances are  callable and return the dictionary of parameters.</p> <p>Attributes:</p> Name Type Description <code>lake_depth</code> <code>Union[float, None]</code> <p>Initial lake height/depth (m). Default is <code>None</code>.</p> <code>num_depths</code> <code>Union[int, None]</code> <p>Number of depths provided for initial profiles. Default is <code>None</code>.</p> <code>the_depths</code> <code>Union[List[float], float, None]</code> <p>The depths of the initial profile points (m). Default is <code>None</code>.</p> <code>the_temps</code> <code>Union[List[float], float, None]</code> <p>The temperature (\u00b0C) at each of the initial profile points. Default is <code>None</code>.</p> <code>the_sals</code> <code>Union[List[float], float, None]</code> <p>The salinity (ppt) at each of the initial profile points. Default is <code>None</code>.</p> <code>num_wq_vars</code> <code>Union[int, None]</code> <p>Number of non-GLM (i.e., FABM or AED2) variables to be initialised. Default is <code>None</code>.</p> <code>wq_names</code> <code>Union[List[str], str, None]</code> <p>Names of non-GLM (i.e., FABM or AED2) variables to be initialised. Default is <code>None</code>.</p> <code>wq_init_vals</code> <code>Union[List[float], float, None]</code> <p>Array of water quality variable initial data  (rows = vars; cols = depths). Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; init_profiles = nml.NMLInitProfiles(\n...     lake_depth=43,\n...     num_depths=2\n... )\n&gt;&gt;&gt; init_profiles_attrs = {\n...     \"num_depths\": 3,\n...     \"the_depths\": [1, 20, 40],\n...     \"the_temps\": [18.0, 18.0, 18.0],\n...     \"the_sals\": [ 0.5, 0.5, 0.5],\n...     \"num_wq_vars\": 6,\n...     \"wq_names\": [\n...         'OGM_don','OGM_pon','OGM_dop','OGM_pop','OGM_doc','OGM_poc'\n...     ],\n...     \"wq_init_vals\": [\n...         1.1, 1.2, 1.3, 1.2, 1.3,\n...         2.1, 2.2, 2.3, 1.2, 1.3,\n...         3.1, 3.2, 3.3, 1.2, 1.3,\n...         4.1, 4.2, 4.3, 1.2, 1.3,\n...         5.1, 5.2, 5.3, 1.2, 1.3,\n...         6.1, 6.2, 6.3, 1.2, 1.3\n...     ]\n... }\n&gt;&gt;&gt; init_profiles.set_attributes(init_profiles_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLInitProfiles.__call__","title":"<code>__call__(check_errors=False)</code>","text":"<p>Consolidate the <code>&amp;init_profiles</code> parameters and return them as a  dictionary.</p> <p>The <code>__call__()</code> method consolidates model parameters set during class  instance initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>nml.NML</code> class. If <code>check_errors</code>  is <code>True</code>, the method performs validation checks on the parameters to  ensure they comply with expected formats and constraints. </p> <p>Parameters:</p> Name Type Description Default <code>check_errors</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Union[float, int, str, List[float], List[str], None]</code> <p>A dictionary containing the <code>&amp;init_profiles</code> parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; init_profiles = nml.NMLInitProfiles(\n...     lake_depth=43,\n...     num_depths=2\n... )\n&gt;&gt;&gt; print(init_profiles(check_errors=False))\n{\n    'lake_depth': 43, \n    'num_depths': 2, \n    'the_depths': None, \n    'the_temps': None, \n    'the_sals': None, \n    'num_wq_vars': None, \n    'wq_names': None, \n    'wq_init_vals': None\n}\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLLight","title":"<code>NMLLight</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Construct the <code>&amp;light</code> model parameters.</p> <p>The <code>&amp;light</code> parameters define light penertration into the water body.  <code>NMLLight</code> provides the means to construct a dictionary containing these  parameters for use in the <code>nml.NML</code> class. Model parameters are set as  attributes upon initialising an instance of the class or using the  <code>set_attributes()</code> method. Class instances are callable and return the  dictionary of parameters.</p> <p>Attributes:</p> Name Type Description <code>light_mode</code> <code>Union[int, None]</code> <p>Switch to configure the approach to light penetration. Options are <code>0</code>  or <code>1</code>. Default is <code>None</code>.</p> <code>Kw</code> <code>Union[float, None]</code> <p>Light extinction coefficient (m^{-1}). Used when <code>light_mode=0</code>.  Default is <code>None</code></p> <code>Kw_file</code> <code>Union[str, None]</code> <p>Name of file with Kw time-series included. Default is <code>None</code>.</p> <code>n_bands</code> <code>Union[int, None]</code> <p>Number of light bandwidths to simulate. Used when <code>light_mode=1</code>.  Default is <code>None</code>.</p> <code>light_extc</code> <code>Union[List[float], float, None]</code> <p>Comma-separated list of light extinction coefficients for each waveband. Default is <code>None</code>.</p> <code>energy_frac</code> <code>Union[List[float], float, None]</code> <p>Comma-separated list of energy fraction captured by each waveband. Default is None.</p> <code>Benthic_Imin</code> <code>Union[float, None]</code> <p>Critical fraction of incident light reaching the benthos. Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; light = nml.NMLLight(\n...     light_mode=0,\n...     Kw=0.5\n... )\n&gt;&gt;&gt; light_attrs = {\n...     \"n_bands\": 4,\n...     \"light_extc\": [1.0, 0.5, 2.0, 4.0],\n...     \"energy_frac\": [0.51, 0.45, 0.035, 0.005],\n...     \"Benthic_Imin\": 10\n... }\n&gt;&gt;&gt; light.set_attributes(light_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLLight.__call__","title":"<code>__call__(check_errors=False)</code>","text":"<p>Consolidate the <code>&amp;light</code> parameters and return them as a  dictionary.</p> <p>The <code>__call__()</code> method consolidates model parameters set during class  instance initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>nml.NML</code> class. If <code>check_errors</code>  is <code>True</code>, the method performs validation checks on the parameters to  ensure they comply with expected formats and constraints. </p> <p>Parameters:</p> Name Type Description Default <code>check_errors</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Union[float, int, str, List[float], None]]</code> <p>A dictionary containing the <code>&amp;light</code> parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; light = nml.NMLLight(\n...    light_mode=0,\n...    Kw=0.5\n... )\n&gt;&gt;&gt; print(light(check_errors=False))\n{\n    'light_mode': 0, \n    'Kw': 0.5, \n    'Kw_file': None, \n    'n_bands': None, \n    'light_extc': None, \n    'energy_frac': None, \n    'Benthic_Imin': None\n}\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLMeteorology","title":"<code>NMLMeteorology</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Construct the <code>&amp;meteorology</code> model parameters.</p> <p>The <code>&amp;meteorology</code> parameters define a variety of meteorological  dynamics, e.g., rainfall, air temperature, radiation, wind, and cloud  cover. <code>NMLMeteorology</code> provides the means to construct a dictionary  containing these parameters for use in the <code>nml.NML</code> class. Model parameters are set as attributes upon initialising an instance of the  class or using the <code>set_attributes()</code> method. Class instances are callable  and return the dictionary of parameters.</p> <p>Attributes:</p> Name Type Description <code>met_sw</code> <code>Union[bool, None]</code> <p>Switch to enable the surface heating module. Default is <code>None</code>.</p> <code>meteo_fl</code> <code>Union[str, None]</code> <p>Filename of the meterological file. Include path and filename. Default  is <code>None</code>.</p> <code>subdaily</code> <code>Union[bool, None]</code> <p>Switch to indicate the meteorological data is provided with sub-daily resolution, at an interval equivalent to <code>dt</code> from <code>nml.NMLTime</code> (\u0394t).  Default is <code>None</code>.</p> <code>time_fmt</code> <code>Union[str, None]</code> <p>Time format of the 1st column in the inflow_fl. For example, 'YYYY-MM-DD hhss'. Default is <code>None</code>.</p> <code>rad_mode</code> <code>Union[int, None]</code> <p>Switch to configure which incoming radiation option to use. Options are <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, or <code>5</code>. Default is <code>None</code>.</p> <code>albedo_mode</code> <code>Union[int, None]</code> <p>Switch to configure which albedo calculation option is used. Options  are <code>1</code> for Hamilton &amp; Schladow, <code>2</code> for Briegleb et al., or <code>3</code> for  Yajima &amp; Yamamoto. Default is <code>None</code>.</p> <code>sw_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the shortwave radiation data provided in the <code>meteo_fl</code>. Default is <code>None</code>.</p> <code>lw_type</code> <code>Union[str, None]</code> <p>Switch to configure which input approach is being used for longwave/cloud data in the <code>meteo_fl</code>. Options are <code>'LW_IN'</code> for  incident longwave, <code>'LW_NET'</code> for net longwave, or <code>'LW_CC'</code> for cloud  cover. Default is <code>None</code>.</p> <code>cloud_mode</code> <code>Union[int, None]</code> <p>Switch to configure which atmospheric emmissivity calculation option is used. Options are <code>1</code> for Idso and Jackson, <code>2</code> for Swinbank, <code>3</code> for Brutsaert, <code>4</code> for Yajima &amp; Yamamoto. Default is <code>None</code>.</p> <code>lw_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the longwave (or cloud) data provided in the <code>meteo_fl</code>. Default is <code>None</code>.</p> <code>atm_stab</code> <code>Union[int, None]</code> <p>Switch to configure which approach to atmospheric stability is used.  <code>0</code> for neutral conditions, <code>1</code> for an undocumented use case, and <code>2</code>  for an undocumented use case. Default is <code>None</code>.</p> <code>rh_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the relative humidity data provided in the <code>meteo_fl</code>. Default is <code>None</code>.</p> <code>at_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the air temperature data provided in the <code>meteo_fl</code>. Default is <code>None</code>.</p> <code>ce</code> <code>Union[float, None]</code> <p>Bulk aerodynamic transfer coefficient for latent heat flux. Default is <code>None</code>.</p> <code>ch</code> <code>Union[float, None]</code> <p>Bulk aerodynamic transfer coefficient for sensible heat flux. Default is <code>None</code>.</p> <code>rain_sw</code> <code>Union[bool, None]</code> <p>Switch to configure rainfall input concentrations. Default is <code>None</code>.</p> <code>rain_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the rainfall data provided in the <code>meteo_fl</code>. Default is <code>None</code>.</p> <code>catchrain</code> <code>Union[bool, None]</code> <p>Switch that configures runoff from exposed banks of lake area. Default is <code>None</code>.</p> <code>rain_threshold</code> <code>Union[float, None]</code> <p>Daily rainfall amount (m) required before runoff from exposed banks occurs. Default is <code>None</code>.</p> <code>runoff_coef</code> <code>Union[float, None]</code> <p>Conversion fraction of infiltration excess rainfall to runoff in exposed lake banks. Default is <code>None</code>.</p> <code>cd</code> <code>Union[float, None]</code> <p>Bulk aerodynamic transfer coefficient for momentum. Default is <code>None</code>.</p> <code>wind_factor</code> <code>Union[float, None]</code> <p>Scaling factor to adjust the windspeed data provided in the <code>meteo_fl</code>. Default is <code>None</code>.</p> <code>fetch_mode</code> <code>Union[int, None]</code> <p>Switch to configure which wind-sheltering/fetch option to use. Options  are <code>0</code> for no sheltering, <code>1</code> for area-based scaling, <code>2</code> for Markfort  length-scale, or <code>3</code> for user input scaling table. Default is <code>None</code>.</p> <code>Aws</code> <code>Union[float, None]</code> <p>Undocumented parameter. Required if <code>fetch_mode=1</code>. Default is <code>None</code>.</p> <code>Xws</code> <code>Union[float, None]</code> <p>Undocumented parameter. Required if <code>fetch_mode=2</code>. Default is <code>None</code>.</p> <code>num_dir</code> <code>Union[int, None]</code> <p>Number of wind direction reference points being read in. Required if  <code>fetch_mode=2</code> or <code>fetch_mode=3</code>. Default is <code>None</code>.</p> <code>wind_dir</code> <code>Union[float, None]</code> <p>Wind directions used for wind-sheltering effects. Required if  <code>fetch_mode=2</code> or <code>fetch_mode=3</code>. Default is <code>None</code>.</p> <code>fetch_scale</code> <code>Union[float, None]</code> <p>Direction specific wind-sheltering scaling factors. Required if  <code>fetch_mode=2</code> or <code>fetch_mode=3</code>. Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; meteorology = nml.NMLMeteorology(\n...     met_sw=True,\n...     lw_type='LW_NET'\n... )\n&gt;&gt;&gt; meteorology_attrs = {\n...     \"lw_type\": \"LW_IN\",\n...     \"rain_sw\": False,\n...     \"atm_stab\": 0,\n...     \"fetch_mode\": 0,\n...     \"rad_mode\": 1,\n...     \"albedo_mode\": 1,\n...     \"cloud_mode\": 4,\n...     \"subdaily\": True,\n...     \"meteo_fl\": 'bcs/met_hourly.csv',\n...     \"wind_factor\": 0.9,\n...     \"ce\": 0.0013,\n...     \"ch\": 0.0013,\n...     \"cd\": 0.0013,\n...     \"catchrain\": True,\n...     \"rain_threshold\": 0.001,\n...     \"runoff_coef\": 0.0\n... }\n&gt;&gt;&gt; meteorology.set_attributes(meteorology_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLMeteorology.__call__","title":"<code>__call__(check_errors=False)</code>","text":"<p>Consolidate the <code>&amp;meteorology</code> parameters and return them as a  dictionary.</p> <p>The <code>__call__()</code> method consolidates model parameters set during class  instance initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>nml.NML</code> class. If <code>check_errors</code>  is <code>True</code>, the method performs validation checks on the parameters to  ensure they comply with expected formats and constraints. </p> <p>Parameters:</p> Name Type Description Default <code>check_errors</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Union[float, int, str, bool, None]]</code> <p>A dictionary containing the <code>&amp;meteorology</code> parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; meteorology = nml.NMLMeteorology(\n...     met_sw=True,\n...     lw_type='LW_NET'\n... )\n&gt;&gt;&gt; print(meteorology(check_errors=False))\n{\n    'met_sw': True, \n    'meteo_fl': None, \n    'subdaily': None, \n    'time_fmt': None, \n    'rad_mode': None, \n    'albedo_mode': None, \n    'sw_factor': None, \n    'lw_type': 'LW_NET', \n    'cloud_mode': None, \n    'lw_factor': None, \n    'atm_stab': None, \n    'rh_factor': None, \n    'at_factor': None, \n    'ce': None, \n    'ch': None, \n    'rain_sw': None, \n    'rain_factor': None, \n    'catchrain': None, \n    'rain_threshold': None, \n    'runoff_coef': None, \n    'cd': None, \n    'wind_factor': None, \n    'fetch_mode': None, \n    'Aws': None, \n    'Xws': None, \n    'num_dir': None, \n    'wind_dir': None, \n    'fetch_scale': None\n}\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLMixing","title":"<code>NMLMixing</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Construct the <code>&amp;mixing</code> model parameters.</p> <p>The <code>&amp;mixing</code> parameters define the dynamics of layer mixing in the  modelled water body. <code>NMLMixing</code> provides the means to construct a  dictionary containing these parameters for use in the <code>nml.NML</code> class.  Model parameters are set as attributes upon initialising an instance of the class or using the <code>set_attributes()</code> method. Class instances are callable  and return the dictionary of parameters.</p> <p>Attributes:</p> Name Type Description <code>surface_mixing</code> <code>Union[int, None]</code> <p>Switch to select the options of the surface mixing model. Options are  <code>0</code> for no surface mixing, <code>1</code>, and <code>2</code>. Default is <code>None</code>.</p> <code>coef_mix_conv</code> <code>Union[float, None]</code> <p>Mixing efficiency - convective overturn. Default is <code>None</code>.</p> <code>coef_wind_stir</code> <code>Union[float, None]</code> <p>Mixing efficiency - wind stirring. Default is <code>None</code>.</p> <code>coef_mix_shear</code> <code>Union[float, None]</code> <p>Mixing efficiency - shear production. Default is <code>None</code>.</p> <code>coef_mix_turb</code> <code>Union[float, None]</code> <p>Mixing efficiency - unsteady turbulence effects. Default is <code>None</code>.</p> <code>coef_mix_KH</code> <code>Union[float, None]</code> <p>Mixing efficiency - Kelvin-Helmholtz billowing. Default is <code>None</code>.</p> <code>deep_mixing</code> <code>Union[int, None]</code> <p>Switch to select the options of the deep (hypolimnetic) mixing model. Options are <code>0</code> for no deep mixing, <code>1</code> for constant diffusivity, and  <code>2</code> for the Weinstock model. Default is <code>None</code>.</p> <code>coef_mix_hyp</code> <code>Union[float, None]</code> <p>Mixing efficiency - hypolimnetic turbulence. Default is <code>None</code>.</p> <code>diff</code> <code>Union[float, None]</code> <p>Background (molecular) diffusivity in the hypolimnion. Default is  <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; mixing = nml.NMLMixing(\n...     surface_mixing=1,\n...     coef_mix_conv=0.1,\n... )\n&gt;&gt;&gt; mixing_attrs = {\n...     \"coef_mix_conv\": 0.125,\n...     \"coef_wind_stir\": 0.23,\n...     \"coef_mix_shear\":0.2,\n...     \"coef_mix_turb\": 0.51,\n...     \"coef_mix_KH\": 0.3,\n...     \"deep_mixing\": 2,\n...     \"coef_mix_hyp\": 0.5,\n...     \"diff\": 0.0\n... }\n&gt;&gt;&gt; mixing.set_attributes(mixing_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLMixing.__call__","title":"<code>__call__(check_errors=False)</code>","text":"<p>Consolidate the <code>&amp;mixing</code> parameters and return them as a  dictionary.</p> <p>The <code>__call__()</code> method consolidates model parameters set during class  instance initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>nml.NML</code> class. If <code>check_errors</code>  is <code>True</code>, the method performs validation checks on the parameters to  ensure they comply with expected formats and constraints. </p> <p>Parameters:</p> Name Type Description Default <code>check_errors</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Union[float, int, None]]</code> <p>A dictionary containing the <code>&amp;mixing</code> parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; mixing = nml.NMLMixing(\n...     surface_mixing=1,\n...     coef_mix_conv=0.1,\n... )\n&gt;&gt;&gt; print(mixing(check_errors=False))\n{\n    'surface_mixing': 1, \n    'coef_mix_conv': 0.1, \n    'coef_wind_stir': None, \n    'coef_mix_shear': None, \n    'coef_mix_turb': None, \n    'coef_mix_KH': None, \n    'deep_mixing': None, \n    'coef_mix_hyp': None, \n    'diff': None\n}\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLMorphometry","title":"<code>NMLMorphometry</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Construct the <code>&amp;morphometry</code> model parameters.</p> <p>The <code>&amp;morphometry</code> parameters define the physical dimensions and location  of the water body. <code>NMLMorphometry</code> provides the means to construct a  dictionary containing these parameters for use in the <code>nml.NML</code> class.  Model parameters are set as attributes upon initialising an instance of the class or using the <code>set_attributes()</code> method. Class instances are callable  and return the dictionary of parameters.</p> <p>Attributes:</p> Name Type Description <code>lake_name</code> <code>Union[str, None]</code> <p>Site name. Default is <code>None</code>.</p> <code>latitude</code> <code>Union[float, None]</code> <p>Latitude, positive North (\u00b0N). Default is <code>None</code>.</p> <code>longitude</code> <code>Union[float, None]</code> <p>Longitude, positive East (\u00b0E). Default is <code>None</code>.</p> <code>base_elev</code> <code>Union[float, None]</code> <p>Elevation of the bottom-most point of the lake (m above datum). Default is <code>None</code>.</p> <code>crest_elev</code> <code>Union[float, None]</code> <p>Elevation of a weir crest, where overflow begins (m above datum).  Default is <code>None</code>.</p> <code>bsn_len</code> <code>Union[float, None]</code> <p>Length of the lake basin, at crest height (m). Default is <code>None</code>.</p> <code>bsn_wid</code> <code>Union[float, None]</code> <p>Width of the lake basin, at crest height (m). Default is <code>None</code>.</p> <code>bsn_vals</code> <code>Union[float, None]</code> <p>Number of points being provided to described the hyposgraphic details. Default is <code>None</code>.</p> <code>H</code> <code>Union[List[float], None]</code> <p>Comma-separated list of lake elevations (m above datum). Default is <code>None</code>.</p> <code>A</code> <code>Union[List[float], None]</code> <p>Comma-separated list of lake areas (m^2). Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; morphometry = nml.NMLMorphometry(\n...     lake_name='Example Lake',\n...     latitude=30.0\n... )\n&gt;&gt;&gt; morphometry_attrs = {\n...     \"latitude\": 32.0,\n...     \"longitude\": 35.0,\n...     \"base_elev\": -252.9,\n...     \"crest_elev\": -203.9,\n...     \"bsn_len\": 21000.0,\n...     \"bsn_wid\": 13000.0,\n...     \"bsn_vals\": 45,\n...     \"H\": [\n...         -252.9, -251.9, -250.9, -249.9, -248.9, -247.9, -246.9, -245.9, \n...         -244.9, -243.9, -242.9, -241.9, -240.9, -239.9, -238.9, -237.9, \n...         -236.9, -235.9, -234.9, -233.9, -232.9, -231.9, -230.9, -229.9,  \n...         -228.9, -227.9, -226.9, -225.9, -224.9, -223.9, -222.9, -221.9,  \n...         -220.9, -219.9, -218.9, -217.9, -216.9, -215.9, -214.9, -213.9,  \n...         -212.9, -211.9, -208.9, -207.9, -203.9\n...     ],\n...     \"A\": [\n...         0, 9250000, 15200000, 17875000, 21975000, 26625000, 31700000, \n...         33950000, 38250000, 41100000, 46800000, 51675000, 55725000, \n...         60200000, 64675000, 69600000, 74475000, 79850000, 85400000, \n...         90975000, 96400000, 102000000, 107000000, 113000000, 118000000, \n...         123000000, 128000000, 132000000, 136000000, 139000000, \n...         143000000, 146000000, 148000000, 150000000, 151000000, \n...         153000000, 155000000, 157000000, 158000000, 160000000, \n...         161000000, 162000000, 167000000, 170000000, 173000000\n...     ]\n... }\n&gt;&gt;&gt; morphometry.set_attributes(morphometry_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLMorphometry.__call__","title":"<code>__call__(check_errors=False)</code>","text":"<p>Consolidate the <code>&amp;morphometry</code> parameters and return them as a  dictionary.</p> <p>The <code>__call__()</code> method consolidates model parameters set during class  instance initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>nml.NML</code> class. If <code>check_errors</code>  is <code>True</code>, the method performs validation checks on the parameters to  ensure they comply with expected formats and constraints. </p> <p>Parameters:</p> Name Type Description Default <code>check_errors</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Union[float, int, str, bool, None]]</code> <p>A dictionary containing the <code>&amp;morphometry</code> parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; morphometry = nml.NMLMorphometry(\n...     lake_name='Example Lake',\n...     latitude=30.0\n... )\n&gt;&gt;&gt; print(morphometry(check_errors=False))\n{\n    'lake_name': 'Example Lake', \n    'latitude': 30.0, \n    'longitude': None, \n    'base_elev': None, \n    'crest_elev': None, \n    'bsn_len': None, \n    'bsn_wid': None, \n    'bsn_vals': None, \n    'H': None, \n    'A': None\n}\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLOutflow","title":"<code>NMLOutflow</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Construct the <code>&amp;outflow</code> model parameters.</p> <p>The <code>&amp;outflow</code> parameters define withdrawals, outlets, offtakes, and  seepage. <code>NMLOutflow</code> provides the means to construct a dictionary  containing these parameters for use in the <code>nml.NML</code> class. Model  parameters are set as attributes upon initialising an instance of the class  or using the <code>set_attributes()</code> method. Class instances are callable and  return the dictionary of parameters.</p> <p>Attributes:</p> Name Type Description <code>num_outlet</code> <code>Union[int, None]</code> <p>Number of outflows (including withdrawals, outlets or offtakes) to be included in this simulation. Default is <code>None</code>.</p> <code>outflow_fl</code> <code>Union[str, None]</code> <p>Filename of the file containing the outflow time-series. Default is <code>None</code>.</p> <code>time_fmt</code> <code>Union[str, None]</code> <p>Time format of the 1st column in the <code>outflow_fl</code>. Default is <code>None</code>.</p> <code>outflow_factor</code> <code>Union[List[float], float, None]</code> <p>Scaling factor used as a multiplier for outflows. A list if  <code>num_outlet &gt; 1</code>. Default is <code>None</code>.</p> <code>outflow_thick_limit</code> <code>Union[List[float], float, None]</code> <p>Maximum vertical limit of withdrawal entrainment. A list if  <code>num_outlet &gt; 1</code>. Default is <code>None</code>.</p> <code>single_layer_draw</code> <code>Union[List[bool], bool, None]</code> <p>Switch to only limit withdrawal entrainment and force outflows from layer at the outlet elevation height. A list if <code>num_outlet &gt; 1</code>.  Default is <code>None</code>.</p> <code>flt_off_sw</code> <code>Union[List[bool], bool, None]</code> <p>Switch to indicate if the outflows are floating offtakes (taking water  from near the surface). A list if <code>num_outlet &gt; 1</code>. Default is <code>None</code>.</p> <code>outlet_type</code> <code>Union[List[int], int, None]</code> <p>Switch to configure approach of each withdrawal. Options are <code>1</code> for  fixed outlet height, <code>2</code> for floating offtake, <code>3</code> for adaptive  offtake/low oxy avoidance, <code>4</code> for adaptive offtake/isotherm following,  or <code>5</code> for adaptive offtake/temp time-series. A list if  <code>num_outlet &gt; 1</code>. Default is <code>None</code>.</p> <code>outl_elvs</code> <code>Union[List[float], float, None]</code> <p>Outlet elevations (m). A list if <code>num_outlet &gt; 1</code>. Default is <code>None</code>.</p> <code>bsn_len_outl</code> <code>Union[List[float], float, None]</code> <p>Basin length at the outlet height(s) (m). A list if <code>num_outlet &gt; 1</code>.  Default is <code>None</code>.</p> <code>bsn_wid_outl</code> <code>Union[List[float], float, None]</code> <p>Basin width at the outlet heights (m). A list if <code>num_outlet &gt; 1</code>.  Default is <code>None</code>.</p> <code>crit_O2</code> <code>Union[int, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>crit_O2_dep</code> <code>Union[int, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>crit_O2_days</code> <code>Union[int, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>outlet_crit</code> <code>Union[int, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>O2name</code> <code>Union[str, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>O2idx</code> <code>Union[str, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>target_temp</code> <code>Union[float, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>min_lake_temp</code> <code>Union[float, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>fac_range_upper</code> <code>Union[float, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>fac_range_lower</code> <code>Union[float, None</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>mix_withdraw</code> <code>Union[bool, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>coupl_oxy_sw</code> <code>Union[bool, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <code>withdrTemp_fl</code> <code>Union[str, None]</code> <p>Filename of the file containing the temperature time-series the  adaptive withdrawal is targeting. Required if <code>outlet_type=5</code>. Default  is <code>None</code>.</p> <code>seepage</code> <code>Union[bool, None]</code> <p>Switch to enable the seepage of water from the lake bottom. Default is <code>None</code>.</p> <code>seepage_rate</code> <code>Union[float, None]</code> <p>Seepage rate of water, or, soil hydraulic conductivity (m day^{-1}).  Default is <code>None</code>.</p> <code>crest_width</code> <code>Union[float, None]</code> <p>Width of weir (at crest height) where lake overflows (m). Default is <code>None</code>.</p> <code>crest_factor</code> <code>Union[float, None]</code> <p>Drag coefficient associated with the weir crest, used to compute the overflow discharge rate. Applies only when the crest elevation is  configured to be less than the maximum elevation of the domain. Default  is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; outflow = nml.NMLOutflow(\n...     num_outlet=1,\n...     flt_off_sw=True\n... )\n&gt;&gt;&gt; outflow_attrs = {\n...     \"flt_off_sw\": False,\n...     \"outlet_type\": 1,\n...     \"outl_elvs\": -215.5,\n...     \"bsn_len_outl\": 18000,\n...     \"bsn_wid_outl\": 11000,\n...     \"outflow_fl\" : 'bcs/outflow.csv',\n...     \"outflow_factor\": 1.0,\n...     \"seepage\": True,\n...     \"seepage_rate\": 0.01\n... }\n&gt;&gt;&gt; outflow.set_attributes(outflow_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLOutflow.__call__","title":"<code>__call__(check_errors=False)</code>","text":"<p>Consolidate the <code>&amp;outflow</code> parameters and return them as a  dictionary.</p> <p>The <code>__call__()</code> method consolidates model parameters set during class  instance initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>nml.NML</code> class. If <code>check_errors</code>  is <code>True</code>, the method performs validation checks on the parameters to  ensure they comply with expected formats and constraints. </p> <p>Parameters:</p> Name Type Description Default <code>check_errors</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[</code> <code>(str)</code> <code>Union[float, int, str, bool, List[float], List[int], List[bool], None]</code> <code>]</code> <p>A dictionary containing the <code>&amp;outflow</code> parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; outflow = nml.NMLOutflow(\n...     num_outlet=1,\n...     flt_off_sw=True\n... )\n&gt;&gt;&gt; print(outflow(check_errors=False))\n{\n    'num_outlet': 1, \n    'outflow_fl': None, \n    'time_fmt': None, \n    'outflow_factor': None, \n    'outflow_thick_limit': None, \n    'single_layer_draw': None, \n    'flt_off_sw': [True], \n    'outlet_type': None, \n    'outl_elvs': None, \n    'bsn_len_outl': None, \n    'bsn_wid_outl': None, \n    'crit_O2': None, \n    'crit_O2_dep': None, \n    'crit_O2_days': None, \n    'outlet_crit': None, \n    'O2name': None, \n    'O2idx': None, \n    'target_temp': None, \n    'min_lake_temp': None, \n    'fac_range_upper': None, \n    'fac_range_lower': None, \n    'mix_withdraw': None, \n    'coupl_oxy_sw': None, \n    'withdrTemp_fl': None, \n    'seepage': None, \n    'seepage_rate': None, \n    'crest_width': None, \n    'crest_factor': None\n}\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLOutput","title":"<code>NMLOutput</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Construct the <code>&amp;output</code> model parameters.</p> <p>The <code>&amp;output</code> parameters define the contents and location of GLM output  files. <code>NMLOutput</code> provides the means to construct a dictionary containing  these parameters for use in the <code>nml.NML</code> class. Model parameters are set  as attributes upon initialising an instance of the class or using the  <code>set_attributes()</code> method. Class instances are callable and return the  dictionary of parameters.</p> <p>Attributes:</p> Name Type Description <code>out_dir</code> <code>Union[str, None]</code> <p>Directory to write the output files. Default is <code>None</code>.</p> <code>out_fn</code> <code>Union[str, None]</code> <p>Filename of the main NetCDF output file. Default is <code>None</code>.</p> <code>nsave</code> <code>Union[int, None]</code> <p>Frequency to write to the NetCDF and CSV point files. Default is  <code>None</code>.</p> <code>csv_lake_fname</code> <code>Union[str, None]</code> <p>Filename for the daily summary file. Default is <code>None</code></p> <code>csv_point_nlevs</code> <code>Union[float, None]</code> <p>Number of specific level/depth CSV files to be created. Default is <code>None</code>.</p> <code>csv_point_fname</code> <code>Union[str, None]</code> <p>Name to be appended to specified depth CSV files. Default is <code>None</code>.</p> <code>csv_point_frombot</code> <code>Union[List[float], float, None]</code> <p>Comma separated list identify whether each output point listed in csv_point_at is relative to the bottom (i.e., heights) or the surface (i.e., depths). Default is <code>None</code>.</p> <code>csv_point_at</code> <code>Union[List[float], float, None]</code> <p>Height or Depth of points to output at (comma-separated list). Default is <code>None</code>.</p> <code>csv_point_nvars</code> <code>Union[int, None]</code> <p>Number of variables to output into the csv files. Default is <code>None</code>.</p> <code>csv_point_vars</code> <code>Union[List[str], str, None]</code> <p>Comma separated list of variable names. Default is <code>None</code>.</p> <code>csv_outlet_allinone</code> <code>Union[bool, None]</code> <p>Switch to create an optional outlet file combining all outlets. Default is <code>None</code>.</p> <code>csv_outlet_fname</code> <code>Union[str, None]</code> <p>Name to be appended to each of the outlet CSV files. Default is <code>None</code>.</p> <code>csv_outlet_nvars</code> <code>Union[int, None]</code> <p>Number of variables to be written into the outlet file(s). Default is <code>None</code>.</p> <code>csv_outlet_vars</code> <code>Union[List[str], str, None]</code> <p>Comma separated list of variable names to be included in the output file(s). Default is <code>None</code>.</p> <code>csv_ovrflw_fname</code> <code>Union[str, None]</code> <p>Filename to be used for recording the overflow details. Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; output = nml.NMLOutput(\n...     out_dir=\"output\",\n...     out_fn=\"output_file\"\n... )\n&gt;&gt;&gt; output_attrs = {\n...     'out_fn': 'output',\n...     'nsave': 6,\n...     'csv_lake_fname': 'lake',\n...     'csv_point_nlevs': 2,\n...     'csv_point_fname': 'WQ_' ,\n...     'csv_point_at': [5, 30],    \n...     'csv_point_nvars': 7,\n...     'csv_point_vars': [\n...         'temp', 'salt', 'OXY_oxy', 'SIL_rsi', \n...         'NIT_amm', 'NIT_nit', 'PHS_frp'\n...     ],\n...     'csv_outlet_allinone': False,\n...     'csv_outlet_fname': 'outlet_',\n...     'csv_outlet_nvars': 4,\n...     'csv_outlet_vars': ['flow', 'temp', 'salt', 'OXY_oxy'],\n...     'csv_ovrflw_fname': \"overflow\"\n... }\n&gt;&gt;&gt; output.set_attributes(output_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLOutput.__call__","title":"<code>__call__(check_errors=False)</code>","text":"<p>Consolidate the <code>&amp;output</code> parameters and return them as a  dictionary.</p> <p>The <code>__call__()</code> method consolidates model parameters set during class  instance initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>nml.NML</code> class. If <code>check_errors</code>  is <code>True</code>, the method performs validation checks on the parameters to  ensure they comply with expected formats and constraints. </p> <p>Parameters:</p> Name Type Description Default <code>check_errors</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Union[float, int, str, bool, List[float], List[str], None]</code> <p>A dictionary containing the <code>&amp;output</code> parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; output = nml.NMLOutput(\n...     out_dir=\"output\",\n...     out_fn=\"output_file\"\n... )\n&gt;&gt;&gt; print(output(check_errors=False))\n{\n    'out_dir': 'output', \n    'out_fn': 'output_file', \n    'nsave': None, \n    'csv_lake_fname': None, \n    'csv_point_nlevs': None, \n    'csv_point_fname': None, \n    'csv_point_frombot': None, \n    'csv_point_at': None, \n    'csv_point_nvars': None, \n    'csv_point_vars': None, \n    'csv_outlet_allinone': None, \n    'csv_outlet_fname': None, \n    'csv_outlet_nvars': None, \n    'csv_outlet_vars': None, \n    'csv_ovrflw_fname': None\n}\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLSediment","title":"<code>NMLSediment</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Construct the <code>&amp;sediment</code> model parameters.</p> <p>The <code>&amp;sediment</code> parameters define the thermal properties of the  soil-sediment. <code>NMLSediment</code> provides the means to construct a dictionary  containing these parameters for use in the <code>nml.NML</code> class. Model  parameters are set as attributes upon initialising an instance of the class  or using the <code>set_attributes()</code> method. Class instances are callable and  return the dictionary of parameters.</p> <p>Attributes:</p> Name Type Description <code>sed_heat_Ksoil</code> <code>Union[float, None]</code> <p>Heat conductivity of soil/sediment. Default is <code>None</code>.</p> <code>sed_temp_depth</code> <code>Union[float, None]</code> <p>Depth of soil/sediment layer below the lake bottom, used for heat flux calculation. Default is <code>None</code>.</p> <code>sed_temp_mean</code> <code>Union[List[float], float, None]</code> <p>Annual mean sediment temperature. A list if <code>n_zones &gt; 1</code>. Default is  <code>None</code>.</p> <code>sed_temp_amplitude</code> <code>Union[List[float], float, None]</code> <p>Amplitude of temperature variation experienced in the sediment over one year. A list if <code>n_zones &gt; 1</code>. Default is <code>None</code>.</p> <code>sed_temp_peak_doy</code> <code>Union[List[int], int, None]</code> <p>Day of the year where the sediment temperature peaks. A list if  <code>n_zones &gt; 1</code>. Default is <code>None</code>.</p> <code>benthic_mode</code> <code>Union[int, None]</code> <p>Switch to configure which mode of benthic interaction to apply. Options  are <code>0</code> for bottom layer only, <code>1</code> for bottom layer and layer flanks,  <code>2</code> for sediment zones, and <code>3</code> for an undocumented use case. Default  is <code>None</code>.</p> <code>n_zones</code> <code>Union[int, None]</code> <p>Number of sediment zones to simulate. Required if <code>benthic_mode=2</code> or  <code>benthic_mode=3</code>. Default is <code>None</code>.</p> <code>zone_heights</code> <code>Union[List[float], float, None]</code> <p>Upper height of zone boundary. Required if <code>benthic_mode=2</code> or  <code>benthic_mode=3</code>. Default is <code>None</code>.</p> <code>sed_reflectivity</code> <code>Union[List[float], float, None]</code> <p>Sediment reflectivity. Default is <code>None</code>.</p> <code>sed_roughness</code> <code>Union[List[float], float, None]</code> <p>Undocumented parameter. Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; sediment = nml.NMLSediment(\n...     sed_heat_Ksoil=0.0,\n...     sed_temp_depth=0.1\n... )\n&gt;&gt;&gt; sediment_attrs = {\n...     \"sed_temp_depth\": 0.2,\n...     \"sed_temp_mean\": [5, 10, 20],\n...     \"sed_temp_amplitude\": [6, 8, 10],\n...     \"sed_temp_peak_doy\": [80, 70, 60],\n...     \"benthic_mode\": 1,\n...     \"n_zones\": 3,\n...     \"zone_heights\": [10.0, 20.0, 50.0],\n...     \"sed_reflectivity\": [0.1, 0.01, 0.01],\n...     \"sed_roughness\": [0.1, 0.01, 0.01]\n... }\n&gt;&gt;&gt; sediment.set_attributes(sediment_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLSediment.__call__","title":"<code>__call__(check_errors=False)</code>","text":"<p>Consolidate the <code>&amp;sediment</code> parameters and return them as a  dictionary.</p> <p>The <code>__call__()</code> method consolidates model parameters set during class  instance initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>nml.NML</code> class. If <code>check_errors</code>  is <code>True</code>, the method performs validation checks on the parameters to  ensure they comply with expected formats and constraints. </p> <p>Parameters:</p> Name Type Description Default <code>check_errors</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Union[float, int, List[float], List[int], None]]</code> <p>A dictionary containing the <code>&amp;sediment</code> parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; sediment = nml.NMLSediment(\n...     sed_heat_Ksoil=0.0,\n...     sed_temp_depth=0.1\n&gt;&gt;&gt; )\n&gt;&gt;&gt; print(sediment(check_errors=False))\n{\n    'sed_heat_Ksoil': 0.0, \n    'sed_temp_depth': 0.1, \n    'sed_temp_mean': None, \n    'sed_temp_amplitude': None, \n    'sed_temp_peak_doy': None, \n    'benthic_mode': None, \n    'n_zones': None, \n    'zone_heights': None, \n    'sed_reflectivity': None, \n    'sed_roughness': None\n}\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLSnowIce","title":"<code>NMLSnowIce</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Construct the <code>&amp;snowice</code> model parameters.</p> <p>The <code>&amp;snowice</code> parameters define the formation of snow and ice cover on the water body. <code>NMLSnowIce</code> provides the means to construct a dictionary  containing these parameters for use in the <code>nml.NML</code> class. Model  parameters are set as attributes upon initialising an instance of the  class or using the <code>set_attributes()</code> method. Class instances are callable  and return the dictionary of parameters.</p> <p>Attributes:</p> Name Type Description <code>snow_albedo_factor</code> <code>Union[float, None]</code> <p>Scaling factor used to as a multiplier to scale the snow/ice albedo estimate. Default is <code>None</code>.</p> <code>snow_rho_max</code> <code>Union[float, None]</code> <p>Minimum snow density allowable (kg m^{-3}). Default is <code>None</code>.</p> <code>snow_rho_min</code> <code>Union[float, None]</code> <p>Maximum snow density allowable (kg m^{-3}). Default is <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; snow_ice = nml.NMLSnowIce(\n...     snow_albedo_factor=1.0,\n...     snow_rho_min=40\n... )\n&gt;&gt;&gt; snow_ice_attrs = {\n...     \"snow_rho_min\": 50,\n...     \"snow_rho_max\": 300\n... }\n&gt;&gt;&gt; snow_ice.set_attributes(snow_ice_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLSnowIce.__call__","title":"<code>__call__(check_errors=False)</code>","text":"<p>Consolidate the <code>&amp;snowice</code> parameters and return them as a  dictionary.</p> <p>The <code>__call__()</code> method consolidates model parameters set during class  instance initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>nml.NML</code> class. If <code>check_errors</code>  is <code>True</code>, the method performs validation checks on the parameters to  ensure they comply with expected formats and constraints. </p> <p>Parameters:</p> Name Type Description Default <code>check_errors</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Union[float, None]]</code> <p>A dictionary containing the <code>&amp;snowice</code> parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; snow_ice = nml.NMLSnowIce(\n...     snow_albedo_factor=1.0,\n...     snow_rho_min=40\n... )\n&gt;&gt;&gt; print(snow_ice(check_errors=False))\n{\n    'snow_albedo_factor': 1.0, \n    'snow_rho_min': 40, \n    'snow_rho_max': None\n}\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLTime","title":"<code>NMLTime</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Construct the <code>&amp;time</code> model parameters.</p> <p>The <code>&amp;time</code> parameters define the duration and timestep of a GLM  simulation. <code>NMLTime</code> provides the means to construct a dictionary  containing these parameters for use in the <code>nml.NML</code> class. Model  parameters are set as attributes upon initialising an instance of the class  or using the <code>set_attributes()</code> method. Class instances are callable and  return the dictionary of parameters.</p> <p>Attributes:</p> Name Type Description <code>timefmt</code> <code>Union[int, None]</code> <p>Time configuration switch. Options are <code>2</code> when using <code>start</code> and  <code>stop</code> parameters or <code>3</code> when using <code>num_days</code>. Default is <code>None</code>.</p> <code>start</code> <code>Union[str, None]</code> <p>Start time/date of simulation in format 'yyyy-mm-dd hhss'. Default is <code>None</code>.</p> <code>stop</code> <code>Union[str, None]</code> <p>End time/date of simulation in format 'yyyy-mm-dd hhss'. Used when <code>timefmt=2</code>. Default is <code>None</code>.</p> <code>dt</code> <code>Union[float, None]</code> <p>Time step (seconds). Default is <code>None</code></p> <code>num_days</code> <code>Union[int, None]</code> <p>Number of days to simulate. Used when <code>timefmt=3</code>. Default is <code>None</code>.</p> <code>timezone</code> <code>Union[float, None]</code> <p>UTC time zone. Default is <code>None</code>.  </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; time = nml.NMLTime(\n...     timefmt=3,\n...     start=\"1998-01-01 00:00:00\"\n... )\n&gt;&gt;&gt; time_attrs = {\n...     \"start\": \"1997-01-01 00:00:00\",\n...     \"stop\": \"1999-01-01 00:00:00\",\n...     \"dt\": 3600.0,\n...     \"num_days\": 730,\n...     \"timezone\": 7.0\n... }\n&gt;&gt;&gt; time.set_attributes(time_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLTime.__call__","title":"<code>__call__(check_errors=False)</code>","text":"<p>Consolidate the <code>&amp;time</code> parameters and return them as a  dictionary.</p> <p>The <code>__call__()</code> method consolidates model parameters set during class  instance initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>nml.NML</code> class. If <code>check_errors</code>  is <code>True</code>, the method performs validation checks on the parameters to  ensure they comply with expected formats and constraints. </p> <p>Parameters:</p> Name Type Description Default <code>check_errors</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Union[float, int, str, None]]</code> <p>A dictionary containing the <code>&amp;time</code> parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; time = nml.NMLTime(\n...     timefmt=3,\n...     start=\"1998-01-01 00:00:00\"\n... )\n&gt;&gt;&gt; print(time(check_errors=False))\n... {\n...     'timefmt': 3, \n...     'start': '1998-01-01 00:00:00', \n...     'stop': None, \n...     'dt': None, \n...     'num_days': None, \n...     'timezone': None\n... }\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLWQSetup","title":"<code>NMLWQSetup</code>","text":"<p>             Bases: <code>NMLBase</code></p> <p>Construct the <code>&amp;wq_setup</code> model parameters.</p> <p>The <code>&amp;wq_setup</code> parameters define the coupling of GLM with water quality  and biogeochemical model libraries, e.g., AED2. <code>NMLWQSetup</code> provides the  means to construct a dictionary containing these parameters for use in the  <code>nml.NML</code> class. Model parameters are set as attributes upon initialising  an instance of the class or using the <code>set_attributes()</code> method. Class  instances are callable and return the dictionary of parameters.</p> <p>wq_lib : Union[str, None]     Water quality model selection. Options are <code>\"aed2\"</code> and <code>\"fabm\"</code>.      Default is <code>None</code>. wq_nml_file : Union[str, None]     Filename of water quality configuration file, e.g., <code>\"./aed2.nml\"</code>.      Default is <code>None</code>. bioshade_feedback : Union[bool, None]     Switch to enable K_{w} to be updated by the WQ model. Default is      <code>None</code>. mobility_off : Union[bool, None]     Switch to enable settling within the WQ model. Default is <code>None</code>. ode_method : Union[int, None]     Method to use for ODE solution of water quality module. Default is     <code>None</code>. split_factor : Union[float, None]     Factor weighting implicit vs explicit numerical solution of the WQ     model. <code>split_factor</code> has a valid range between <code>0.0</code> and <code>1.0</code>.      Default is <code>None</code>. repair_state : Union[bool, None]     Switch to correct negative or out of range WQ variables. Default is     <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; wq_setup = nml.NMLWQSetup(\n...     wq_lib=\"aed2\",\n...     wq_nml_file = \"aed2/aed2.nml\"\n... )\n&gt;&gt;&gt; wq_setup_attrs = {\n...     \"wq_nml_file\": \"aed2/aed2.nml\",\n...     \"ode_method\": 1,\n...     \"split_factor\": 1,\n...     \"bioshade_feedback\": True,\n...     \"repair_state\": True,\n...     \"mobility_off\": False\n... }\n&gt;&gt;&gt; wq_setup.set_attributes(wq_setup_attrs)\n</code></pre>"},{"location":"nml/#glmpy.nml.NMLWQSetup.__call__","title":"<code>__call__(check_errors=False)</code>","text":"<p>Consolidate the <code>&amp;wq_setup</code> parameters and return them as a  dictionary.</p> <p>The <code>__call__()</code> method consolidates model parameters set during class  instance initialisation, or updated through <code>set_attributes()</code>, into a  dictionary suitable for use with the <code>nml.NML</code> class. If <code>check_errors</code>  is <code>True</code>, the method performs validation checks on the parameters to  ensure they comply with expected formats and constraints. </p> <p>Parameters:</p> Name Type Description Default <code>check_errors</code> <code>bool</code> <p>If <code>True</code>, performs validation checks on the parameters to ensure  compliance with GLM. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Union[float, int, str, bool, None]]</code> <p>A dictionary containing the <code>&amp;wq_setup</code> parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import nml\n&gt;&gt;&gt; wq_setup = nml.NMLWQSetup(\n...     wq_lib=\"aed2\",\n...     wq_nml_file = \"./aed2.nml\"\n... )\n&gt;&gt;&gt; print(wq_setup(check_errors=False))\n{\n    'wq_lib': 'aed2', \n    'wq_nml_file': './aed2.nml', \n    'bioshade_feedback': None, \n    'mobility_off': None, \n    'ode_method': None, \n    'split_factor': None, \n    'repair_state': None\n}\n</code></pre>"},{"location":"outflows/","title":"Outflows","text":""},{"location":"outflows/#glmpy.outflows.CustomOutflows","title":"<code>CustomOutflows</code>","text":"<p>Create a simple outflow timeseries for GLM.</p> <p>Generates an outflow timeseries in m^3/second between a given start and end datetime. The timeseries can be updated in two ways: 1. Providing a dictionary with specific datetimes and their  corresponding outflows. 2. Specifying a fixed outflow value between two datetimes. The outflow timeseries can be returned as a pandas DataFrame or exported to  a CSV file.</p> <p>Attributes:</p> Name Type Description <code>start_datetime</code> <code>Union[str, Timestamp, datetime]</code> <p>The start datetime of the outflow timeseries. Must be of type  Timestamp, datetime, or a valid datetime string.</p> <code>end_datetime</code> <code>Union[str, Timestamp, datetime]</code> <p>The end datetime of the outflow timeseries. Must be of type  Timestamp, datetime, or a valid datetime string.</p> <code>frequency</code> <code>str</code> <p>Frequency of the outflow timeseries. Must be either '24h' (daily) or '1h' (hourly). Default is '24h'.</p> <code>base_outflow</code> <code>Union[int, float]</code> <p>Base flow of the outflow timeseries in m^3/day or m^3/hour depending  on <code>frequency</code>. Default is 0.0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import outflows\n</code></pre> <p>Initialise a daily outflow timeseries with a base outflow of 0.0 m^3/day:</p> <pre><code>&gt;&gt;&gt; outflows = outflows.CustomOutflows(\n...     start_datetime=\"2020-01-01\",\n...     end_datetime=\"2020-01-10\",\n...     frequency=\"24h\",\n...     base_outflow=0.0\n... )\nUpdate the timeseries with a dictionary of specific dates and their\ncorresponding outflows in m^3/day:\n&gt;&gt;&gt; outflows_dict = {\n...     \"2020-01-02\": 2, # 2m^3/day\n...     \"2020-01-03\": 4, # 4m^3/day\n...     \"2020-01-04\": 6 # 6m^3/day\n... }\n&gt;&gt;&gt; outflows.set_on_datetime(outflows_dict)\n</code></pre> <p>Return and print the outflows timeseries as a pandas DataFrame. Note, the outflow units have been converted to m^3/second as expected by GLM:</p> <pre><code>&gt;&gt;&gt; print(outflows.get_outflows())\n        time      flow\n0 2020-01-01  0.000000\n1 2020-01-02  0.000023\n2 2020-01-03  0.000046\n3 2020-01-04  0.000069\n4 2020-01-05  0.000000\n5 2020-01-06  0.000000\n6 2020-01-07  0.000000\n7 2020-01-08  0.000000\n8 2020-01-09  0.000000\n9 2020-01-10  0.000000\n</code></pre> <p>Update the timeseries with a fixed outflow between two dates:</p> <pre><code>&gt;&gt;&gt; outflows.set_over_datetime(\n...     from_datetime=\"2020-01-05\",\n...     to_datetime = \"2020-01-09\",\n...     outflow = 5 # 5m^3/day\n... )\n</code></pre> <p>Return and print the outflows timeseries as a pandas DataFrame:</p> <pre><code>&gt;&gt;&gt; print(outflows.get_outflows())\n        time      flow\n0 2020-01-01  0.000000\n1 2020-01-02  0.000023\n2 2020-01-03  0.000046\n3 2020-01-04  0.000069\n4 2020-01-05  0.000058\n5 2020-01-06  0.000058\n6 2020-01-07  0.000058\n7 2020-01-08  0.000058\n8 2020-01-09  0.000058\n9 2020-01-10  0.000000\n</code></pre> <p>Write the outflows to a CSV without the index:</p> <pre><code>&gt;&gt;&gt; outflows.write_outflows(file_path=\"outflows.csv\")\n</code></pre>"},{"location":"outflows/#glmpy.outflows.CustomOutflows.get_outflows","title":"<code>get_outflows()</code>","text":"<p>Get the outflow timeseries.</p> <p>Returns the outflow timeseries as a pandas DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import outflows\n&gt;&gt;&gt; outflows = outflows.CustomOutflows(\n...     start_datetime=\"2020-01-01\",\n...     end_datetime=\"2020-01-10\",\n...     frequency=\"24h\",\n...     base_outflow=0.0\n... )\n&gt;&gt;&gt; outflows.get_outflows()\n</code></pre>"},{"location":"outflows/#glmpy.outflows.CustomOutflows.set_on_datetime","title":"<code>set_on_datetime(datetime_outflows)</code>","text":"<p>Set the outflow volume for specific datetimes.</p> <p>The outflow volume for specific datetimes can be set by providing a dictionary with datetimes as keys and outflow volumes as values. Outflow volumes will be treated as having the same units as the base  outflow (m^3/day or m^3/hour depending on <code>frequency</code>).</p> <p>Parameters:</p> Name Type Description Default <code>datetime_outflows</code> <code>Dict[Union[str, pd.Timestamp, dt.datetime], </code> required <code>Union</code> <p>Dictionary with valid datetimes as keys and outflow volumes as  values.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import outflows\n&gt;&gt;&gt; outflows = outflows.CustomOutflows(\n...     start_datetime=\"2020-01-01 00:00:00\",\n...     end_datetime=\"2020-01-01 10:00:00\",\n...     frequency=\"1h\",\n...     base_outflow=0.0\n... )\n&gt;&gt;&gt; outflows_dict = {\n...     \"2020-01-01 01:00:00\": 10,\n...     \"2020-01-01 03:00:00\": 12,\n...     \"2020-01-01 05:00:00\": 14\n... }\n&gt;&gt;&gt; outflows.set_on_datetime(outflows_dict)\n&gt;&gt;&gt; print(outflows.get_outflows())\n                  time      flow\n0  2020-01-01 00:00:00  0.000000\n1  2020-01-01 01:00:00  0.002778\n2  2020-01-01 02:00:00  0.000000\n3  2020-01-01 03:00:00  0.003333\n4  2020-01-01 04:00:00  0.000000\n5  2020-01-01 05:00:00  0.003889\n6  2020-01-01 06:00:00  0.000000\n7  2020-01-01 07:00:00  0.000000\n8  2020-01-01 08:00:00  0.000000\n9  2020-01-01 09:00:00  0.000000\n10 2020-01-01 10:00:00  0.000000\n</code></pre>"},{"location":"outflows/#glmpy.outflows.CustomOutflows.set_over_datetime","title":"<code>set_over_datetime(from_datetime, to_datetime, outflow)</code>","text":"<p>Set the outflow volume between two datetimes.</p> <p>Outflow volumes between two datetimes can be set by providing a start datetime, end datetime, and an outflow volume. Outflows are updated on the start and end datetime.</p> <p>Parameters:</p> Name Type Description Default <code>from_datetime</code> <code>Union[str, Timestamp, datetime]</code> <p>The datetime to update the outflow timeseries from.</p> required <code>to_datetime</code> <code>Union[str, Timestamp, datetime]</code> <p>The datetime to update the outflow timeseries to.</p> required <code>outflow</code> <code>Union[float, int]</code> <p>The outflow volume to set between the <code>from_datetime</code> and <code>to_datetime</code> in m^3/day or m^3/hour (depending on <code>frequency</code>).</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import outflows\n&gt;&gt;&gt; outflows = outflows.CustomOutflows(\n...     start_datetime=\"2020-01-01 00:00:00\",\n...     end_datetime=\"2020-01-01 10:00:00\",\n...     frequency=\"1h\",\n...     base_outflow=0.0\n... )\n&gt;&gt;&gt; outflows.set_over_datetime(\n...     from_datetime=\"2020-01-01 01:00:00\",\n...     to_datetime = \"2020-01-01 09:00:00\",\n...     outflow = 5\n... )\n&gt;&gt;&gt; print(outflows.get_outflows())\n                  time      flow\n0  2020-01-01 00:00:00  0.000000\n1  2020-01-01 01:00:00  0.001389\n2  2020-01-01 02:00:00  0.001389\n3  2020-01-01 03:00:00  0.001389\n4  2020-01-01 04:00:00  0.001389\n5  2020-01-01 05:00:00  0.001389\n6  2020-01-01 06:00:00  0.001389\n7  2020-01-01 07:00:00  0.001389\n8  2020-01-01 08:00:00  0.001389\n9  2020-01-01 09:00:00  0.001389\n10 2020-01-01 10:00:00  0.000000\n</code></pre>"},{"location":"outflows/#glmpy.outflows.CustomOutflows.write_outflows","title":"<code>write_outflows(file_path)</code>","text":"<p>Write the outflow timeseries to a CSV file.</p> <p>The outflow timeseries can be written to a CSV file by providing a path to the CSV file. The index of the DataFrame is not included in the  CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the CSV file to which the outflow timeseries will be written.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from glmpy import outflows\n&gt;&gt;&gt; outflows = outflows.CustomOutflows(\n...     start_datetime=\"2020-01-01\",\n...     end_datetime=\"2020-01-10\",\n...     frequency=\"24h\",\n...     base_outflow=10\n... )\n&gt;&gt;&gt; outflows.write_outflows(file_path=\"outflows.csv\")\n</code></pre>"},{"location":"simulation/","title":"Simulation","text":""},{"location":"simulation/#glmpy.simulation.GLMPostProcessor","title":"<code>GLMPostProcessor</code>","text":"<p>Class to process outputs of GLM simulation.</p> <p>Attributes:</p> Name Type Description <code>outputs_path</code> <code>str</code> <p>Path to directory where GLM outputs have been written.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; import shutil\n</code></pre> <pre><code>&gt;&gt;&gt; from glmpy import simulation as sim\n</code></pre> <pre><code>&gt;&gt;&gt; files = {\n&gt;&gt;&gt;    \"glm3.nml\": os.path.join(os.getcwd(), \"glm3.nml\"),\n&gt;&gt;&gt;    \"met.csv\": os.path.join(os.getcwd(), \"met.csv\"),\n&gt;&gt;&gt; }\n</code></pre> <pre><code>&gt;&gt;&gt; # running local instance of GLM\n&gt;&gt;&gt; glm_run = sim.GLMSim(files, False, \"/inputs\")\n&gt;&gt;&gt; inputs_dir = glm_run.prepare_inputs()\n</code></pre> <pre><code>&gt;&gt;&gt; glm_run.glm_run(inputs_dir, \"/glm/glm\")\n</code></pre> <pre><code>&gt;&gt;&gt; outputs_dir = os.path.join(inputs_dir, \"output\")\n</code></pre> <pre><code>&gt;&gt;&gt; # initialise GLMPostProcessor object\n&gt;&gt;&gt; glm_process = sim.GLMPostProcessor(outputs_dir)\n</code></pre> <pre><code>&gt;&gt;&gt; # create zipfile of GLM outputs\n&gt;&gt;&gt; # csv file and netcdf\n&gt;&gt;&gt; # returns path to zipfile of outputs\n&gt;&gt;&gt; files_zip_path = glm_process.zip_outputs()\n</code></pre> <pre><code>&gt;&gt;&gt; # create zipfile of csv GLM outputs\n&gt;&gt;&gt; files_zip_csv_path = glm_process.zip_csvs()\n</code></pre> <pre><code>&gt;&gt;&gt; # create zipfile of JSON GLM outputs\n&gt;&gt;&gt; files_zip_json_path = glm_process.zip_json()\n</code></pre>"},{"location":"simulation/#glmpy.simulation.GLMPostProcessor.csv_to_json","title":"<code>csv_to_json(csv_lake_fname, variables)</code>","text":"<p>Converts outputs of GLM simulation in csv format to JSON.</p> <p>Can be used as a step before saving GLM results to JSON files or to generate JSON formatted data that can be returned to clients for rendering in web browers; for example, if GLM is being used as part of a web application.</p> <p>Parameters:</p> Name Type Description Default <code>csv_lake_fname</code> <code>str</code> <p>File name of csv of outputs from GLM - <code>lake.csv</code>.</p> required <code>variables</code> <code>list</code> <p>List of variable names from <code>lake.csv</code> to select and convert to JSON format..</p> required <p>Returns:</p> Type Description <code>dict     JSON formatted results of GLM simulation.</code>"},{"location":"simulation/#glmpy.simulation.GLMPostProcessor.csv_to_json_files","title":"<code>csv_to_json_files()</code>","text":"<p>Convert csv of GLM outputs to JSON format and writes to a <code>.json</code> file.</p>"},{"location":"simulation/#glmpy.simulation.GLMPostProcessor.zip_csvs","title":"<code>zip_csvs()</code>","text":"<p>Creates a zipfile of csv GLM outputs (csv outputs only).</p> <p>Use this if you do not need a netcdf file of GLM outputs.</p> <p>Returns:</p> Type Description <code>str     Path to zipfile of GLM outputs.</code>"},{"location":"simulation/#glmpy.simulation.GLMPostProcessor.zip_json","title":"<code>zip_json()</code>","text":"<p>Creates a zipfile of csv GLM outputs converted to JSON format.</p> <p>Use this, for example, if you are using GLM within a web application and outputs from GLM simulations are being passed between clients and servers. Saving outputs of GLM simulations to JSON format is useful if you want to render results in a web browser, for example.</p> <p>Returns:</p> Type Description <code>str     Path to zipfile of GLM outputs.</code>"},{"location":"simulation/#glmpy.simulation.GLMPostProcessor.zip_outputs","title":"<code>zip_outputs()</code>","text":"<p>Creates a zipfile of GLM outputs (csv and netcdf outputs).</p> <p>Returns:</p> Type Description <code>str     Path to zipfile of GLM outputs.</code>"},{"location":"simulation/#glmpy.simulation.GLMSim","title":"<code>GLMSim</code>","text":"<p>Prepare inputs and run a GLM simulation.</p> <p>The <code>GLMSim</code> class has attributes and methods that handle running GLM simulations and processing the results.</p> <p>The class is designed to work with GLM simulations running on local instances of GLM or instances of GLM behind a FastAPI web API (i.e. when running GLM simulations as a web service). When running GLM locally input files required for a simulation (e.g. glm3.nml, met.csv) should be passed in as dict object with the format: <code>{\"&lt;filename&gt;\": \"&lt;path-to-file&gt;\"}. When running GLM behind a web API, input files can be sent to the server from a client through a HTTP request and will be processed as a FastAPI</code>UploadFile` object: https://fastapi.tiangolo.com/tutorial/request-files/#uploadfile</p> <p>Attributes:</p> Name Type Description <code>input_files</code> <code>Union[UploadFile, dict]</code> <p>FastAPI <code>UploadFile</code> object storing input files for a GLM simulation or, if running GLM locally or outside a FastAPI environment a dict of filenames (keys) and paths to files (values).</p> <code>api</code> <code>bool</code> <p>If True, GLM is run using FastAPI engine. Otherwise, local GLM versions.</p> <code>inputs_dir</code> <code>str</code> <p>File path to directory to save input files for GLM simulation.</p> <p>Examples:</p> <p>Running GLM as a web service behind a FastAPI endpoint. <code>files</code> is a FastAPI <code>UploadFile</code> object.</p> <pre><code>&gt;&gt;&gt; import glmpy.simulation as sim\n&gt;&gt;&gt; glm_sim = sim.GLMSim(files, True, \"/inputs\")\n&gt;&gt;&gt; inputs_dir = glm_sim.prepare_inputs()\n&gt;&gt;&gt; glm_sim.glm_run(inputs_dir, \"/glm/glm\")\n</code></pre> <p>Running GLM locally. <code>files</code> is a dict object with paths to where input files are stored.</p> <pre><code>&gt;&gt;&gt; import glmpy.simulation as sim\n&gt;&gt;&gt; files = {\n&gt;&gt;&gt;    \"glm3.nml\": \"/path/to/glm3.nml\",\n&gt;&gt;&gt;    \"met.csv\": \"/path/to/met.csv\"\n&gt;&gt;&gt; }\n&gt;&gt;&gt; glm_sim = sim.GLMSim(files, False, \"/inputs\")\n&gt;&gt;&gt; inputs_dir = glm_sim.prepare_inputs()\n&gt;&gt;&gt; glm_sim.glm_run(inputs_dir, \"/glm/glm\")\n</code></pre>"},{"location":"simulation/#glmpy.simulation.GLMSim.bundled_glm_path","title":"<code>bundled_glm_path()</code>  <code>staticmethod</code>","text":"<p>Path of the bundled GLM executable.</p> <p>Returns the path of the internally bundled GLM executable. If the  executable does not exist in the expected path, <code>bundled_glm_path()</code>  returns <code>None</code>.</p>"},{"location":"simulation/#glmpy.simulation.GLMSim.glm_run","title":"<code>glm_run(inputs_dir, glm_path=None)</code>","text":"<p>Run a GLM simulation.</p> <p>Parameters:</p> Name Type Description Default <code>inputs_dir</code> <code>str</code> <p>File path to directory with input files required for a GLM simulation.</p> required <code>glm_path</code> <code>Union[str, None]</code> <p>Path to location of GLM binary. If None, the internally bundled GLM executable will be called.</p> <code>None</code>"},{"location":"simulation/#glmpy.simulation.GLMSim.prepare_inputs","title":"<code>prepare_inputs()</code>","text":"<p>Prepare input files for a GLM simulation.</p> <p>If <code>inputs_dir</code> exists, it will be deleted and a new directory created with new input files.</p> <p>Returns:</p> Type Description <code>str</code> <p>File path to directory with input files required for a GLM  simulation.</p>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#latest-posts","title":"Latest Posts","text":""},{"location":"blog/2024/03/22/glm-py-released-/","title":"glm-py released! \ud83d\ude80","text":"<p>We're pleased to announce the first public release of glm-py on pip!</p> <p>glm-py <code>0.1.3</code> provides a Python interface to the General Lake Model (GLM) that  abstracts away the complexity of building and running simulations. It is now easier than ever to use GLM for research, education, and software development. </p> <p>In the first release of glm-py we've prioritised providing functionality for  the core components of modelling a water body with GLM, i.e., writing the  <code>.nml</code> file, preparing the model inputs, and running GLM. The <code>nml</code> module of  glm-py lets you configure your model parameters without ever needing to open a <code>.nml</code> file. glm-py translates parameters defined in Python dictionaries to  the format expected by GLM. The benefits of this approach include: type hints  for explicitly declaring expected parameter types, removal of <code>.nml</code> syntax  errors, and raising helpful error messages to enforce parameter compliance  (coming soon!). The <code>simulation</code> module streamlines how you prepare and run  your simulation. glm-py can automatically create a directory of your input  files that matches the structure expected by GLM. Running the model is as  simple as calling <code>glm_run()</code> - no need to use the command line. These features  make running GLM less complex and more accessible.</p> <p>In addition to the writing <code>.nml</code> files and running simulations, glm-py  provides tools to automate time consuming tasks and support the development of web applications. For example, the <code>dimensions</code> module lets you easily  calculate the <code>H</code> and <code>A</code> parameters for common water body morphometries. The creation of CSV inputs is also simiplified with the <code>inflows</code> and  <code>outflows</code> modules. Meanwhile, developers can integrate GLM into web frameworks by leveraging classes in the <code>glm_json</code> and <code>simulation</code> modules. More useful  functionality will follow in future releases and we'd love to hear your input on how we can expand this toolkit.</p> <p>Looking ahead, the development of glm-py is planning to incorporate:</p> <ul> <li>Complete error checking of model parameters</li> <li>A calibration module</li> <li>Expanded functionality for AED</li> </ul> <p>We encourage you to use glm-py and engage with the project on GitHub. Be sure to browse this documentation website for a complete guide on using the  package. </p> <p>Happy modelling!</p>"},{"location":"blog/2024/03/22/modelling-sparkling-lake-with-glm-py/","title":"Modelling Sparkling Lake with glm-py","text":"<p>This tutorial guides users through the process of setting up a model of  Sparkling Lake using glm-py.</p> <p> </p> <p>Sparkling Lake is an oligotrophic, northern temperate lake (89.7 \u00baN, 46.3 \u00baW) in Winconsin, USA. The lake is approximately 20m deep and covers a surface area of 0.638km<sup>2</sup>. This tutorial serves an introduction to the two core modules of glm-py - <code>nml</code> and <code>simulation</code>. You will use glm-py to model Sparkling Lake for 2 years (1980-04-15 to 1982-04-15).</p> <p>If you haven't already, install glm-py using <code>pip</code>:</p> <pre><code>pip install glm-py\n</code></pre>"},{"location":"blog/2024/03/22/modelling-sparkling-lake-with-glm-py/#creating-a-glm-nml-file","title":"Creating a GLM <code>.nml</code> file","text":"<p>To begin, start by importing the <code>nml</code> module from <code>glmpy</code>:</p> <pre><code>from glmpy import nml\n</code></pre> <p>The <code>nml</code> module provides a set of classes to construct GLM's namelist file (<code>.nml</code>).  A <code>.nml</code> file is divided into multiple \"blocks\" that configure specific aspects of the model, e.g., the <code>&amp;morphometry</code> block defines morphometry of the water body. The structure of a <code>.nml</code> file is shown below for the four minimum required blocks (<code>...</code> indicates that the block contains more parameters than shown):</p> <pre><code>&amp;glm_setup\n  sim_name = 'GLMSimulation'\n  ...\n/\n&amp;morphometry\n  lake_name = 'my_lake'\n  ...\n/\n&amp;time\n  timefmt = 3\n  ...\n/\n&amp;init_profiles\n  lake_depth = 10\n  ...\n/\n</code></pre>"},{"location":"blog/2024/03/22/modelling-sparkling-lake-with-glm-py/#model-setup","title":"Model setup","text":"<p>GLM simulates the dynamics of a water body by dividing it into a vertically stacked series of layers. The compulsory <code>&amp;glm_setup</code> block defines the structure of these layers, e.g., the maximum number of layers, the minimum layer volume, and the minimum and maximum layer thicknesses. To configure the <code>&amp;glm_setup</code> parameters for Sparkling Lake, you would typically write a <code>.nml</code> file that contains the following:</p> <pre><code>&amp;glm_setup \n   sim_name = 'Sparkling Lake'\n   max_layers = 500\n   min_layer_vol = 0.5\n   min_layer_thick = 0.15\n   max_layer_thick = 0.5\n   density_model = 1\n   non_avg = .true.\n/\n</code></pre> <p>Using glm-py, you instead configure the <code>&amp;glm_setup</code> block by using the <code>NMLGLMSetup</code> class from the <code>nml</code> module. Each model parameter of the <code>&amp;glm_setup</code> block has a corresponding attribute in the <code>NMLGLMSetup</code> class:</p> <pre><code>glm_setup = nml.NMLGLMSetup(\n    sim_name='Sparkling Lake',\n    max_layers=500,\n    min_layer_vol=0.5,\n    min_layer_thick=0.15,\n    max_layer_thick=0.5,\n    density_model=1,\n    non_avg=True\n)\n</code></pre> <p>This approach offers a number of advantages over editing a raw <code>.nml</code> file:</p> <ul> <li>Explicit type hinting for parameter types</li> <li>Native Python syntax</li> <li>Error checking</li> </ul> <p>Alternatively, these parameters can also be defined in a dictionary and set as class attributes using the <code>set_attributes()</code> method:</p> <pre><code>glm_setup = nml.NMLGLMSetup()\n\nglm_setup_attrs = {\n    'sim_name': 'Sparkling Lake',\n    'max_layers': 500,\n    'min_layer_vol': 0.5,\n    'min_layer_thick': 0.15,\n    'max_layer_thick': 0.5,\n    'density_model': 1,\n    'non_avg': True\n}\n\nglm_setup.set_attributes(glm_setup_attrs)\n</code></pre> <p>Once the attributes are set, you can return a dictionary of the consolidated model parameters by calling the instance of the <code>NMLGLMSetup()</code> class:</p> <pre><code>glm_setup_parameters = glm_setup()\nprint(glm_setup_parameters)\n</code></pre> <p><pre><code>{'sim_name': 'Sparkling Lake', 'max_layers': 500, 'min_layer_vol': 0.5, 'min_layer_thick': 0.15, 'max_layer_thick': 0.5, 'density_model': 1, 'non_avg': True}\n</code></pre> The call method provides an optional <code>check_errors</code> parameter. If set to <code>True</code>, glm-py will validate the model parameters and raise errors if non-compliance is detected. Note, <code>check_errors</code> is not fully implemented in glm-py <code>0.0.1</code>.</p> <pre><code>FutureWarning: Error checking is not stable and lacks complete coverage. Erroneous parameters may not be raised.\n  glm_setup(check_errors=True)\n\n{'sim_name': 'Sparkling Lake',\n 'max_layers': 500,\n 'min_layer_vol': 0.5,\n 'min_layer_thick': 0.15,\n 'max_layer_thick': 0.5,\n 'density_model': 1,\n 'non_avg': True}\n</code></pre>"},{"location":"blog/2024/03/22/modelling-sparkling-lake-with-glm-py/#mixing-and-morphometry","title":"Mixing and morphometry","text":"<p>Next, let's set the parameters that control the mixing processes within Sparkling Lake. Just as <code>NMLGLMSetup</code> defines the <code>&amp;glm_setup</code> block, we can configure the <code>&amp;mixing</code> block using the <code>NMLMixing</code> class:</p> <pre><code>mixing = nml.NMLMixing(\n    surface_mixing=1,\n    coef_mix_conv=0.2,\n    coef_wind_stir=0.402,\n    coef_mix_shear=0.2,\n    coef_mix_turb=0.51,\n    coef_mix_KH=0.3,\n    deep_mixing=2,\n    coef_mix_hyp=0.5,\n    diff=0.0\n)\n</code></pre> <p>Let's repeat the same for the <code>&amp;morphometry</code> block - use the <code>NMLMorphometry</code> class:</p> <pre><code>morphometry = nml.NMLMorphometry(\n    lake_name='Sparkling',\n    latitude=46.00881,\n    longitude=-89.69953,\n    bsn_len=901.0385,\n    bsn_wid=901.0385,\n    crest_elev=320.0,\n    bsn_vals=15,\n    H=[301.712, 303.018285714286, 304.324571428571,\n        305.630857142857, 306.937142857143, 308.243428571429,\n        309.549714285714, 310.856, 312.162285714286,\n        313.468571428571, 314.774857142857, 316.081142857143,\n        317.387428571429, 318.693714285714, 320, 321],\n    A=[0, 45545.8263571429, 91091.6527142857,\n        136637.479071429, 182183.305428571, 227729.131785714,\n        273274.958142857, 318820.7845, 364366.610857143,\n        409912.437214286, 455458.263571429, 501004.089928571,\n        546549.916285714, 592095.742642857, 637641.569, 687641.569]\n)\n</code></pre>"},{"location":"blog/2024/03/22/modelling-sparkling-lake-with-glm-py/#setting-the-remaining-blocks","title":"Setting the remaining blocks","text":"<p>There are up to 14 configurable blocks in the GLM namelist file - setting each will take some time! Let's speed up the process by importing a JSON file that contains the parameters for the remaining blocks. We'll use the <code>JSONReader</code> class from the <code>glm_json</code> module to extract the relevant parameters from each respective block. Download the JSON file to your working directory using <code>curl</code>:</p> <pre><code>curl https://raw.githubusercontent.com/WET-tool/glm-py/main/notebooks/glmpy-demo/sparkling-nml.json --output sparkling-nml.json\n</code></pre> <p>Now import the <code>glm_json</code> module and initalise the <code>JSONReader</code> class by passing in the file path of the JSON file we just downloaded:</p> <p><pre><code>from glmpy import glm_json\n\nmy_json_file = glm_json.JSONReader(\"sparkling-nml.json\")\n</code></pre> Next, let's extract the parameters for the <code>&amp;meteorology</code> block using the <code>get_nml_parameters()</code> method:</p> <pre><code>meteorology_attrs = my_json_file.get_nml_parameters(\"&amp;meteorology\")\n</code></pre> <p>Take a look at what <code>meteorology_attrs</code> contains:</p> <pre><code>print(meteorology_attrs)\n</code></pre> <pre><code>{'met_sw': True, 'lw_type': 'LW_IN', 'rain_sw': False, 'atm_stab': 0, 'catchrain': False, 'rad_mode': 1, 'albedo_mode': 1, 'cloud_mode': 4, 'fetch_mode': 0, 'subdaily': False, 'meteo_fl': 'bcs/nldas_driver.csv', 'wind_factor': 1, 'sw_factor': 1.08, 'lw_factor': 1, 'at_factor': 1, 'rh_factor': 1, 'rain_factor': 1, 'ce': 0.00132, 'ch': 0.0014, 'cd': 0.0013, 'rain_threshold': 0.01, 'runoff_coef': 0.3}\n</code></pre> <p>This is a dictionary containing all parameters for the <code>&amp;meteorology</code> block. Let's pass these to the <code>NMLMeteorology</code> class with the <code>set_attributes()</code> method:</p> <pre><code>meteorology = nml.NMLMeteorology()\nmeteorology.set_attributes(meteorology_attrs)\nprint(meteorology())\n</code></pre> <pre><code>{'met_sw': True, 'meteo_fl': 'bcs/nldas_driver.csv', 'subdaily': False, 'time_fmt': None, 'rad_mode': 1, 'albedo_mode': 1, 'sw_factor': 1.08, 'lw_type': 'LW_IN', 'cloud_mode': 4, 'lw_factor': 1, 'atm_stab': 0, 'rh_factor': 1, 'at_factor': 1, 'ce': 0.00132, 'ch': 0.0014, 'rain_sw': False, 'rain_factor': 1, 'catchrain': False, 'rain_threshold': 0.01, 'runoff_coef': 0.3, 'cd': 0.0013, 'wind_factor': 1, 'fetch_mode': 0, 'Aws': None, 'Xws': None, 'num_dir': None, 'wind_dir': None, 'fetch_scale': None}\n</code></pre> <p>Easy! But before we go any futher, look closely at the <code>meteo_fl</code> parameter - what's <code>bcs/nldas_driver.csv</code>? This is a path to a CSV that contains boundary condition data for Sparkling Lake, e.g., daily rainfall, wind speed, and air temperature. You'll need this file to run the model. Let's download it with <code>curl</code> and place it in sub-directory called <code>bcs</code>:</p> <pre><code>mkdir bcs\ncurl https://raw.githubusercontent.com/WET-tool/glm-py/main/notebooks/glmpy-demo/bcs/nldas_driver.csv --output bcs/nldas_driver.csv\n</code></pre> <p>Now, let's setup the remaining blocks:  <code>&amp;output</code>, <code>&amp;init_profiles</code>, <code>&amp;time</code>, <code>&amp;bird_model</code>, <code>&amp;light</code>, <code>&amp;sediment</code>. We'll use <code>get_nml_parameters</code> to return dictionaries of parameters that will set the attributes of the corresponding <code>nml.NML*</code> classes:</p> <pre><code>output_attrs=my_json_file.get_nml_parameters(\"&amp;output\")\ninit_profiles_attrs=my_json_file.get_nml_parameters(\"&amp;init_profiles\")\ntime_attrs=my_json_file.get_nml_parameters(\"&amp;time\")\nlight_attrs=my_json_file.get_nml_parameters(\"&amp;light\")\nbird_model_attrs=my_json_file.get_nml_parameters(\"&amp;bird_model\")\nsediment_attrs=my_json_file.get_nml_parameters(\"&amp;sediment\")\nwq_setup_attrs=my_json_file.get_nml_parameters(\"&amp;wq_setup\")\n</code></pre> <p>Now initialise the respective classes:</p> <pre><code>output = nml.NMLOutput()\ninit_profiles = nml.NMLInitProfiles()\ntime = nml.NMLTime()\nlight = nml.NMLLight()\nbird_model = nml.NMLBirdModel()\nsediment = nml.NMLSediment()\nwq_setup = nml.NMLWQSetup()\n</code></pre> <p>And set the attributes:</p> <pre><code>output.set_attributes(output_attrs)\ninit_profiles.set_attributes(init_profiles_attrs)\ntime.set_attributes(time_attrs)\nlight.set_attributes(light_attrs)\nbird_model.set_attributes(bird_model_attrs)\nsediment.set_attributes(sediment_attrs)\nwq_setup.set_attributes(wq_setup_attrs)\n</code></pre> <p>If you're want to find out more about the attributes for each block, check out glm-py's documentation website.</p>"},{"location":"blog/2024/03/22/modelling-sparkling-lake-with-glm-py/#writing-the-namelist-file","title":"Writing the namelist file","text":"<p>We now have the attributes set for each block. Let's combine them to create the <code>.nml</code> file. First, create an instance of the <code>NML</code> class. Then pass in the dictionaries of consolidated parameters, i.e., from <code>glm_setup()</code>, <code>mixing()</code>, <code>morphometry()</code>, etc:</p> <pre><code>nml = nml.NML(\n  glm_setup=glm_setup(),\n  mixing=mixing(),\n  morphometry=morphometry(),\n  time=time(),\n  output=output(),\n  init_profiles=init_profiles(),\n  meteorology=meteorology(),\n  bird_model=bird_model(),\n  light=light(),\n  sediment=sediment()\n)\n</code></pre> <p>Finally, use the <code>write_nml()</code> method to save the <code>.nml</code> to your working directory:</p> <pre><code>nml.write_nml(nml_file_path='glm3.nml')\n</code></pre>"},{"location":"blog/2024/03/22/modelling-sparkling-lake-with-glm-py/#running-the-model","title":"Running the model","text":"<p>Model configuration is now complete! To run our Sparkling Lake simulation, import the <code>simulation</code> module:</p> <pre><code>from glmpy import simulation\n</code></pre> <p>We now need to specify the location of any files that we'll use in the simulation. For Sparkling Lake, that's just your newly created <code>glm3.nml</code> and the meterological boundary condition file <code>nldas_driver.csv</code>. These will be defined in a dictionary where the key is the filename and the value is the file path:</p> <pre><code>files = {\n    \"glm3.nml\": \"glm3.nml\",\n    \"nldas_driver.csv\": \"bcs/nldas_driver.csv\"\n}\n</code></pre> <p>Now pass this dictionary to a new instance of the <code>GLMSim</code> class. <code>GLMSim</code> is used prepare a new directory of model inputs that we'll point GLM at . Set <code>api</code> to <code>False</code> to run the simulation locally and set <code>inputs_dir</code> to the name of the inputs directory that will be created:</p> <pre><code>glm_sim = simulation.GLMSim(\n  input_files=files,\n  api=False,\n  inputs_dir=\"inputs\"\n)\n</code></pre> <p>Create the <code>inputs</code> directory by calling the <code>.prepare_inputs()</code> method:</p> <pre><code>inputs_dir = glm_sim.prepare_inputs()\n</code></pre> <p>You should now have a new directory that looks like this:</p> <pre><code>\u251c\u2500\u2500 bcs\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 nldas_driver.csv\n\u251c\u2500\u2500 glm3.nml\n</code></pre> <p>Finally, run the simulation by calling the <code>.glm_run()</code> method and pass in the <code>inputs_dir</code> object:</p> <pre><code>glm_sim.glm_run(inputs_dir=inputs_dir)\n</code></pre> <p>Congratulations! You've now configured and run a GLM simulation entirely in Python. You should see a new sub-directory called <code>outputs</code> within the <code>inputs</code> directory that contains the model results.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>glm-py is an open source project that is actively maintained by the Aquatic  EcoDynamics research group at the University of Western Australia. Whether you're an experienced GLM user, or are new to modelling hydrodynamics, we would appreciate your feedback and input on using this package. </p>"},{"location":"contributing/#suggested-contributions","title":"Suggested contributions","text":"<ul> <li> <p> Documenting model parameters</p> <p>Many GLM parameters are lacking adequate documentation in their respective <code>nml.NML*</code> classes. Please open an issue if you can improve on the  documentation or provide parameter units (where applicable).</p> <p> Open a docs issue</p> </li> <li> <p> Found a bug?</p> <p>While glm-py is in its infancy, you may encounter a bug in unexpected use  cases. Please open an issue and provide a reproducible example if you've  identified a bug.</p> <p> Report a bug</p> </li> </ul>"},{"location":"how_to/how-to-dimensions/","title":"How-to: <code>dimensions</code> module","text":""},{"location":"how_to/how-to-dimensions/#calculating-the-morphometry-parameters-for-simple-water-bodies","title":"Calculating the morphometry parameters for simple water bodies","text":"<p>For simple water bodies, glm-py provides functionality to easily calculate the <code>H</code> and <code>A</code> (height and surface area) parameters for the <code>NMLMorphometry</code> class, i.e., the <code>&amp;morphometry</code> configuration block.</p> <p>The <code>InvertedTruncatedSquarePyramid</code> class can be used to retrieve these parameters for pyramidal water bodies with a square base, e.g., an on-farm reservoir.</p> <p> </p> <pre><code>from glmpy import dimensions\n\nmy_dimensions = dimensions.InvertedTruncatedSquarePyramid(\n    height=6,\n    surface_length=40,\n    side_slope=1/3,\n    num_vals=7,\n    surface_elevation=0\n)\n</code></pre> <p>Heights and surface areas can be then returned with the <code>get_heights()</code> and <code>get_surface_areas()</code> methods:</p> <pre><code>print(my_dimensions.get_heights())\nprint(my_dimensions.get_surface_areas())\n</code></pre> <pre><code>[-6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0]\n[16.0, 100.0, 256.0, 484.0, 784.0, 1156.0, 1600.0]\n</code></pre>"},{"location":"how_to/how-to-dimensions/#num_vals","title":"<code>num_vals</code>","text":"<p>Notice how the length of lists returned by <code>get_heights()</code> and <code>get_surface_areas</code> equals the <code>num_vals</code> attribute? <code>num_vals</code> can be used to increase or decrease the the number of <code>H</code> and <code>A</code> values calculated between the top and bottom of the water body.</p> <p>Increasing <code>num_vals</code>:</p> <pre><code>my_dimensions = dimensions.InvertedTruncatedSquarePyramid(\n    height=6,\n    surface_length=40,\n    side_slope=1/3,\n    num_vals=9,\n    surface_elevation=0\n)\nprint(my_dimensions.get_heights())\nprint(my_dimensions.get_surface_areas())\n</code></pre> <pre><code>[-6.0, -5.25, -4.5, -3.75, -3.0, -2.25, -1.5, -0.75, 0.0]\n[16.0, 72.25, 169.0, 306.25, 484.0, 702.25, 961.0, 1260.25, 1600.0]\n</code></pre> <p>Decreasing <code>num_vals</code>:</p> <pre><code>my_dimensions = dimensions.InvertedTruncatedSquarePyramid(\n    height=6,\n    surface_length=40,\n    side_slope=1/3,\n    num_vals=4,\n    surface_elevation=0\n)\nprint(my_dimensions.get_heights())\nprint(my_dimensions.get_surface_areas())\n</code></pre> <pre><code>[-6.0, -4.0, -2.0, 0.0]\n[16.0, 256.0, 784.0, 1600.0]\n</code></pre>"},{"location":"how_to/how-to-dimensions/#surface_elevation","title":"<code>surface_elevation</code>","text":"<p>The elevation of the water body can be adjusted through the <code>surface_elevation</code> attribute.</p> <p>Surface elevation of 100m:</p> <pre><code>my_dimensions = dimensions.InvertedTruncatedSquarePyramid(\n    height=6,\n    surface_length=40,\n    side_slope=1/3,\n    num_vals=7,\n    surface_elevation=100\n)\nprint(my_dimensions.get_heights())\n</code></pre> <pre><code>[94.0, 95.0, 96.0, 97.0, 98.0, 99.0, 100.0]\n</code></pre> <p>Surface elevation of -100m:</p> <pre><code>my_dimensions = dimensions.InvertedTruncatedSquarePyramid(\n    height=6,\n    surface_length=40,\n    side_slope=1/3,\n    num_vals=7,\n    surface_elevation=100\n)\nprint(my_dimensions.get_heights())\n</code></pre> <pre><code>[-106.0, -105.0, -104.0, -103.0, -102.0, -101.0, -100.0]\n</code></pre>"},{"location":"how_to/how-to-dimensions/#invalid-dimensions","title":"Invalid dimensions","text":"<p>If <code>InvertedTruncatedSquarePyramid</code> is initialised with invalid dimensions, glm-py will raise an error and tell you how to correct it:</p> <pre><code>my_dimensions = dimensions.InvertedTruncatedSquarePyramid(\n    height=6,\n    surface_length=1, # &lt;-- invlaid surface_length\n    side_slope=1/3,\n    num_vals=7,\n    surface_elevation=0\n)\n</code></pre> <pre><code>ValueError: Invalid combination of height, surface_length, and side_slope attributes. The calculated base_length of the water body is currently &lt;= 0. base_length is calculated by (surface_length-(height/side_slope)*2). Adjust your input attributes to calculate a positive base_length value.\n</code></pre>"},{"location":"how_to/how-to-dimensions/#constructing-the-morphometry-parameters","title":"Constructing the <code>&amp;morphometry</code> parameters","text":"<p>You can plug the lists returned by the <code>get_heights()</code> and <code>get_surface_areas</code> methods directly into the <code>NMLMorphometry</code> class from the <code>nml</code> module. Remember to set the <code>bsn_vals</code> attribute in <code>NMLMorphometry</code> to equal the <code>num_vals</code> attribute:</p> <pre><code>from glmpy import dimensions, nml\n\nnum_vals=7\n\nmy_dimensions = dimensions.InvertedTruncatedSquarePyramid(\n    height=6,\n    surface_length=40,\n    side_slope=1/3,\n    num_vals=num_vals,\n    surface_elevation=0\n)\n\nmorphometry = nml.NMLMorphometry(\n    H=my_dimensions.get_heights(),\n    A=my_dimensions.get_areas(),\n    bsn_vals=num_vals\n)\n</code></pre>"},{"location":"how_to/how-to-glm_json/","title":"How-to: <code>glm_json</code> module","text":""},{"location":"how_to/how-to-glm_json/#converting-json-to-nml","title":"Converting JSON to <code>.nml</code>","text":"<p>For software development applications, it's often useful to store and transmit the model parameters of a GLM simulation in JSON format. glm-py's <code>glm_json</code>  module provides a <code>JSONReader</code> class that reads a JSON file and returns  dictionaries of model parameters.</p> <p>Consider the following JSON file saved as <code>json_parameters.json</code>:</p> <pre><code>{\n  \"&amp;glm_setup\": {\n    \"sim_name\": \"Sparkling Lake\",\n    \"max_layers\": 500,\n    \"min_layer_vol\": 0.5,\n    \"min_layer_thick\": 0.15,\n    \"max_layer_thick\": 0.5,\n    \"density_model\": 1,\n    \"non_avg\": true\n  },\n  \"&amp;morphometry\": {\n    \"lake_name\": \"Sparkling\",\n    \"latitude\": 46.00881,\n    \"longitude\": -89.69953,\n    \"crest_elev\": 320.0,\n    \"bsn_len\": 901.0385,\n    \"bsn_wid\": 901.0385,\n    \"bsn_vals\": 15,\n    \"H\": [301.712, 303.018285714286, 304.324571428571, 305.630857142857, 306.937142857143, 308.243428571429, 309.549714285714, 310.856, 312.162285714286, 313.468571428571, 314.774857142857, 316.081142857143, 317.387428571429, 318.693714285714, 320, 321],\n    \"A\": [0, 45545.8263571429, 91091.6527142857, 136637.479071429, 182183.305428571, 227729.131785714, 273274.958142857, 318820.7845, 364366.610857143, 409912.437214286, 455458.263571429, 501004.089928571, 546549.916285714, 592095.742642857, 637641.569, 687641.569]\n  },\n  \"&amp;time\": {\n    \"timefmt\": 3,\n    \"start\": \"1980-04-15\",\n    \"stop\": \"2012-12-10\",\n    \"dt\": 3600,\n    \"timezone\": -6,\n    \"num_days\": 730\n  },\n  \"&amp;init_profiles\": {\n    \"lake_depth\": 18.288,\n    \"num_depths\": 3,\n    \"the_depths\": [0, 0.2, 18.288],\n    \"the_temps\": [3, 4, 4],\n    \"the_sals\": [0, 0, 0],\n    \"num_wq_vars\": 6,\n    \"wq_names\": [\"OGM_don\", \"OGM_pon\", \"OGM_dop\", \"OGM_pop\", \"OGM_doc\", \"OGM_poc\"],\n    \"wq_init_vals\": [1.1, 1.2, 1.3, 1.2, 1.3, 2.1, 2.2, 2.3, 1.2, 1.3, 3.1, 3.2, 3.3, 1.2, 1.3, 4.1, 4.2, 4.3, 1.2, 1.3, 5.1, 5.2, 5.3, 1.2, 1.3, 6.1, 6.2, 6.3, 1.2, 1.3]\n  }\n}\n</code></pre> <p>To convert this JSON file to <code>.nml</code>, first import the <code>glm_json</code> module:</p> <pre><code>from glmpy import glm_json\n</code></pre> <p>Then, create an instance of the <code>JSONReader</code> class and provide the path to the  JSON file:</p> <pre><code>json_file = glm_json.JSONReader('json_parameters.json')\n</code></pre> <p>For each configuration block in the JSON file, you can return a dictionary of  model parameters with the <code>get_nml_parameters()</code> method. These can be use to set the attributes of the corresponding <code>nml.NML*</code> class, or be  passed directly to the <code>nml.NML</code> class (note, no error checking will be  applied):</p> <pre><code>glm_setup_attrs = json_file.get_nml_parameters(\"&amp;glm_setup\")\nprint(glm_setup_attrs)\n</code></pre> <pre><code>{'sim_name': 'Sparkling Lake', 'max_layers': 500, 'min_layer_vol': 0.5, 'min_layer_thick': 0.15, 'max_layer_thick': 0.5, 'density_model': 1, 'non_avg': True}\n</code></pre> <pre><code>from glmpy import nml\n\nglm_setup = nml.NMLGLMSetup()\nglm_setup.set_attributes(glm_setup_attrs)\n\nnml = nml.NML(\n  glm_setup=glm_setup(),\n  morphometry=json_file.get_nml_parameters(\"&amp;morphometry\"),\n  time=json_file.get_nml_parameters(\"&amp;time\"),\n  init_profiles=json_file.get_nml_parameters(\"&amp;init_profiles\")\n)\n\nnml.write_nml(nml_file_path='glm3.nml')\n</code></pre>"},{"location":"how_to/how-to-inflows/","title":"How-to: <code>inflows</code> module","text":""},{"location":"how_to/how-to-inflows/#calculating-inflows-from-catchment-runoff","title":"Calculating inflows from catchment runoff","text":"<p>The <code>CatchmentRunoffInflows</code>  class provides functionality for calculating inflows from catchment runoff during  rainfall events. The amount of runoff is calculated as a function of the  catchment area, precipitation, and a runoff coefficient/threshold.</p> <p>To use <code>CatchmentRunoffInflows</code>, you must first have a CSV or  <code>pandas.DataFrame</code> object of precipitation data in an hourly or daily  frequency. Consider the following timeseries:</p> <pre><code>import pandas as pd \n\nmet_data = pd.DataFrame({\n    'Date': pd.date_range(\n        start='1997-01-01',\n        end='2004-12-31',\n        freq='24h'),\n    'Rain': 0.024 #m per day\n})\n</code></pre> <p>We can now initalise the <code>CatchmentRunoffInflows</code> class by passing in this  DataFrame, the catchment area (in m<sup>2</sup>), the date and rainfall column  names, and either a runoff coefficient or a runoff threshold:</p> <pre><code>from glmpy import inflows\n\nmy_inflows = inflows.CatchmentRunoffInflows(\n    met_data=met_data,\n    catchment_area=1000, # a 1000 m^2 catchment area\n    runoff_coef=0.5, \n    precip_col='Rain',\n    date_time_col='Date'\n)\n</code></pre>"},{"location":"how_to/how-to-inflows/#inspect-the-catchment-inflows","title":"Inspect the catchment inflows","text":"<p>Upon calling the <code>get_inflows()</code>  method, <code>CatchmentRunoffInflows</code> will calculate runoff and return a DataFrame of infows in units of m<sup>3</sup>/sec:</p> <pre><code>my_inflows.get_inflows()\n</code></pre> <pre><code>time        flow            \n1997-01-01  0.000139\n1997-01-02  0.000139\n1997-01-03  0.000139\n1997-01-04  0.000139\n1997-01-05  0.000139\n...              ...\n2004-12-27  0.000139\n2004-12-28  0.000139\n2004-12-29  0.000139\n2004-12-30  0.000139\n2004-12-31  0.000139\n\n[2922 rows x 1 columns]\n</code></pre>"},{"location":"how_to/how-to-inflows/#writing-catchment-inflows-to-a-csv","title":"Writing catchment inflows to a CSV","text":"<p>The inflows DataFrame can then be saved to file by simply calling the  <code>write_inflows</code> method:</p> <pre><code>my_inflows.write_inflows(\n    file_path=\"runoff.csv\"\n)\n</code></pre>"},{"location":"how_to/how-to-nml/","title":"How-to: <code>nml</code> module","text":""},{"location":"how_to/how-to-nml/#creating-a-glm-nml-file","title":"Creating a GLM <code>.nml</code> file","text":"<p>Start by importing the <code>nml</code> module from <code>glmpy</code>:</p> <pre><code>from glmpy import nml\n</code></pre>"},{"location":"how_to/how-to-nml/#setting-parameters","title":"Setting parameters","text":"<p>Each \"configuration block\" in a GLM <code>.nml</code> file (e.g., <code>&amp;glm_setup</code>, <code>&amp;morphometry</code>, and <code>&amp;init_profiles</code>) has a respective class in the <code>nml</code> module, e.g., <code>nml.NMLGLMSetup</code>, <code>nml.NMLMorphometry</code>, and <code>nml.NMLInitProfiles</code>. These classes are used to construct dictionaries of model parameters which can be combined in the <code>nml.NML</code> class to write the <code>.nml</code> file. For example, the <code>&amp;glm_setup</code> parameters can be constructed with the <code>NMLGLMSetup</code> class as follows:</p> <pre><code>my_setup = nml.NMLGLMSetup(\n    sim_name='GLMSimulation',\n    max_layers=500,\n    min_layer_vol=0.5,\n    min_layer_thick=0.15,\n    max_layer_thick=0.5,\n    density_model=1,\n    non_avg=True\n)\n</code></pre> <p>Alternatively, the class attributes can be set/updated with the <code>set_attributes()</code> method:</p> <pre><code>my_setup = nml.NMLGLMSetup()\n\nsetup_params = {\n    'sim_name': 'GLMSimulation',\n    'max_layers': 500,\n    'min_layer_vol': 0.5,\n    'min_layer_thick': 0.15,\n    'max_layer_thick': 0.5,\n    'density_model': 1,\n    'non_avg': True\n}\n\nmy_setup.set_attributes(setup_params)\n</code></pre> <p>Refer to the API Reference for detailed information about the parameters for each block.</p>"},{"location":"how_to/how-to-nml/#returning-consolidated-parameters","title":"Returning consolidated parameters","text":"<p>When you call an instance of the <code>NMLGLMSetup</code> class (or any <code>nml.NML*</code> class), a dictionary of consolidated model parameters will be returned. The call method has an optional <code>check_errors</code> parameter that validates your parameters and raises errors if they are not compliant with GLM. Note, error checking is not fully implemented.</p> <pre><code>print(my_setup(check_errors=False))\n</code></pre> <pre><code>{'sim_name': 'GLMSimulation', 'max_layers': 500, 'min_layer_vol': 0.5, 'min_layer_thick': 0.15, 'max_layer_thick': 0.5, 'density_model': 1, 'non_avg': True}\n</code></pre>"},{"location":"how_to/how-to-nml/#writing-the-nml-file","title":"Writing the <code>.nml</code> file","text":"<p>At a minimum, the GLM namelist file (<code>.nml</code>) requires model parameters set for the following blocks:</p> <ul> <li><code>&amp;glm_setup</code> with the <code>NMLGLMSetup</code> class</li> <li><code>&amp;morphometry</code> with the <code>NMLMorphometry</code> class</li> <li><code>&amp;time</code> with the <code>NMLTime</code> class</li> <li><code>&amp;init_profiles</code> with the <code>NMLInitProfiles</code> class</li> </ul> <p>The configured blocks can then be combined into a <code>.nml</code> file with the <code>NML</code> class:</p> <p><pre><code>my_nml = nml.NML(\n    setup=my_setup(),\n    morphometry=my_morphometry(),\n    time=my_time(),\n    init_profiles=my_init_profiles(),\n    check_errors=False\n)\n</code></pre> The <code>NML</code> class also provides an optional <code>check_errors</code> attribute that validates parameters that have dependencies between blocks.</p> <p>To write the <code>.nml</code> file to disk, use the <code>write_nml()</code> method:</p> <pre><code>my_nml.write_nml(nml_file_path='my_nml.nml')\n</code></pre>"},{"location":"how_to/how-to-outflows/","title":"How-to: <code>outflows</code> module","text":""},{"location":"how_to/how-to-outflows/#writing-an-outflows-csv","title":"Writing an outflows CSV","text":"<p>The  <code>CustomOutflows</code>  class supports the creation of outflow CSV files. It  provides a wrapper around the <code>pandas.DataFrame</code> object and converts outflows set in units of m<sup>3</sup>/day, or m<sup>3</sup>/hour, to  m<sup>3</sup>/second.</p>"},{"location":"how_to/how-to-outflows/#creating-the-outflows-dataframe","title":"Creating the outflows DataFrame","text":"<p>To create an outflows CSV, import the outflows module and initalise the <code>CustomOutflows</code> class. The duration of the timeseries is set with the  <code>start_datetime</code> and <code>end_datetime</code> attributes. These attributes can be  provided in the form of a <code>pandas.Timestamp</code>, <code>datetime.datetime</code>, or a valid datetime string. Make sure your <code>start_datetime</code> and <code>end_datetime</code> match the  <code>start</code> and <code>stop</code> parameters used to configure <code>&amp;time</code> block with  <code>NMLTime</code>. Outflows can be defined at an hourly  (<code>1h</code>) or daily frequency (<code>24h</code>) with the <code>frequency</code> attribute. An optional  <code>base_outflow</code> attribute can be used to set a constant outflow. The input units  of <code>base_outflow</code> will be in either m<sup>3</sup>/day or m<sup>3</sup>/hour  depending on the <code>frequency</code> you set.</p> <pre><code>from glmpy import outflows\n\nmy_outflows = outflows.CustomOutflows(\n    start_datetime=\"2020-01-01\",\n    end_datetime=\"2020-01-10\",\n    frequency=\"24h\",\n    base_outflow = 0.0\n)\n</code></pre>"},{"location":"how_to/how-to-outflows/#set-outflows-for-specific-dates","title":"Set outflows for specific dates","text":"<p>By default, the <code>CustomOutflows</code> class will have a constant outflow rate for  the entire simulation period. To set outflows for specific dates, use the  <code>set_on_datetime()</code>  method and provide a dictionary with dates (as keys) and outflows (as values):</p> <pre><code>outflows_dict = {\n    \"2020-01-02\": 2, # 2m^3/day\n    \"2020-01-03\": 4, # 4m^3/day\n    \"2020-01-04\": 6 # 6m^3/day\n}\nmy_outflows.set_on_datetime(outflows_dict)\n</code></pre>"},{"location":"how_to/how-to-outflows/#return-the-outflow-dataframe","title":"Return the outflow DataFrame","text":"<p>To return the <code>pandas.DataFrame</code> of outflows, use the  <code>get_outflows()</code>  method:</p> <pre><code>outflows_dataframe = my_outflows.get_outflows()\nprint(outflows_dataframe)\n</code></pre> <pre><code>        time      flow\n0 2020-01-01  0.000000\n1 2020-01-02  0.000023\n2 2020-01-03  0.000046\n3 2020-01-04  0.000069\n4 2020-01-05  0.000000\n5 2020-01-06  0.000000\n6 2020-01-07  0.000000\n7 2020-01-08  0.000000\n8 2020-01-09  0.000000\n9 2020-01-10  0.000000\n</code></pre>"},{"location":"how_to/how-to-outflows/#set-outflows-over-a-date-range","title":"Set outflows over a date range","text":"<p>Constant outflows can be set over a date range with the  <code>set_over_datetime()</code>  method:</p> <pre><code>outflows.set_over_datetime(\n    from_datetime=\"2020-01-05\",\n    to_datetime = \"2020-01-09\",\n    outflow = 5 # 5m^3/day\n)\n\noutflows_dataframe = my_outflows.get_outflows()\n\nprint(outflows_dataframe)\n</code></pre> <pre><code>        time      flow\n0 2020-01-01  0.000000\n1 2020-01-02  0.000023\n2 2020-01-03  0.000046\n3 2020-01-04  0.000069\n4 2020-01-05  0.000058\n5 2020-01-06  0.000058\n6 2020-01-07  0.000058\n7 2020-01-08  0.000058\n8 2020-01-09  0.000058\n9 2020-01-10  0.000000\n</code></pre>"},{"location":"how_to/how-to-outflows/#writing-the-outflows-file","title":"Writing the outflows file","text":"<p>Once the outflows have been defined, they can be saved as a CSV with the  <code>write_outflows()</code>  method:</p> <pre><code>outflows.write_outflows(file_path=\"outflows.csv\")\n</code></pre>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/category/releases/","title":"Releases","text":""},{"location":"blog/category/tutorials/","title":"Tutorials","text":""}]}